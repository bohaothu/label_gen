


%
%
%
% automatically generated
% % bibtex2html -create-directories -ceon -html-links -icons /home/npalix/Documents/Under Git/Papers/biblio/palix.bib
% Date: Tue May  3 16:24:03 2011

% Author: npalix
%
%
%










@PHDTHESIS{palix:these2008,
   AUTHOR       = {Nicolas Palix},
   SCHOOL       = {Universit√© de Bordeaux I - LaBRI / INRIA Bordeaux - Sud-Ouest},
   TITLE        = {Langages d√©di√©s au d√©veloppement de services de 
      communications},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://tel.archives-ouvertes.fr/tel-00340864/},
   PDF          = {http://tel.archives-ouvertes.fr/docs/00/34/08/64/PDF/these_palix.pdf},
   ABSTRACT     = { IP telephony services use network resources to automate 
      communication stimuli processing. However, deploying services on a 
      telephony system leads to safety issues, and programmers need to 
      ensure some safety properties on their services. Several approaches 
      allowing service development have emerged. Some of them ensure safety 
      properties by restricting expressiveness, limiting the scope of 
      usage. This thesis proposes a new approach that relies on 
      domain-specific languages (DSL) to develop communication services. A 
      domain-specific language is a programming language dedicated to a 
      particular domain. Their expressiveness and verifiability are adapted 
      and specific to a domain. A compiler statically checks critical 
      domain properties. Two new DSLs have been designed for communication 
      services, namely SPL (Session Processing Language) and Pantaxou. The 
      SPL language allows developers to specify routing logic that 
      processes IP telephony signaling. SPL offers abstractions specific to 
      message processing that guarantee the safety properties of IP 
      telephony. The Pantaxou language generalizes the communication 
      service concept introduced by SPL allowing the coordination of 
      communicating entities. The language consists of two parts: the first 
      one enables the description of an environment of communicating 
      entities; the second one expresses the coordination scenarios between 
      these entities. These scenarios must ensure some constrains with 
      respect to the environment description. Two compilers ensure the 
      environment consistency and the scenarios consistency regarding the 
      environment. The contributions of this thesis are as follows: (1) We 
      carry out an analysis of communication services. This analysis 
      focuses on communication services based on the SIP protocol. Existing 
      approaches for developing SIP-based communication services are 
      presented. (2) We present the design and implementation of a 
      language, named SPL, for programming routing services. Various 
      analyses for this language ensure critical properties of the SIP 
      protocol. (3) We generalize the service development to entity 
      services. We have designed a language, named Pantaxou, that 
      introduces a two-step process for the development of coordination 
      services, enabling early verification during the development process. 
      (4) The design and implementation of these languages improve the 
      development process of communication services and especially their 
      safety. Beyond the domain of telephony services, our DSL-based 
      approach opens up new possibilities for the development of 
      distributed services in the field of ubiquitous computing. }
}

@ARTICLE{lawall-al:ercim10,
   AUTHOR       = {Julia L. Lawall and Ren√© Rydhof Hansen and 
      Nicolas Palix and Gilles Muller},
   JOURNAL      = {ERCIM News},
   TITLE        = {Improving the Security of Infrastructure Software using 
      Coccinelle},
   YEAR         = {2010},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   PAGES        = {54},
   VOLUME       = {83},
   KEYWORDS     = {Coccinelle, Herodotos, LLVM, CLang},
   URL          = {http://ercim-news.ercim.eu/en83},
   PDF          = {http://ercim-news.ercim.eu/images/stories/EN83/EN83-web.pdf},
   ABSTRACT     = {Finding and fixing programming errors in deployed 
      software is often a slow, painstaking, and expensive process. In 
      order to minimise this problem, static analysis is increasingly being 
      adopted as a way to find programming errors before the software 
      application is released. Coccinelle is a program matching and 
      transfor-mation tool that makes it easy for developers to express 
      static analysis-based software defect-finding rules and scan software 
      source code for potential defects.}
}

@ARTICLE{burgy-consel-al:ercim05,
   AUTHOR       = {L. Burgy and C. Consel and F. Latry and L. R√©veill√®re and 
      N. Palix},
   JOURNAL      = {ERCIM News},
   TITLE        = {Telephony over IP: Experience and Challenges},
   YEAR         = {2005},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   PAGES        = {53--54},
   VOLUME       = {63},
   KEYWORDS     = {SIP, IP Telephony},
   URL          = {http://www.ercim.org/publication/Ercim_News/enw63/consel.html},
   PDF          = {http://www.ercim.org/publication/Ercim_News/enw63/EN63.pdf},
   ABSTRACT     = {Telephony over IP (ToIP) makes it possible to program 
      telephony platforms that have long been kept closed and proprietary. 
      As new services are developed that enrich telephony with complex 
      features such as database access, Web service invocation, and agenda 
      look-up, the telephony platform is increasingly exposed to software 
      bugs. Because telephony is heavily relied on, the success of its 
      evolution to IP critically depends on the reliability of services.}
}

@INPROCEEDINGS{palix:asplos11,
   AUTHOR       = {Nicolas Palix and Ga√´l Thomas and Suman Saha and 
      Christophe Calv√®s and Julia Lawall and Gilles Muller},
   BOOKTITLE    = {Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2011)},
   TITLE        = {Faults in Linux: Ten Years Later},
   YEAR         = {2011},
   ADDRESS      = {Newport Beach, California, USA},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {305--318},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Linux, Coccinelle, Herodotos},
   URL          = {http://doi.acm.org/10.1145/1950365.1950401},
   PDF          = {http://proton.inrialpes.fr/~npalix/papers/asplos11-palix.pdf},
   ABSTRACT     = { In 2001, Chou et al. published a study of faults found 
      by applying a static analyzer to Linux versions 1.0 through 2.4.1. A 
      major result of their work was that the drivers directory contained 
      up to 7 times more of certain kinds of faults than other directories. 
      This result inspired a number of development and research efforts on 
      improving the reliability of driver code. Today, however, Linux is 
      used in a much wider range of environments, provides a much wider 
      range of services, and has adopted a new development and release 
      model. What has been the impact of these changes on code quality? Are 
      drivers still a major problem? To answer these questions, we have 
      attempted to transport, based on the information provided, the 
      experiments of Chou et al. to Linux versions 2.6.0 to 2.6.33, 
      released between late 2003 and early 2010. We find that even if Linux 
      has more than doubled in size during this period, the number of 
      faults per line of code has been decreasing. And, even though drivers 
      still accounts for a large part of the kernel code and contains the 
      most faults, its fault rate is now below that of other directories, 
      such as arch (HAL) and fs (file systems). Such information can guide 
      further development and research efforts. To enable others to 
      continually update the results as Linux evolves, we define our 
      experimental protocol and make our checkers and results available in 
      a public archive. },
   DOI          = {10.1145/1950365.1950401}
}

@INPROCEEDINGS{lawall:edcc10,
   AUTHOR       = {Julia Lawall and Ben Laurie and Rydhof Hansen, Ren√© and 
      Nicolas Palix and Gilles Muller},
   BOOKTITLE    = {Proceeding of the 8th European Dependable Computing Conference, EDCC 2010},
   TITLE        = {Finding Error Handling Bugs in OpenSSL using Coccinelle},
   YEAR         = {2010},
   ADDRESS      = {Valencia, Spain},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {April},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software quality, Software evolution, 
      Static code analysis},
   ABSTRACT     = { OpenSSL is a library providing various functionalities 
      relating to secure network communication. Detecting and fixing bugs 
      in OpenSSL code is thus essential, particularly when such bugs can 
      lead to malicious attacks. In previous work, we have proposed a 
      methodology for finding API usage protocols in Linux kernel code 
      using the program matching and transformation engine Coccinelle. In 
      this work, we report on our experience in applying this methodology 
      to OpenSSL, focusing on API usage protocols related to error 
      handling. This work has resulted in detection of over 30 bugs in a 
      recent snapshot of OpenSSL, and in many cases it was possible to 
      correct the bugs automatically. Our patches correcting these bugs 
      have been accepted by the OpenSSL developers. This work furthermore 
      confirms the applicability of our methodology to user-level code. }
}

@INPROCEEDINGS{Olesen:opencert10,
   AUTHOR       = {Mads Chr. Olesen and Ren√© Rydhof Hansen and 
      Julia L. Lawall and Nicolas Palix},
   BOOKTITLE    = {4th International Workshop on Foundations and Techniques for Open Source Software Certification},
   TITLE        = {Clang and Coccinelle: Synergising program analysis tools 
      for CERT C Secure Coding Standard certification},
   YEAR         = {2010},
   ADDRESS      = {Pisa, Italy},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {automated tool support, CERT C Secure Coding, 
      certification, Clang, Coccinelle},
   ABSTRACT     = { Writing correct C programs is well-known to be hard, 
      not least due to the many language features intrinsic to C. Writing 
      secure C programs is even harder and, at times, seemingly impossible. 
      To improve on this situation the US CERT has developed and published 
      a set of coding standards, the ‚ÄúCERT C Secure Coding Standard‚Äù, 
      that (in the current version) enumerates 118 rules and 182 
      recommenda- tions with the aim of making C programs (more) secure. 
      The large number of rules and recommendations makes automated tool 
      support essential for certifying that a given system is in compliance 
      with the standard. In this paper we report on ongoing work on 
      integrating two state of the art analysis tools, Clang and 
      Coccinelle, into a combined tool well suited for analysing and 
      certifying C programs according to, e.g., the CERT C Secure Coding 
      standard or the MISRA (the Motor Industry Software Reliability 
      Assocation) C standard. We further argue that such a tool must be 
      highly adaptable and customisable to each software project as well as 
      to the certification rules required by a given standard. Clang is the 
      C frontend for the LLVM compiler/virtual machine project which in- 
      cludes a comprehensive set of static analyses and code checkers. 
      Coccinelle is a program transformation tool and bug-finder developed 
      originally for the Linux ker- nel, but has been successfully used to 
      find bugs in other Open Source projects such as WINE and OpenSSL. }
}

@INPROCEEDINGS{palix:aosd10,
   AUTHOR       = {Nicolas Palix and Julia Lawall and Gilles Muller},
   BOOKTITLE    = {Proceeding of the ACM International Conference on Aspect-Oriented Software Development, AOSD'10},
   TITLE        = {Tracking Code Patterns over Multiple Software Versions 
      with Herodotos},
   YEAR         = {2010},
   ADDRESS      = {Rennes and Saint Malo, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {169-180},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Occurrence histories, Software quality, 
      Software evolution, Static code analysis, Coccinelle, Herodotos},
   URL          = {http://proton.inrialpes.fr/~npalix/papers/aosd10-palix.pdf},
   PDF          = {http://proton.inrialpes.fr/~npalix/papers/aosd10-palix.pdf},
   ABSTRACT     = { An important element of understanding a software code 
      base is to identify the repetitive patterns of code it contains and 
      how these evolve over time. Some patterns are useful to the software, 
      and may be modularized. Others are detrimental to the software, such 
      as patterns that represent defects. In this case, it is useful to 
      study the occurrences of such patterns, to identify properties such 
      as when and why they are introduced, how long they persist, and the 
      reasons why they are corrected. To enable studying pattern 
      occurrences over time, we propose a tool, Herodotos, that 
      semi-automatically tracks pattern occurrences over multiple versions 
      of a software project, independent of other changes in the source 
      files. Guided by a user-provided configuration file, Herodotos builds 
      various graphs showing the evolution of the pattern occurrences and 
      computes some statistics. We have evaluated this approach on the 
      history of a representative range of open source projects over the 
      last three years. For each project, we track several kinds of defects 
      that have been found by pattern matching. This tracking is done 
      automatically in 99% of the occurrences. The results allow us to 
      compare the evolution of the selected projects and defect kinds over 
      time. },
   DOI          = {10.1145/1739230.1739250}
}

@INPROCEEDINGS{acp4is10,
   AUTHOR       = {Nicolas Palix and Julia L. Lawall and Ga√´l Thomas and 
      Gilles Muller},
   BOOKTITLE    = {ACP4IS '10: Proceedings of the 9th workshop on Aspects, components, and patterns for infrastructure software},
   TITLE        = {How Often do Experts Make Mistakes?},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {9--15},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {DSL, Coccinelle, Herodotos},
   URL          = {http://proton.inrialpes.fr/~npalix/papers/acp4is10-palix.pdf},
   PDF          = {http://opus.kobv.de/ubp/volltexte/2010/4122/},
   ABSTRACT     = {Large open-source software projects involve developers 
      with a wide variety of backgrounds and expertise. Such software 
      projects furthermore include many internal APIs that developers must 
      understand and use properly. According to the intended purpose of 
      these APIs, they are more or less frequently used, and used by 
      developers with more or less expertise. In this paper, we study the 
      impact of usage patterns and developer expertise on the rate of 
      defects occurring in the use of internal APIs. For this preliminary 
      study, we focus on memory management APIs in the Linux kernel, as the 
      use of these has been shown to be highly error prone in previous 
      work. We study defect rates and developer expertise, to consider 
      e.g., whether widely used APIs are more defect prone because they are 
      used by less experienced developers, or whether defects in widely 
      used APIs are more likely to be fixed.}
}

@INPROCEEDINGS{jouve-al:gdr-gpl09,
   AUTHOR       = {Wilfried Jouve and Nicolas Palix and Charles Consel and 
      Patrice Kadionik},
   BOOKTITLE    = {Journ√©es nationales du groupe de recherche g√©nie de la programmation et du logiciel},
   TITLE        = {G√©n√©ration de canevas de programmation d√©di√©s pour 
      les applications de t√©l√©phonie avanc√©es},
   YEAR         = {2009},
   ADDRESS      = {Toulouse, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {January},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {54--55},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{lawall09:_wysiw,
   AUTHOR       = {Julia L. Lawall and Julien Brunel and Nicolas Palix and 
      Ren√© Rydhof Hansen and Henrik Stuart and Gilles Muller},
   BOOKTITLE    = {Proceeding of the International Conference on Dependable Systems and Networks},
   TITLE        = {WYSIWIB: A Declarative Approach to Finding API Protocols 
      and Bugs in Linux Code},
   YEAR         = {2009},
   ADDRESS      = {Estoril (Lisbon), Portugal},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {43--52},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {DSL, Coccinelle},
   PDF          = {http://www.diku.dk/hjemmesider/ansatte/julia/dsn09.pdf},
   ABSTRACT     = { Eliminating OS bugs is essential to ensuring the 
      reliability of infrastructures ranging from embedded systems to 
      servers. Several tools based on static analysis have been proposed 
      for finding bugs in OS code. They have, however, emphasized 
      scalability over usability, making it difficult to focus the tools on 
      specific kinds of bugs and to relate the results to patterns in the 
      source code. We propose a declarative approach to bug finding in 
      Linux OS code using a control-flow based program search engine. Our 
      approach is WYSIWIB (What You See Is Where It Bugs), since the 
      programmer expresses specifications for bug finding using a syntax 
      close to that of ordinary C code. The key advantage of our approach 
      is that search specifications can be easily tailored, to eliminate 
      false positives or catch more bugs. We present three case studies 
      that have allowed us to find hundreds of potential bugs. },
   DOI          = {10.1109/DSN.2009.5270354}
}

@INPROCEEDINGS{Lawall:acp4is09,
   AUTHOR       = {Julia L. Lawall and Gilles Muller and Nicolas Palix},
   BOOKTITLE    = {ACP4IS '09: Proceedings of the 8th workshop on Aspects, components, and patterns for infrastructure software},
   TITLE        = {Enforcing the Use of API Functions in Linux Code},
   YEAR         = {2009},
   ADDRESS      = {New York, NY, USA},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {7--11},
   PUBLISHER    = {ACM},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {DSL, Coccinelle},
   URL          = {http://portal.acm.org/citation.cfm?doid=1509276.1509279},
   PDF          = {http://www.diku.dk/hjemmesider/ansatte/julia/acp4is09-lawall.pdf},
   ABSTRACT     = { In the Linux kernel source tree, header files typically 
      define many small functions that have a simple behavior but are 
      critical to ensure readability, correctness, and maintainability. We 
      have observed, however, that some Linux code does not use these 
      functions systematically. In this paper, we propose an approach 
      combining rule-based program matching and transformation with 
      generative programming to generate rules for finding and fixing code 
      fragments that should use the functions defined in header files. We 
      illustrate our approach using an in-depth study based on four typical 
      functions defined in the header file include/linux/usb.h. },
   DOI          = {10.1145/1509276.1509279}
}

@INPROCEEDINGS{palix:2009:cfse,
   AUTHOR       = {Nicolas Palix},
   BOOKTITLE    = {7e Conf√©rence Francaise en Syst√®mes d'Exploitation (CFSE)},
   TITLE        = {Herodotos, l'historien de vos d√©fauts},
   YEAR         = {2009},
   ADDRESS      = {Toulouse, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Herodotos},
   PDF          = {http://www.irit.fr/Toulouse2009/Toulouse2009/papiers/cfse8.pdf},
   ABSTRACT     = {Les logiciels √©voluent continuellement afin 
      d'am√©liorer les performances, corriger les erreurs, ou ajouter des 
      fonctionnalit√©s. Cependant, les modifications du code conduisent 
      in√©vitablement √ l'introduction de d√©fauts logiciels. Pour 
      pr√©venir l'introduction de fautes, il est n√©cessaire de comprendre 
      pourquoi elles surviennent. Il est donc important de d√©velopper des 
      outils et des pratiques aidant √ trouver, suivre et pr√©venir ces 
      d√©fauts. Dans cet article, nous proposons une m√©thodologie et son 
      outil associ√©, Herodotos, permettant d'√©tudier les fautes dans le 
      temps et d'ainsi d√©terminer le moment de leur apparition et de leur 
      disparition. Herodotos suit, de mani√®re semi-automatis√©e, les 
      fautes sur plusieurs versions d'un m√™me projet ind√©pendamment des 
      modifications annexes dans les fichiers sources. Il construit des 
      historiques graphiques et calcule des statistiques sur la vie des 
      fautes. Nous avons √©valu√© cette approche sur l'historique de quatre 
      projets open source sur les trois derni√®res ann√©es. Pour chaque 
      projet, nous explorons plusieurs types de fautes qui ont √©t√© 
      trouv√©es par une analyse statique du code. Nous analysons les 
      r√©sultats produits pour comparer les projets s√©lectionn√©s et les 
      types de fautes √©tudi√©es.}
}

@INPROCEEDINGS{jouve-lancia-palix-al:percom2008,
   AUTHOR       = {W. Jouve and J. Lancia and N. Palix and C. Consel and 
      J. Lawall},
   BOOKTITLE    = {Proceedings of the 6th IEEE Conference on Pervasive Computing and Communications (PERCOM'08)},
   TITLE        = {High-level Programming Support for Robust Pervasive 
      Computing Applications},
   YEAR         = {2008},
   ADDRESS      = {Hong Kong, China},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {252--255},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Pervasive, Middleware, Generation, 
      Programming Framework, DiaGen},
   URL          = {http://hal.inria.fr/inria-00333602/},
   PDF          = {http://hal.inria.fr/docs/00/33/36/02/PDF/jouve-al_percom08.pdf},
   PS           = {http://hal.inria.fr/docs/00/33/36/02/ANNEX/jouve-al_percom08_poster.pdf},
   ABSTRACT     = {In this paper, we present a domain-specific Interface 
      Definition Language (IDL) and its compiler, dedicated to the 
      development of pervasive computing applications. Our IDL provides 
      declarative support for concisely characterizing a pervasive 
      computing environment. This description is (1) to be used by 
      programmers as a high-level reference to develop applications that 
      coordinate entities of the target environment and (2) to be passed to 
      a compiler that generates a programming framework dedicated to the 
      target environment. This process enables verifications to be 
      performed prior to runtime on both the declared environment and a 
      given application. Furthermore, customized operations are 
      automatically generated to support the development of pervasive 
      computing activities, such as service discovery and session 
      negotiation for stream-oriented devices. },
   DOI          = {10.1109/PERCOM.2008.9}
}

@INPROCEEDINGS{jouve-palix-al:iptcomm2008,
   AUTHOR       = {W. Jouve and N. Palix and C. Consel and P. Kadionik},
   BOOKTITLE    = {Proceedings of The 2nd LNCS Conference on Principles, Systems and Applications of IP Telecommunications (IPTComm'08)},
   TITLE        = {A SIP-based Programming Framework for Advanced Telephony 
      Applications},
   YEAR         = {2008},
   ADDRESS      = {Heidelberg, Germany},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {July},
   NOTE         = {Best Student Paper Award},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {1--20},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {IP Telephony, SIP, Middleware, Generation, 
      Programming Framework, DiaGen},
   URL          = {http://hal.inria.fr/inria-00333609/},
   PDF          = {http://hal.inria.fr/docs/00/33/36/09/PDF/jouve-al_iptcomm08.pdf},
   PS           = {http://hal.inria.fr/docs/00/33/36/09/ANNEX/jouve-al_iptcomm08_talk.pdf},
   ABSTRACT     = {The scope of telephony is significantly broadening, 
      providing users with a variety of communication modes, including 
      presence status, instant messaging and videoconferencing. 
      Furthermore, telephony is being increasingly combined with a number 
      of non-telephony, heterogeneous resources, consisting of software 
      entities, such as Web services, and hardware entities, such as 
      location-tracking devices. This heterogeneity, compounded with the 
      intricacies of underlying technologies, make the programming of new 
      telephony applications a daunting task. This paper proposes an 
      approach to supporting the development of advanced telephony 
      applications. To do so, we introduce a declarative language over Java 
      to define the entities of a target telephony application area. This 
      definition is passed to a generator to produce a Java programming 
      framework, dedicated to the application area. The generated 
      frameworks provide service discovery and high-level communication 
      mechanisms. These mechanisms are automatically mapped into SIP, 
      making our approach compatible with existing SIP infrastructures and 
      entities. Our work is implemented and has been validated on various 
      advanced telephony applications. },
   DOI          = {10.1007/978-3-540-89054-6_1}
}

@INPROCEEDINGS{mercadal-palix-al:gpce2008,
   AUTHOR       = {J. Mercadal and N. Palix and C. Consel and J. Lawall},
   BOOKTITLE    = {Proceedings of the Seventh International Conference on Generative Programming and Component Engineering (GPCE)},
   TITLE        = {Pantaxou: a Domain-Specific Language for Developing Safe 
      Coordination Services},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {149--160},
   PUBLISHER    = {ACM},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Pantaxou, Generation, Programming Framework},
   URL          = {http://hal.inria.fr/inria-00333637/},
   PDF          = {http://hal.inria.fr/docs/00/33/36/37/PDF/mercadal-al_gpce08.pdf},
   ABSTRACT     = {Coordinating entities in a networked environment has 
      always been a significant challenge for software developers. In 
      recent years, however, it has become even more difficult, because 
      devices have increasingly rich capabilities, combining an ever larger 
      range of technologies (networking, multimedia, sensors, etc.). To 
      address this challenge, we propose a language-based approach to 
      covering the life-cycle of applications coordinating networked 
      entities. Our approach covers the characterization of the networked 
      environment, the specification of coordination applications, the 
      verification of a networked environment and its deployment. It is 
      carried out in practice by a domain-specific language, named 
      Pantaxou. This paper presents the domain-specific language Pantaxou, 
      dedicated to the development of applications for networked 
      heterogeneous entities. Pantaxou has been used to specify a number of 
      coordination scenarios in areas ranging from home automation to 
      telecommunications. The language semantics has been formally defined 
      and a compiler has been developed. The compiler verifies the 
      coherence of a coordination scenario and generates coordination code 
      in Java.},
   DOI          = {10.1145/1449913.1449936}
}

@INPROCEEDINGS{consel-jouve-al:perware2007,
   AUTHOR       = {C. Consel and W. Jouve and J. Lancia and N. Palix},
   BOOKTITLE    = {Proceedings of The 4th IEEE Workshop on Middleware Support for Pervasive Computing (PerWare'07)},
   TITLE        = {Ontology-Directed Generation of Frameworks For Pervasive 
      Service Development},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {501--506},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Pervasive, Generation, Programming Framework, 
      Middleware, DiaGen},
   URL          = {http://hal.archives-ouvertes.fr/hal-00306009/},
   PDF          = {http://hal.archives-ouvertes.fr/docs/00/30/60/09/PDF/consel_al_perware_0_.pdf},
   PS           = {http://hal.archives-ouvertes.fr/docs/00/30/60/09/ANNEX/consel-al_perware07_talk.pdf},
   ABSTRACT     = {Pervasive computing applications are tedious to develop 
      because they combine a number of problems ranging from device 
      heterogeneity, to middleware constraints, to lack of programming 
      support. In this paper, we present an approach to integrating the 
      ontological description of a pervasive computing environment into a 
      programming language, namely Java. From this ontological description 
      of a pervasive computing environment, a framework is automatically 
      generated. It provides the developer with dedicated programming 
      support to manage, discover and invoke services. Besides, it performs 
      a number of verifications both at compile and run time, ensuring the 
      robustness of applications. },
   DOI          = {10.1109/PERCOMW.2007.91}
}

@INPROCEEDINGS{palix-reveillere-al:iptcomm2007,
   AUTHOR       = {N. Palix and C. Consel and L. R√©veill√®re and J. Lawall},
   BOOKTITLE    = {Proceedings of Principles, Systems and Applications of IP Telecommunications, IPTComm},
   TITLE        = {A Stepwise Approach to Developing Languages for SIP 
      Telephony Service Creation},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {79--88},
   PUBLISHER    = {ACM},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {IP Telephony, SIP, DSL, SPL},
   URL          = {http://hal.inria.fr/inria-00196520/},
   PDF          = {http://hal.inria.fr/docs/00/19/65/20/PDF/palix-reveillere-al_iptcomm07.pdf},
   PS           = {http://hal.inria.fr/docs/00/19/65/20/ANNEX/palix-reveillere-al_iptcomm07_talk.pdf},
   ABSTRACT     = {Developing a SIP-based telephony service requires a pro- 
      grammer to have expertise in telephony rules and constraints, the SIP 
      protocol, distributed systems, and a SIP API, which is often large 
      and complex. These requirements make the development of telephony 
      software an overwhelming challenge. To overcome this challenge, 
      various programming languages have been proposed to develop telephony 
      services. Nevertheless, none of these languages as yet has a formal 
      semantics. Therefore, the reference implementation, which may not be 
      available, becomes the only source of information for the programmer 
      to understand the subtleties of the language. Furthermore, this 
      situation makes it dificult for third-party developers to port the 
      language to another runtime system or to provide another 
      implementation of the runtime system. This paper presents a 
      semantics-based stepwise approach for designing and developing a 
      scripting language dedicated to the development of telephony 
      services. This approach enables critical properties of services to be 
      guaranteed and captures expertise on the operational behavior of a 
      service. We have applied this approach to developing the Session 
      Processing Language (SPL) dedicated to SIP-based service creation. A 
      variety of services have been written in SPL for our university 
      department. },
   DOI          = {10.1145/1326304.1326317}
}

@INPROCEEDINGS{burgy-consel-al:icc2006,
   AUTHOR       = {L. Burgy and C. Consel and F. Latry and J. Lawall and 
      N. Palix and L. R√©veill√®re},
   BOOKTITLE    = {IEEE International Conference on Communications},
   TITLE        = {Language Technology for Internet-Telephony Service 
      Creation},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {1795--1800},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {IP Telephony, SIP, DSL, SPL},
   URL          = {http://hal.inria.fr/inria-00196518/},
   PDF          = {http://hal.inria.fr/docs/00/19/65/18/PDF/icc2006_PID183688.pdf},
   PS           = {http://hal.inria.fr/docs/00/19/65/18/ANNEX/icc06.pdf},
   ABSTRACT     = {Telephony is evolving at a frantic pace, critically 
      relying on the development of services to offer a host of new 
      functionalities. However, programming Internet telephony services 
      requires an intimate knowledge of a variety of protocols and 
      technologies, which can be a challenge for many programmers. 
      Furthermore, because telephony is a resource heavily relied on, 
      programmability of telephony platforms should not compromise their 
      robustness. This paper presents an approach to creating telephony 
      services that builds on programming language technology (i.e., 
      language design and implementation, language semantics, and program 
      analysis). We have developed a language, named Session Processing 
      Language (SPL), that offers domain-specific constructs, abstracting 
      over the intricacies of the underlying technologies. By design, SPL 
      guarantees critical properties that cannot be verified in 
      general-purpose languages. SPL relies on a Service Logic Execution 
      Environment for SIP (SIP-SLEE) that introduces a design framework for 
      service development based around the notion of session. SPL and 
      SIP-SLEE have been implemented and they are now being used to develop 
      and deploy real services, demonstrating the practical benefits of our 
      approach. },
   DOI          = {10.1109/ICC.2006.254980}
}

@INPROCEEDINGS{burgy-consel-al:icin2006,
   AUTHOR       = {L. Burgy and C. Consel and F. Latry and N. Palix and 
      L. R√©veill√®re},
   BOOKTITLE    = {Proceedings of the tenth International Conference on Intelligence in service delivery Networks (ICIN 2006)},
   TITLE        = {A High-Level, Open Ended Architecture For SIP-based 
      Services},
   YEAR         = {2006},
   ADDRESS      = {Bordeaux, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {364--365},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {IP Telephony, SIP, DSL, SPL},
   URL          = {http://hal.inria.fr/inria-00196516/},
   PDF          = {http://hal.inria.fr/docs/00/19/65/16/PDF/icin06-archi.pdf},
   PS           = {http://hal.inria.fr/docs/00/19/65/16/ANNEX/icin06-pA4.pdf}
}

@TECHREPORT{Palix:RR7357,
   AUTHOR       = {Nicolas Palix and Suman Saha and Ga√´l Thomas and 
      Christophe Calv√®s and Julia Lawall and Gilles Muller},
   INSTITUTION  = {INRIA},
   TITLE        = {Faults in Linux: Ten Years Later},
   YEAR         = {2010},
   OPTADDRESS   = {},
   MONTH        = {August},
   OPTNOTE      = {},
   NUMBER       = {RR-7357},
   TYPE         = {Research report},
   URL          = {http://hal.inria.fr/inria-00509256/},
   PDF          = {http://hal.inria.fr/docs/00/50/92/56/PDF/RR-7357.pdf},
   ABSTRACT     = { In 2001, Chou et al. published a study of faults found 
      by applying a static analyzer to Linux versions 1.0 through 2.4.1. A 
      major result of their work was that the drivers directory contained 
      up to 7 times more of certain kinds of faults than other directories. 
      This result inspired a number of development and research efforts on 
      improving the reliability of driver code. Today, however, Linux is 
      used in a much wider range of environments, provides a much wider 
      range of services, and has adopted a new development and release 
      model. What has been the impact of these changes on code quality? Are 
      drivers still a major problem? To answer these questions, we have 
      attempted to transport, based on the information provided, the 
      experiments of Chou et al. to Linux versions 2.6.0 to 2.6.33, 
      released between late 2003 and early 2010. We find that even if Linux 
      has more than doubled in size during this period, the number of 
      faults per line of code has been decreasing. And, even though drivers 
      still accounts for a large part of the kernel code and contains the 
      most faults, its fault rate is now below that of other directories, 
      such as arch (HAL) and fs (file systems). Such information can guide 
      further development and research efforts. To enable others to 
      continually update the results as Linux evolves, we define our 
      experimental protocol and make our checkers and results available in 
      a public archive. }
}

@TECHREPORT{PALIX:2009:INRIA-00406306:1,
   AUTHOR       = {Nicolas Palix and Julia Lawall and Gilles Muller},
   INSTITUTION  = {INRIA},
   TITLE        = {Herodotos: A Tool to Expose Bugs' Lives},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {RR-6984},
   TYPE         = {Research Report},
   KEYWORDS     = {Occurrence histories, Software quality, 
      Software evolution, Static code analysis, Coccinelle, Herodotos},
   PAGES        = {16},
   URL          = {http://hal.inria.fr/inria-00406306/},
   PDF          = {http://hal.inria.fr/docs/00/40/63/06/PDF/RR-6984.pdf},
   ABSTRACT     = {Software is continually evolving, to improve 
      performance, correct errors, and add new features. Code 
      modifications, however, inevitably lead to the introduction of 
      defects. To prevent the introduction of defects, one has to 
      understand why they occur. Thus, it is important to develop tools and 
      practices that aid in defect finding, tracking and prevention. In 
      this paper, we propose a methodology and associated tool, Herodotos, 
      to study defects over time. Herodotos semi-automatically tracks 
      defects over multiple versions of a software project, independent of 
      other changes in the source files. It builds a graphical history of 
      each defect and gives some statistics based on the results. We have 
      evaluated this approach on the history of a representative range of 
      open source projects over the last three years. For each project, we 
      explore several kinds of defects that have been found by static code 
      analysis. We analyze the generated results to compare the selected 
      software projects and defect kinds.}
}

@MISC{BURGY:2008:INRIA-00350014:1,
   AUTHOR       = {Laurent Burgy and Charles Consel and Fabien Latry and 
      Nicolas Palix and Laurent R√©veill√®re},
   HOWPUBLISHED = {European Patent no. EP1887774},
   MONTH        = {February},
   OPTNOTE      = {},
   TITLE        = {Routing device for an IP telephony system},
   YEAR         = {2008},
   URL          = {http://hal.inria.fr/inria-00350014/},
   PDF          = {http://www.freepatentsonline.com/EP1887774.pdf}
}

@MASTERSTHESIS{palix04:master,
   AUTHOR       = {Nicolas Palix},
   SCHOOL       = {Universit√© de Grenoble I - INRIA Rh√¥ne-Alpes},
   TITLE        = {Mod√©lisation et traduction de syst√®mes sur puce √ base 
      de composants},
   YEAR         = {2004},
   ADDRESS      = {Montbonnot Saint Martin},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www.inrialpes.fr/pop-art/people/palix/},
   PDF          = {http://www.inrialpes.fr/pop-art/people/palix/rapport.pdf},
   PS           = {http://www.inrialpes.fr/pop-art/people/palix/presentation.pdf.gz},
   ABSTRACT     = {This report describes a methodology allowing to 
      translate a SystemC description of a system on chip (SoC) in a 
      layered component-based system consisting of transitions systems with 
      constraints. This translation is formalized as much as possible but 
      must be extended yet. Only simple and frequently used constructs are 
      currently taken into account. The compositionnal aspect allows to 
      reuse components in SystemC but also in Prometheus, tool implementing 
      the component-based verification. The compiler framework respect the 
      modular and component-based framework and is regarded as easily 
      extensible to manage the more complex constructs of SystemC and C++.}
}

