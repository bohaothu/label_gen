%%% -*-BibTeX-*-
%%% ====================================================================
%%%  BibTeX-file{
%%%     author          = "Nelson H. F. Beebe",
%%%     version         = "1.10",
%%%     date            = "16 September 2011",
%%%     time            = "12:52:16 MDT",
%%%     filename        = "java2010.bib",
%%%     address         = "University of Utah
%%%                        Department of Mathematics, 110 LCB
%%%                        155 S 1400 E RM 233
%%%                        Salt Lake City, UT 84112-0090
%%%                        USA",
%%%     telephone       = "+1 801 581 5254",
%%%     FAX             = "+1 801 581 4148",
%%%     URL             = "http://www.math.utah.edu/~beebe",
%%%     checksum        = "61516 5003 24247 233355",
%%%     email           = "beebe at math.utah.edu, beebe at acm.org,
%%%                        beebe at computer.org (Internet)",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "bibliography; BibTeX; HotJava; HotJava;
%%%                        HotJavaBean; HTML; Java; Java3D; JavaBean;
%%%                        JavaChip; JavaCUP; JavaDev; JavaDump;
%%%                        JavaEngine; JavaLanche; JavaLex; JavaMan;
%%%                        JavaManagement; JavaOne; JavaOS; JavaPVM;
%%%                        JavaQ; JavaScript; JavaSoft; JavaSpace;
%%%                        JavaStation; JavaStations; JavaStudio;
%%%                        JavaTalk; JBuilder; JChat; JClass; Jcon;
%%%                        JDKs; JetAssist; JetForm; JFactory; JLex;
%%%                        JPython; JRes; JSafe; JScape; JScript;
%%%                        JScriptTest; JSpace; JTable; JTAPI; KJPrice;
%%%                        MacJava; MetaJava; NexusJava; PersonalJava;
%%%                        picoJava; PJAmi; PowerJ; SpecJava; TclJava;
%%%                        TowerJ; World Wide Web; WWW",
%%%     license         = "public domain",
%%%     supported       = "yes",
%%%     docstring       = "This bibliography records books and other
%%%                        publications about the Java programming
%%%                        language, and related software, for the years
%%%                        2010--2019.  The companion bibliography,
%%%                        java.bib, covers the years 1995--1999, and
%%%                        java2000.bib covers 2000--2009.
%%%
%%%                        At version 1.10, year coverage looked
%%%                        like this:
%%%
%%%                             2010 (  86)    2011 (  32)
%%%
%%%                             Article:        112
%%%                             Book:             6
%%%
%%%                             Total entries:  118
%%%
%%%                        Further information on Java development and
%%%                        the HotJava WorldWideWeb browser can be
%%%                        found at the URL http://java.sun.com/.
%%%                        Netscape versions 2.03-beta or later
%%%                        support Java as well.
%%%
%%%                        A Java applet index and repository is
%%%                        available at http://www.gamelan.com/.
%%%
%%%                        Visix has extended their
%%%                        platform-independent window systems support
%%%                        to include Java; details are at
%%%                        http://www.visix.com/
%%%
%%%                        A tutorial on Java is available at
%%%                        http://java.sun.com/tutorial, a white paper
%%%                        on the Java language is at
%%%                        http://java.sun.com/1.0alpha3/doc/overview/
%%%                        java/index.html, and a white paper on the
%%%                        HotJava browser is at http://java.sun.com/
%%%                        1.0alpha3/doc/overview/hotjava/index.html.
%%%
%%%                        A status report on Java security problems
%%%                        is available at http://java.sun.com/sfaq;
%%%                        a good discussion of these issues can be
%%%                        found in the reference Hamilton:1996:JSN
%%%                        below.
%%%
%%%                        John December maintains a Java bibliography
%%%                        that includes press releases and online
%%%                        references at http://www.december.com/john//
%%%                        works/java/bib.html; a snapshot of that
%%%                        collection was incorporated in this
%%%                        bibliography on 17-Dec-1995.
%%%
%%%                        The Web site for Java World magazine is at
%%%                        http://www.javaworld.com/; many entries in
%%%                        this bibliography were found in resources
%%%                        there.
%%%
%%%                        An interesting press release detailing
%%%                        plans about Java-on-a-chip is available
%%%                        at http://www.sun.com:80/sparc/newsreleases/nr95-042.html.
%%%
%%%                        LINPACK benchmark results for Java on a
%%%                        number of different machines have recently
%%%                        been offered at
%%%                        http://www.netlib.org/benchmark/linpackjava/.
%%%                        If you use a Java-aware browser to visit
%%%                        that URL, you can run the benchmark on your
%%%                        own machine, and report the results back to
%%%                        the LINPACK developers.
%%%
%%%                        Other Java sites on the Internet include
%%%                        (see entry DeRoest:1996:PHP below):
%%%
%%%                        Java FAQS:
%%%                            http://www-net.com/java/faq
%%%                            http://lightyear.ncsa.uiuc.edu/~srp/java/javabooks.html
%%%                            http://www.digitalfocus.com/faq/
%%%                            http://www.afu.com/javafaq.html
%%%
%%%                        JavaScript handbook:
%%%                            http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/index.html
%%%
%%%                        Java tutorials:
%%%                            http://www.neca.com/~vmis/java.html
%%%                            http://sunsite.unc.edu/javafaq/javafaq.html
%%%                            http://www.phrantic.com/scoop/onjava.html
%%%
%%%                        JavaScript tutorials:
%%%                            http://www.freqgrafx.com/411/tutorial.html
%%%                            http://ourworld.compuserve.com/homepages/voodoo/script.html
%%%
%%%                        Java and porting projects:
%%%                            http://www.javasoft.com/
%%%                            ftp://ftp4.netscape.com/pub/MacJava
%%%                            http://java.blackdown.org/java-linux.html
%%%                            http://www.osf.org/mall/web/javaport.htm
%%%                            http://www.lls.se/~matjo/PJAmi/PJAmi.html
%%%                            http://ncc.hursley.ibm.com/javainfo/ (IBM's
%%%                            official Java home page)
%%%                            http://www.hp.com/go/JAVA (Hewlett--Packard'
%%%                            official Java home page)
%%%
%%%                        Java books in languages other than English:
%%%                            http://lightyear.ncsa.uiuc.edu/~srp/java/japanese.html
%%%                            http://wwwiz.com/books/european.html
%%%
%%%                        Java books at Amazon bookstore (warning:
%%%                        also contains many entries for books about
%%%                        the island of Java in Indonesia):
%%%                            http://www.wholesaleproducts.com/computer-javascript.html
%%%                            http://www.wholesaleproducts.com/computer-java.html
%%%
%%%                        This bibliography was initially built from
%%%                        searches in the OCLC Content1st database.
%%%                        Additions were then made from all of the
%%%                        bibliographies in the TeX User Group
%%%                        collection, from bibliographies in the
%%%                        author's personal files, from the IEEE
%%%                        INSPEC CD-ROM database (1995--Sept 1996),
%%%                        from the Compendex database, from the
%%%                        UnCover database, and from the OCLC
%%%                        BooksInPrint database.
%%%
%%%                        Numerous errors in the sources noted above
%%%                        have been corrected.  Spelling has been
%%%                        verified with the UNIX spell and GNU ispell
%%%                        programs using the exception dictionary
%%%                        stored in the companion file with extension
%%%                        .sok.
%%%
%%%                        BibTeX citation tags are uniformly chosen as
%%%                        name:year:abbrev, where name is the family
%%%                        name of the first author or editor, year is a
%%%                        4-digit number, and abbrev is a 3-letter
%%%                        condensation of important title
%%%                        words. Citation tags were automatically
%%%                        generated by software developed for the
%%%                        BibNet Project.
%%%
%%%                        In this bibliography, entries are sorted
%%%                        first by ascending year, and within each
%%%                        year, alphabetically by author or editor, and
%%%                        then, if necessary, by the 3-letter
%%%                        abbreviation at the end of the BibTeX
%%%                        citation tag, using the bibsort -byyear
%%%                        utility.  Year order has been chosen to make
%%%                        it easier to identify the most recent work.
%%%
%%%                        The checksum field above contains a CRC-16
%%%                        checksum as the first value, followed by the
%%%                        equivalent of the standard UNIX wc (word
%%%                        count) utility output of lines, words, and
%%%                        characters.  This is produced by Robert
%%%                        Solovay's checksum utility.",
%%%  }
%%% ====================================================================

@Preamble{"\input bibnames.sty " #
          "\input path.sty " #
          "\ifx \undefined \circled \def \circled #1{(#1)}\fi" #
          "\ifx \undefined \k \let \k = \c \fi" #
          "\ifx \undefined \reg \def \reg {\circled{R}}\fi" #
          "\ifx \undefined \TM \def \TM {${}^{\sc TM}$} \fi" #
          "\hyphenation{
                        Aero-space
                        Gur-e-wich
                        Horst-mann
                        ROAST-ER
                        Rich-ard
                        Sep-tem-ber
                        data-bases
                        roast-er
          }"
}

%%% ====================================================================
%%% Acknowledgement abbreviations:

@String{ack-nhfb = "Nelson H. F. Beebe,
                    University of Utah,
                    Department of Mathematics, 110 LCB,
                    155 S 1400 E RM 233,
                    Salt Lake City, UT 84112-0090, USA,
                    Tel: +1 801 581 5254,
                    FAX: +1 801 581 4148,
                    e-mail: \path|beebe@math.utah.edu|,
                            \path|beebe@acm.org|,
                            \path|beebe@computer.org| (Internet),
                    URL: \path|http://www.math.utah.edu/~beebe/|"}

%%% ====================================================================
%%% Institution abbreviations:

@String{inst-CSC                = "Center for Scientific Computing, Department
                                  of Mathematics, University of Utah"}

@String{inst-CSC:adr            = "Salt Lake City, UT 84112, USA"}

%%% ====================================================================
%%% Journal abbreviations:

@String{j-ACM-COMM-COMP-ALGEBRA = "ACM Communications in Computer Algebra"}

@String{j-ADA-USER-J            = "Ada User Journal"}

@String{j-ADV-ENG-SOFTWARE      = "Advances in Engineering Software"}

@String{j-ADV-EXP-MED-BIO       = "Advances in experimental medicine and
                                  biology"}

@String{j-ADV-IMAGING           = "Advanced Imaging"}

@String{j-AMER-STAT             = "The American Statistician"}

@String{j-APL-QUOTE-QUAD        = "APL Quote Quad"}

@String{j-APPL-MATH-COMP        = "Applied Mathematics and Computation"}

@String{j-BIOINFORMATICS        = "Bioinformatics"}

@String{j-BUSINESS-WEEK         = "Business week"}

@String{j-CACM                  = "Communications of the ACM"}

@String{j-CCCUJ                 = "C/C++ Users Journal"}

@String{j-CCPE                  = "Concurrency and Computation: Prac\-tice and
                                  Experience"}

@String{j-CHEMO-INTELL-LAB      = "Chemometrics and Intelligent Laboratory
                                  Systems"}

@String{j-COMP-ARCH-NEWS        = "ACM SIGARCH Computer Architecture News"}

@String{j-COMP-CIVIL-ENG        = "Journal of Computing in Civil Engineering"}

@String{j-COMP-EDU-J            = "Computers in education journal"}

@String{j-COMP-GEOSCI           = "Computers and Geosciences"}

@String{j-COMP-J                = "The Computer Journal"}

@String{j-COMP-LANGS            = "Computer Languages"}

@String{j-COMP-LANGS-SYS-STRUCT = "Computer Languages, Systems and Structures"}

@String{j-COMP-MATH-APPL        = "Computers and Mathematics with
                                  Applications"}

@String{j-COMP-NET-AMSTERDAM    = "Computer Networks (Amsterdam, Netherlands:
                                  1999)"}

@String{j-COMP-PHYS-COMM        = "Computer Physics Communications"}

@String{j-COMP-STANDARDS-INTERFACES = "Computer Standards and Interfaces"}

@String{j-COMP-STAT             = "Computational Statistics"}

@String{j-COMP-STRUCTURES       = "Computers and Structures"}

@String{j-COMP-SURV             = "ACM Computing Surveys"}

@String{j-COMPUT-APPL-ENG-EDUC  = "Computer Applications in Engineering
                                  Education"}

@String{j-COMPUT-BULL           = "The Computer Bulletin"}

@String{j-COMPUT-HUM-BEHAV      = "Computers in Human Behavior"}

@String{j-COMPUT-METH-PROG-BIOMED = "Computer Methods and Programs in
                                  Biomedicine"}

@String{j-COMPUT-SCI-ENG        = "Computing in Science and Engineering"}

@String{j-COMPUT-SECUR          = "Computers and Security"}

@String{j-COMPUTER              = "Computer"}

@String{j-COMPUTERS-AND-GRAPHICS = "Computers and Graphics"}

@String{j-CONTROL-ENG           = "Control Engineering"}

@String{j-CPE                   = "Concurrency: Prac\-tice and Experience"}

@String{j-DDJ                   = "Dr. Dobb's Journal of Software Tools"}

@String{j-EDN                   = "EDN"}

@String{j-ELECT-NOTES-THEOR-COMP-SCI = "Electronic Notes in Theoretical
                                  Computer Science"}

@String{j-ELECTRONIC-DESIGN     = "Electronic Design"}

@String{j-ELECTRONIC-ENG-TIMES  = "Electronic Engineering Times"}

@String{j-ELECTRONIC-LIBRARY    = "Electronic Library"}

@String{j-ELECTRONIK            = "Elektronik"}

@String{j-ELETTRONICA-OGGI      = "Elettronica Oggi"}

@String{j-EMBED-SYS-PROG        = "Embedded Systems Programming"}

@String{j-EMBEDDED-LINUX-J      = "Embedded Linux Journal"}

@String{j-FORM-METHODS-SYST-DES = "Formal Methods in System Design"}

@String{j-FRONTIERS-EDU-CONF    = "Frontiers in Education Conference"}

@String{j-FUT-GEN-COMP-SYS      = "Future Generation Computer Systems"}

@String{j-HIGHER-ORDER-SYMB-COMPUT = "Higher-Order and Symbolic Computation"}

@String{j-IBM-JRD               = "IBM Journal of Research and Development"}

@String{j-IBM-SYS-J             = "IBM Systems Journal"}

@String{j-IEE-PROC-COMPUT-DIGIT-TECH = "IEE Proceedings. Computers and Digital
                                  Techniques"}

@String{j-IEEE-CGA              = "IEEE Computer Graphics and Applications"}

@String{j-IEEE-CONCURR          = "IEEE Concurrency"}

@String{j-IEEE-DISTRIB-SYST-ONLINE = "IEEE Distributed Systems Online"}

@String{j-IEEE-MICRO            = "IEEE Micro"}

@String{j-IEEE-MULTIMEDIA       = "IEEE MultiMedia"}

@String{j-IEEE-SEC-PRIV         = "IEEE Security \& Privacy"}

@String{j-IEEE-SIGNAL-PROCESS-MAG = "IEEE signal processing magazine"}

@String{j-IEEE-SOFTWARE         = "IEEE Software"}

@String{j-IEEE-TRANS-CONSUMER-ELECTRONICS = "IEEE Transactions on Consumer
                                  Electronics"}

@String{j-IEEE-TRANS-COMPUT     = "IEEE Transactions on Computers"}

@String{j-IEEE-TRANS-EDUC       = "IEEE transactions on education"}

@String{j-IEEE-TRANS-PAR-DIST-SYS = "IEEE Transactions on Parallel and
                                  Distributed Systems"}

@String{j-IEEE-TRANS-SOFTW-ENG  = "IEEE Transactions on Software Engineering"}

@String{j-IETE-TECH-REV         = "IETE Technical Review"}

@String{j-IJHPCA                = "The International Journal of High Performance
                                  Computing Applications"}

@String{j-INF-CONTROL           = "Information and Control"}

@String{j-INFO-PROC-LETT        = "Information Processing Letters"}

@String{j-INFO-RETRIEVAL-LIB-AUTO = "Information Retrieval and Library
                                  Automation"}

@String{j-INFO-SOFTWARE-TECH    = "Information and Software Technology"}

@String{j-INFORMATION-WEEK      = "Information Week"}

@String{j-INFOWORLD             = "InfoWorld"}

@String{j-INT-J-COMPUT-SYST-SCI-ENG = "International Journal of Computer Systems
                                  Science and Engineering"}

@String{j-INT-J-ENG-EDUC        = "International Journal of Engineering
                                  Education"}

@String{j-INT-J-PARALLEL-PROG   = "International Journal of Parallel
                                  Programming"}

@String{j-INT-J-ROBOTICS-AUTOMATION = "International Journal of Robotics and
                                  Automation"}

@String{j-INT-J-SOFTW-TOOLS-TECHNOL-TRANSFER = "International Journal on
                                  Software Tools for Technology Transfer
                                  (STTT)"}

@String{j-INT-J-SYST-SCI        = "International Journal of Systems Science"}

@String{j-INTEL-TECH-J          = "Intel Technology Journal"}

@String{j-J-ACM                 = "Journal of the ACM"}

@String{j-J-AUTO-REASON         = "Journal of Automated Reasoning"}

@String{j-J-COMP-INFO-SYS       = "The Journal of Computer Information
                                  Systems"}

@String{j-J-COMP-SCI-TECH       = "Journal of Computer Science and Technology"}

@String{j-J-COMP-SYS-SCI        = "Journal of Computer and System Sciences"}

@String{j-J-COMPUT-GRAPH-STAT   = "Journal of Computational and Graphical
                                  Statistics"}

@String{j-J-DIGITAL-IMAGING     = "Journal of Digital Imaging"}

@String{j-J-GEOPHYS-RES         = "Journal of Geophysical Research"}

@String{j-J-GRID-COMP           = "Journal of Grid Computing"}

@String{j-J-INFO-SCI-ENG        = "Journal of Information Science and
                                  Engineering"}

@String{j-J-LOGIC-ALG-PROG      = "Journal of Logic and Algebraic Programming"}

@String{j-J-NETWORK-COMP-APPL   = "Journal of Network and Computer
                                  Applications"}

@String{j-J-OPER-RES-SOC        = "OR: the journal of the Operational Research
                                  Society"}

@String{j-J-PAR-DIST-COMP       = "Journal of Parallel and Distributed
                                  Computing"}

@String{j-J-STAT-SOFT           = "Journal of Statistical Software"}

@String{j-J-SUPERCOMPUTING      = "The Journal of Supercomputing"}

@String{j-J-SYST-SOFTW          = "The Journal of systems and software"}

@String{j-J-UCS                 = "J.UCS: Journal of Universal Computer
                                  Science"}

@String{j-JERIC                 = "ACM Journal on Educational Resources in
                                  Computing (JERIC)"}

@String{j-LECT-NOTES-COMP-SCI   = "Lecture Notes in Computer Science"}

@String{j-LINUX-J               = "Linux Journal"}

@String{j-LIT-LING-COMP         = "Literary and Linguistic Computing"}

@String{j-LOGIN                 = ";login: the USENIX Association newsletter"}

@String{j-LOPLAS                = "ACM Letters on Programming Languages and
                                  Systems"}

@String{j-MAGMA                 = "Magma"}

@String{j-MARKUP-LANG           = "Markup languages: theory \& practice"}

@String{j-MATH-COMP-EDU         = "Mathematics and computer education"}

@String{j-MICROPROC-MICROSYS    = "Microprocessors and Microsystems"}

@String{j-MICROPROC-REP         = "Microprocessor report"}

@String{j-MINI-MICRO-SYSTEMS    = "Mini-Micro Systems"}

@String{j-MOL-SIM               = "Molecular simulation"}

@String{j-MULTIMEDIA-SYSTEMS    = "Multimedia Systems"}

@String{j-MULTIMEDIA-TOOLS-APPLIC = "Multimedia Tools and Applications"}

@String{j-NETWORK-COMPUTING     = "Network Computing"}

@String{j-NEUROIMAGE            = "NeuroImage"}

@String{j-NORDIC-J-COMPUT       = "Nordic Journal of Computing"}

@String{j-OPER-SYS-REV          = "Operating Systems Review"}

@String{j-PARALLEL-ALGORITHMS-APPL = "Parallel Algorithms and Applications"}

@String{j-PARALLEL-COMPUTING    = "Parallel Computing"}

@String{j-PARALLEL-DIST-COMP-PRACT = "Parallel and Distributed Computing
                                  Practices"}

@String{j-PARALLEL-PROCESS-LETT = "Parallel Processing Letters"}

@String{j-PC-MAGAZINE           = "PC Magazine"}

@String{j-PERF-EVAL             = "Performance evaluation"}

@String{j-PERS-COMPUT-WORLD     = "Personal computer world"}

@String{j-PRIMUS                = "PRIMUS (Problems Resources and Issues in
                                  Mathematics Undergraduate Studies)"}

@String{j-PROC-AM-CONTROL-CONF  = "Proceedings of the American Control
                                  Conference"}

@String{j-PROC-IEEE             = "Proceedings of the IEEE"}

@String{j-PROC-SPIE             = "Proceedings of the SPIE --- The
                                  International Society for Optical
                                  Engineering"}

@String{j-PROG-COMP-SOFT        = "Programming and Computer Software;
                                  translation of Programmirovaniye (Moscow,
                                  USSR) Plenum"}

@String{j-QUEUE                 = "ACM Queue: Tomorrow's Computing Today"}

@String{j-REAL-TIME-SYST        = "Real-Time Systems"}

@String{j-REV-ESP-ELECT         = "Revista espa{\~n}ola de electronica"}

@String{j-SCI-COMPUT-PROGRAM    = "Science of Computer Programming"}

@String{j-SCI-PROG              = "Scientific Programming"}

@String{j-SCPE                  = "Scalable Computing: Practice and Experience"}

@String{j-SIGADA-LETTERS        = "ACM SIGADA Ada Letters"}

@String{j-SIGCSE                = "SIGCSE Bulletin (ACM Special Interest Group
                                  on Computer Science Education)"}

@String{j-SIGMETRICS            = "ACM SIGMETRICS Perform. Eval. Rev."}

@String{j-SIGMOD                = "SIGMOD Record (ACM Special Interest Group
                                  on Management of Data)"}

@String{j-SIGPLAN               = "ACM SIG{\-}PLAN Notices"}

@String{j-SIGSAM                = "SIGSAM Bulletin (ACM Special Interest Group
                                  on Symbolic and Algebraic Manipulation)"}

@String{j-SIM-SERIES            = "Simulation series"}

@String{j-SIMULATION            = "Simulation"}

@String{j-SPE                   = "Soft\-ware\emdash Prac\-tice and
                                  Experience"}

@String{j-SYS-ADMIN             = "SysAdmin"}

@String{j-SYS-COMP-JAPAN        = "Systems and computers in Japan"}

@String{j-SYST-CONTROL-INFO     = "Systems, Control and Information =
                                  Shisutemu Seigyo Joho Gakkai shi"}

@String{j-TACO                  = "ACM Transactions on Architecture and Code
                                  Optimization"}

@String{j-TECHNIQUE-SCI-INFORMATIQUES = "Technique et science informatiques :
                                  TSI"}

@String{j-TECS                  = "ACM Transactions on Embedded Computing
                                  Systems"}

@String{j-THEOR-COMP-SCI        = "Theoretical Computer Science"}

@String{j-TOCE                  = "ACM Transactions on Computing Education"}

@String{j-TOCHI                 = "ACM Transactions on Computer-Human
                                  Interaction"}

@String{j-TOCS                  = "ACM Transactions on Computer Systems"}

@String{j-TODAES                = "ACM Transactions on Design Automation of
                                   Electronic Systems"}

@String{j-TOIT                  = "ACM Transactions on Internet Technology (TOIT)"}

@String{j-TOMS                  = "ACM Transactions on Mathematical Software"}

@String{j-TOPLAS                = "ACM Transactions on Programming Languages
                                  and Systems"}

@String{j-TOSEM                 = "ACM Transactions on Software Engineering
                                  and Methodology"}

@String{j-TWEB                  = "ACM Transactions on the Web (TWEB)"}

@String{j-VLDB-J                = "VLDB Journal: Very Large Data Bases"}

@String{j-WIRTSCHAFTSINFORMATIK = "Wirtschaftsinformatik"}

%%% ====================================================================
%%% Publishers and their addresses:

@String{pub-ACM                 = "ACM Press"}

@String{pub-ACM:adr             = "New York, NY 10036, USA"}

@String{pub-AIP                 = "American Institute of Physics"}

@String{pub-AIP:adr             = "Woodbury, NY, USA"}

@String{pub-APRESS              = "Apress"}

@String{pub-APRESS:adr          = "Berkeley, CA, USA"}

@String{pub-ARTECH              = "Artech House Inc."}

@String{pub-ARTECH:adr          = "Norwood, MA, USA"}

@String{pub-AW                  = "Ad{\-d}i{\-s}on-Wes{\-l}ey"}

@String{pub-AW:adr              = "Reading, MA, USA"}

@String{pub-AW-LONGMAN          = "Ad{\-d}i{\-s}on-Wes{\-l}ey Longman"}

@String{pub-AW-LONGMAN:adr      = "Reading, MA, USA"}

@String{pub-BIRKHAUSER          = "Birkh{\"a}user Verlag"}

@String{pub-BIRKHAUSER:adr      = "Basel, Switzerland"}

@String{pub-BROOKS-COLE         = "Brooks\slash Cole"}

@String{pub-BROOKS-COLE:adr     = "Pacific Grove, CA, USA"}

@String{pub-CAMBRIDGE           = "Cambridge University Press"}

@String{pub-CAMBRIDGE:adr       = "Cambridge, UK"}

@String{pub-CHAPMAN-HALL-CRC    = "Chapman and Hall/CRC"}

@String{pub-CHAPMAN-HALL-CRC:adr = "Boca Raton, FL, USA"}

@String{pub-CHARLES-RIVER-MEDIA = "Charles River Media, Inc."}

@String{pub-CHARLES-RIVER-MEDIA:adr = "403 VFW Drive, PO Box 417, Rockland, MA
                                  02370, USA"}

@String{pub-CORIOLIS            = "Coriolis Group Books"}

@String{pub-CORIOLIS:adr        = "Scottsdale, AZ, USA"}

@String{pub-COURSE-TECHNOLOGY   = "Course Technology"}

@String{pub-COURSE-TECHNOLOGY:adr = "Cambridge, MA, USA"}

@String{pub-CRC                 = "CRC Press"}

@String{pub-CRC:adr             = "2000 N.W. Corporate Blvd., Boca Raton, FL
                                  33431-9868, USA"}

@String{pub-HUNGRY-MINDS        = "Hungry Minds"}

@String{pub-HUNGRY-MINDS:adr    = "909 Third Avenue, New York, NY 10022, USA"}

@String{pub-HUNGRY-MINDS-IN     = "Hungry Minds"}

@String{pub-HUNGRY-MINDS-IN:adr = "Indianapolis, IN, USA"}

@String{pub-IBM-PRESS           = "IBM Press"}

@String{pub-IBM-PRESS:adr       = ""}

@String{pub-IDG                 = "IDG Books"}

@String{pub-IDG:adr             = "San Mateo, CA, USA"}

@String{pub-IDG-WORLDWIDE       = "I D G Books Worldwide"}

@String{pub-IDG-WORLDWIDE:adr   = "Indianapolis, IN, USA"}

@String{pub-IEEE                = "IEEE Computer Society Press"}

@String{pub-IEEE:adr            = "1109 Spring Street, Suite 300, Silver
                                  Spring, MD 20910, USA"}

@String{pub-IOS                 = "IOS Press"}

@String{pub-IOS:adr             = "Amsterdam, The Netherlands"}

@String{pub-IRWIN-MCGRAW-HILL   = "Irwin\slash McGraw Hill"}

@String{pub-IRWIN-MCGRAW-HILL:adr = "Boston, MA, USA"}

@String{pub-ISO                 = "International Organization for Standardization"}

@String{pub-ISO:adr             = "Geneva, Switzerland"}

@String{pub-ITP                 = "International Thomson Publishing"}

@String{pub-ITP:adr             = "London, New York, Boston, Madrid,
                                  \\ldots{}"}

@String{pub-JONES-BARTLETT      = "Jones and Bartlett"}

@String{pub-JONES-BARTLETT:adr  = "Boston, MA, USA"}

@String{pub-KLUWER              = "Kluwer Academic Publishers Group"}

@String{pub-KLUWER:adr          = "Norwell, MA, USA, and Dordrecht, The
                                  Netherlands"}

@String{pub-MANNING             = "Manning Publications"}

@String{pub-MANNING:adr         = "Greenwich, CT, USA"}

@String{pub-MCGRAW-HILL         = "Mc{\-}Graw-Hill"}

@String{pub-MCGRAW-HILL:adr     = "New York, NY, USA"}

@String{pub-MIT                 = "MIT Press"}

@String{pub-MIT:adr             = "Cambridge, MA, USA"}

@String{pub-MORGAN-KAUFMANN     = "Morgan Kaufmann Publishers"}

@String{pub-MORGAN-KAUFMANN:adr = "Los Altos, CA 94022, USA"}

@String{pub-MT                  = "M\&T Books"}

@String{pub-MT:adr              = "M\&T Publishing, Inc., 501 Galveston Drive,
                                  Redwood City, CA 94063, USA"}

@String{pub-NASA                = "National Aeronautics and Space
                                  Administration"}

@String{pub-NASA:adr            = "Washington, DC, USA"}

@String{pub-NEW-RIDERS          = "New Riders Publishing"}

@String{pub-NEW-RIDERS:adr      = "Carmel, IN, USA"}

@String{pub-NIST                = "National Institute for Standards and
                                  Technology"}

@String{pub-NIST:adr            = "Gaithersburg, MD, USA"}

@String{pub-NO-STARCH           = "No Starch Press"}

@String{pub-NO-STARCH:adr       = "San Francisco, CA, USA"}

@String{pub-NORTON              = "W. W. Norton \& Co."}

@String{pub-NORTON:adr          = "New York, NY, USA"}

@String{pub-ORA                 = "O'Reilly \& {Associates, Inc.}"}

@String{pub-ORA:adr             = "981 Chestnut Street, Newton, MA 02164, USA"}

@String{pub-ORA-MEDIA           = "O'Reilly Media, Inc."}

@String{pub-ORA-MEDIA:adr       = "1005 Gravenstein Highway North, Sebastopol,
                                  CA 95472, USA"}

@String{pub-OSBORNE             = "Osborne/McGraw-Hill"}

@String{pub-OSBORNE:adr         = "Berkeley, CA, USA"}

@String{pub-PEACHPIT            = "Peachpit Press, Inc."}

@String{pub-PEACHPIT:adr        = "1085 Keith Avenue, Berkeley, CA 94708, USA"}

@String{pub-PH                  = "Pren{\-}tice-Hall"}

@String{pub-PH:adr              = "Englewood Cliffs, NJ 07632, USA"}

@String{pub-PHPTR               = "P T R Pren{\-}tice-Hall"}

@String{pub-PHPTR:adr           = "Englewood Cliffs, NJ 07632, USA"}

@String{pub-PRAGMATIC-BOOKSHELF = "Pragmatic Bookshelf"}

@String{pub-PRAGMATIC-BOOKSHELF:adr = "Raleigh, NC, USA"}

@String{pub-PRINCETON           = "Princeton University Press"}

@String{pub-PRINCETON:adr       = "Princeton, NJ, USA"}

@String{pub-QUE                 = "Que Corporation"}

@String{pub-QUE:adr             = "Indianapolis, IN, USA"}

@String{pub-R-D-BOOKS           = "R\&D Books"}

@String{pub-R-D-BOOKS:adr       = "Lawrence, KS, USA; Berkeley, CA, USA"}

@String{pub-SAE                 = "Society of Automotive Engineers"}

@String{pub-SAE:adr             = "Warrendale, PA, USA"}

@String{pub-SAMS                = "Howard W. Sams"}

@String{pub-SAMS:adr            = "Indianapolis, IN 46268, USA"}

@String{pub-SCOTT-JONES         = "Scott\slash Jones"}

@String{pub-SCOTT-JONES:adr     = "El Granada, CA, USA"}

@String{pub-SITEPOINT           = "SitePoint Pty. Ltd."}

@String{pub-SITEPOINT:adr       = "Collingwood, VIC, Australia"}

@String{pub-SPIE                = "SPIE Optical Engineering Press"}

@String{pub-SPIE:adr            = "Bellingham, WA, USA"}

@String{pub-SUN-MICROSYSTEMS-PRESS = "Sun Microsystems Press"}

@String{pub-SUN-MICROSYSTEMS-PRESS:adr = "Palo Alto, CA, USA"}

@String{pub-SUNSOFT             = "SunSoft Press"}

@String{pub-SUNSOFT:adr         = "2550 Garcia Avenue, Mountain View, CA
                                  94043-1100, USA"}

@String{pub-SV                  = "Spring{\-}er-Ver{\-}lag"}

@String{pub-SV:adr              = "Berlin, Germany~/ Heidelberg, Germany~/
                                  London, UK~/ etc."}

@String{pub-SYBEX               = "Sybex, Inc."}

@String{pub-SYBEX:adr           = "2021 Challenger Driver, Suite 100, Alameda,
                                  CA 94501, USA"}

@String{pub-USENIX              = "USENIX Association"}

@String{pub-USENIX:adr          = "Berkeley, CA, USA"}

@String{pub-WILEY               = "John Wiley and Sons"}

@String{pub-WILEY:adr           = "New York, NY, USA; London, UK; Sydney,
                                  Australia"}

@String{pub-WILEY-COMPUTER      = "Wiley Computer Publishers"}

@String{pub-WILEY-COMPUTER:adr  = "New York, NY, USA"}

@String{pub-WROX                = "Wrox Press"}

@String{pub-WROX:adr            = "Chicago, IL, USA"}

%%% ====================================================================
%%% Series abbreviations:

@String{ser-LNCS                = "Lecture Notes in Computer Science"}

%%% ====================================================================
%%% Bibliography entries, sorted by year, and then by citation key.

@Article{Akai:2010:EAS,
  author =       "Shumpei Akai and Shigeru Chiba",
  title =        "Extending {AspectJ} for separating regions",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "45--54",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837852.1621616",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Synchronization is a good candidate for an aspect in
                 aspect-oriented programming (AOP) since programmers
                 have to choose the best granularity of synchronization
                 for the underlying hardware to obtain the best
                 execution performance. If synchronization is an aspect,
                 programmers can change the synchronization code
                 independently of the rest of the program when the
                 program runs on different hardware. However, existing
                 AOP languages such as AspectJ have problems. They
                 cannot select an arbitrary code region as a join point.
                 Moreover, they cannot enforce weaving of a
                 synchronization aspect. Since it is an alternative
                 feature in feature modeling, at least one of available
                 synchronization aspects must be woven. Otherwise, the
                 program would be thread-unsafe. Since an aspect in
                 AspectJ is inherently optional, programmers must be
                 responsible for weaving it. To solve these problems,
                 this paper proposes two new constructs for AspectJ,
                 {\em regioncut\/} and {\em assertions for advice}.
                 Regioncut selects arbitrary code region as a join point
                 and assertion for advice enforces weaving a mandatory
                 advice. We implemented these constructs by extending
                 the AspectBench compiler. We evaluated the design of
                 our constructs by applying them to two open-source
                 software products, Javassist and Hadoop.",
  acknowledgement = ack-nhfb,
  keywords =     "aspect-oriented programming; feature-oriented
                 programming; region; synchronization",
}

@Article{Albert:2010:PIM,
  author =       "Elvira Albert and Samir Genaim and Miguel
                 G{\'o}mez-Zamalloa",
  title =        "Parametric inference of memory requirements for
                 garbage collected languages",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "121--130",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806651.1806671",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The accurate prediction of program's memory
                 requirements is a critical component in software
                 development. Existing heap space analyses either do not
                 take deallocation into account or adopt specific models
                 of garbage collectors which do not necessarily
                 correspond to the actual memory usage. We present a
                 novel approach to inferring upper bounds on memory
                 requirements of Java-like programs which is {\em
                 parametric\/} on the notion of {\em object lifetime},
                 i.e., on when objects become collectible. If objects
                 lifetimes are inferred by a reachability analysis, then
                 our analysis infers accurate upper bounds on the memory
                 consumption for a {\em reachability\/} -based garbage
                 collector. Interestingly, if objects lifetimes are
                 inferred by a {\em heap liveness\/} analysis, then we
                 approximate the program minimal memory requirement,
                 i.e., the peak memory usage when using an optimal
                 garbage collector which frees objects as soon as they
                 become dead. The key idea is to integrate information
                 on objects lifetimes into the process of generating the
                 {\em recurrence equations\/} which capture the memory
                 usage at the different program states. If the heap size
                 limit is set to the memory requirement inferred by our
                 analysis, it is ensured that execution will not exceed
                 the memory limit with the only assumption that garbage
                 collection works when the limit is reached. Experiments
                 on Java bytecode programs provide evidence of the
                 feasibility and accuracy of our analysis.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "garbage collection; java bytecode; live heap space
                 analysis; low-level languages; peak memory
                 consumption",
}

@Article{Ali:2010:DJB,
  author =       "Mohammed F. M. Ali and Mohammed I. Younis and Kamal Z.
                 Zamli and Widad Ismail",
  title =        "Development of {Java} based {RFID} application
                 programmable interface for heterogeneous {RFID}
                 system",
  journal =      j-J-SYST-SOFTW,
  volume =       "83",
  number =       "11",
  pages =        "2322--2331",
  month =        nov,
  year =         "2010",
  CODEN =        "JSSODM",
  ISSN =         "0164-1212",
  bibdate =      "Mon Nov 1 11:40:40 MDT 2010",
  bibsource =    "http://www.sciencedirect.com/science/journal/01641212",
  acknowledgement = ack-nhfb,
}

@Article{Altman:2010:OTJ,
  author =       "E. Altman and M. Arnold and R. Bordawekar and R. M.
                 Delmonico and N. Mitchell and P. F. Sweeney",
  title =        "Observations on tuning a {Java} enterprise application
                 for performance and scalability",
  journal =      j-IBM-JRD,
  volume =       "54",
  number =       "5",
  pages =        "2:1--2:12",
  month =        "????",
  year =         "2010",
  CODEN =        "IBMJAE",
  DOI =          "http://dx.doi.org/10.1147/JRD.2010.2057090",
  ISSN =         "0018-8646",
  bibdate =      "Sun Feb 20 14:29:19 MST 2011",
  bibsource =    "http://www.research.ibm.com/journal/",
  acknowledgement = ack-nhfb,
}

@Article{Apel:2010:CUF,
  author =       "Sven Apel and Delesley Hutchins",
  title =        "A calculus for uniform feature composition",
  journal =      j-TOPLAS,
  volume =       "32",
  number =       "5",
  pages =        "19:1--19:33",
  month =        may,
  year =         "2010",
  CODEN =        "ATPSDT",
  DOI =          "http://doi.acm.org/10.1145/1745312.1745316",
  ISSN =         "0164-0925",
  bibdate =      "Fri May 21 12:28:30 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "The goal of {\em feature-oriented programming\/} (FOP)
                 is to modularize software systems in terms of features.
                 A {\em feature\/} refines the content of a base
                 program. Both base programs and features may contain
                 various kinds of software artifacts, for example,
                 source code in different languages, models, build
                 scripts, and documentation. We and others have noticed
                 that when composing features, different kinds of
                 software artifacts can be refined in a uniform way,
                 regardless of what they represent. We present gDeep, a
                 core calculus for feature composition, which captures
                 the language independence of FOP; it can be used to
                 compose features containing many different kinds of
                 artifact in a type-safe way. The calculus allows us to
                 gain insight into the principles of FOP and to define
                 general algorithms for feature composition and
                 validation. We provide the formal syntax, operational
                 semantics, and type system of gDeep and outline how
                 languages like Java, Haskell, Bali, and XML can be
                 plugged in.",
  acknowledgement = ack-nhfb,
  articleno =    "19",
  keywords =     "feature composition; Feature-oriented programming;
                 principle of uniformity; type systems",
}

@Article{Auerbach:2010:LJC,
  author =       "Joshua Auerbach and David F. Bacon and Perry Cheng and
                 Rodric Rabbah",
  title =        "{Lime}: a {Java}-compatible and synthesizable language
                 for heterogeneous architectures",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "89--108",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869469",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Barabash:2010:TGC,
  author =       "Katherine Barabash and Erez Petrank",
  title =        "Tracing garbage collection on highly parallel
                 platforms",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "1--10",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837855.1806653",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The pervasiveness of multiprocessor and multicore
                 hardware and the rising level of available parallelism
                 are radically changing the computing landscape. Can
                 software deal with tomorrow's potential higher
                 parallelism? In this paper we study this issue from the
                 garbage collection perspective. In particular, we
                 investigate the scalability of parallel heap tracing,
                 which stands at the core of the garbage collection
                 activity. Heap shapes can be sequential in nature, and
                 prevent the collector from scaling the trace. We start
                 by proposing the idealized trace utilization as a
                 scalability measure for evaluating the scalability of a
                 given heap shape. We then examine standard Java
                 benchmarks and evaluate the existence of non-scalable
                 object-graph shapes in their execution. Next, we
                 propose and implement a prototype of garbage collection
                 techniques that attempt to ameliorate the object-graph
                 shape problem. Finally, we measure and report their
                 efficacy.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "garbage collection; memory management; parallel
                 garbage collection; runtime systems",
}

@Article{Barbuti:2010:AIA,
  author =       "Roberto Barbuti and Nicoletta De Francesco and Luca
                 Tesei",
  title =        "An Abstract Interpretation Approach for Enhancing the
                 {Java Bytecode Verifier}",
  journal =      j-COMP-J,
  volume =       "53",
  number =       "6",
  pages =        "679--700",
  month =        jul,
  year =         "2010",
  CODEN =        "CMPJA6",
  DOI =          "http://dx.doi.org/10.1093/comjnl/bxp031",
  ISSN =         "0010-4620 (print), 1460-2067 (electronic)",
  ISSN-L =       "0010-4620",
  bibdate =      "Tue Aug 3 15:52:17 MDT 2010",
  bibsource =    "http://comjnl.oxfordjournals.org/content/vol53/issue6/index.dtl",
  URL =          "http://comjnl.oxfordjournals.org/cgi/content/abstract/53/6/679;
                 http://comjnl.oxfordjournals.org/cgi/reprint/53/6/679",
  acknowledgement = ack-nhfb,
}

@Article{Basanta-Val:2010:NHR,
  author =       "Pablo Basanta-Val and Marisol Garc{\'\i}a-Valls and
                 Iria Est{\'e}vez-Ayres",
  title =        "{No-Heap Remote Objects} for distributed real-time
                 {Java}",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "7:1--7:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814546",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "This article presents an approach to providing
                 real-time support for Java's Remote Method Invocation
                 (RMI) and its integration with the RTSJ memory model in
                 order to leave out garbage collection. A new construct
                 for remote objects, called {\em No-heap Remote
                 object\/} ({\em NhRo\/}), is introduced. The use of a
                 NhRo guarantees that memory required to perform a
                 remote invocation (at the server side) does not use
                 heap memory. Thus, the aim is to avoid garbage
                 collection in the remote invocation process, improving
                 predictability and memory isolation of distributed
                 Java-based real-time applications. The article presents
                 the bare model and the main programming patterns that
                 are associated with the NhRo model. Sun RMI
                 implementation has been modified to integrate the NhRo
                 model in both static and dynamic environments.",
  acknowledgement = ack-nhfb,
  articleno =    "7",
  keywords =     "distributed real-time Java; DRTSJ; Real-time Java;
                 real-time remote objects; region-based memory
                 management; RTSJ",
}

@Article{Basanta-Val:2010:SSS,
  author =       "Pablo Basanta-Val and Iria Estevez-Ayres and Marisol
                 Garcia-Valls and Luis Almeida",
  title =        "A Synchronous Scheduling Service for Distributed
                 Real-Time {Java}",
  journal =      j-IEEE-TRANS-PAR-DIST-SYS,
  volume =       "21",
  number =       "4",
  pages =        "506--519",
  month =        apr,
  year =         "2010",
  CODEN =        "ITDSEO",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/TPDS.2009.95",
  ISSN =         "1045-9219",
  bibdate =      "Thu May 13 12:06:56 2010",
  bibsource =    "http://www.computer.org/tpds/",
  acknowledgement = ack-nhfb,
  fjournal =     "IEEE Transactions on Parallel and Distributed
                 Systems",
}

@Article{Bebenita:2010:STB,
  author =       "Michael Bebenita and Florian Brandner and Manuel
                 Fahndrich and Francesco Logozzo and Wolfram Schulte and
                 Nikolai Tillmann and Herman Venter",
  title =        "{SPUR}: a trace-based {JIT} compiler for {CIL}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "708--725",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869517",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Chambers:2010:FEE,
  author =       "Craig Chambers and Ashish Raniwala and Frances Perry
                 and Stephen Adams and Robert R. Henry and Robert
                 Bradshaw and Nathan Weizenbaum",
  title =        "{FlumeJava}: easy, efficient data-parallel pipelines",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "363--375",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1809028.1806638",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "MapReduce and similar systems significantly ease the
                 task of writing data-parallel code. However, many
                 real-world computations require a pipeline of
                 MapReduces, and programming and managing such pipelines
                 can be difficult. We present FlumeJava, a Java library
                 that makes it easy to develop, test, and run efficient
                 data-parallel pipelines. At the core of the FlumeJava
                 library are a couple of classes that represent
                 immutable parallel collections, each supporting a
                 modest number of operations for processing them in
                 parallel. Parallel collections and their operations
                 present a simple, high-level, uniform abstraction over
                 different data representations and execution
                 strategies. To enable parallel operations to run
                 efficiently, FlumeJava defers their evaluation, instead
                 internally constructing an execution plan dataflow
                 graph. When the final results of the parallel
                 operations are eventually needed, FlumeJava first
                 optimizes the execution plan, and then executes the
                 optimized operations on appropriate underlying
                 primitives (e.g., MapReduces). The combination of
                 high-level abstractions for parallel data and
                 computation, deferred evaluation and optimization, and
                 efficient parallel primitives yields an easy-to-use
                 system that approaches the efficiency of hand-optimized
                 pipelines. FlumeJava is in active use by hundreds of
                 pipeline developers within Google.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "data-parallel programming; java; mapreduce",
}

@Article{Curley:2010:RDT,
  author =       "Edward Curley and Binoy Ravindran and Jonathan
                 Anderson and E. Douglas Jensen",
  title =        "Recovering from distributable thread failures in
                 distributed real-time {Java}",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "8:1--8:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814547",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "We consider the problem of recovering from the
                 failures of distributable threads (``threads'') in
                 distributed real-time systems that operate under
                 runtime uncertainties including those on thread
                 execution times, thread arrivals, and node failure
                 occurrences. When a thread experiences a node failure,
                 the result is a broken thread having an orphan. Under a
                 termination model, the orphans must be detected and
                 aborted, and exceptions must be delivered to the
                 farthest, contiguous surviving thread segment for
                 resuming thread execution. Our application/scheduling
                 model includes the proposed distributable thread
                 programming model for the emerging Distributed
                 Real-Time Specification for Java (DRTSJ), together with
                 an exception-handler model. Threads are subject to
                 time/utility function (TUF) time constraints and an
                 utility accrual (UA) optimality criterion. A key
                 underpinning of the TUF/UA scheduling paradigm is the
                 notion of ``best-effort'' where higher importance
                 threads are always favored over lower importance ones,
                 irrespective of thread urgency as specified by their
                 time constraints. We present a thread scheduling
                 algorithm called HUA and a thread integrity protocol
                 called TPR. We show that HUA and TPR bound the orphan
                 cleanup and recovery time with bounded loss of the
                 best-effort property. Our implementation experience for
                 HUA/TPR in the Reference Implementation of the proposed
                 programming model for the DRTSJ demonstrates the
                 algorithm/protocol's effectiveness.",
  acknowledgement = ack-nhfb,
  articleno =    "8",
  keywords =     "distributable thread; Distributed; distributed
                 scheduling; Java; real-time; thread integrity",
}

@Article{Cutsem:2010:PDP,
  author =       "Tom Van Cutsem and Mark S. Miller",
  title =        "Proxies: design principles for robust object-oriented
                 intercession {APIs}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "12",
  pages =        "59--72",
  month =        dec,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1899661.1869638",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Dec 15 10:25:15 MST 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Proxies are a powerful approach to implement
                 meta-objects in object-oriented languages without
                 having to resort to metacircular interpretation. We
                 introduce such a meta-level API based on proxies for
                 Javascript. We simultaneously introduce a set of design
                 principles that characterize such APIs in general, and
                 compare similar APIs of other languages in terms of
                 these principles. We highlight how principled
                 proxy-based APIs improve code robustness by avoiding
                 interference between base and meta-level code that
                 occur in more common reflective intercession
                 mechanisms.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{DeFrancesco:2010:UAI,
  author =       "Nicoletta {De Francesco} and Giuseppe Lettieri and
                 Luca Martini",
  title =        "Using abstract interpretation to add type checking for
                 interfaces in {Java} bytecode verification",
  journal =      j-THEOR-COMP-SCI,
  volume =       "411",
  number =       "22--24",
  pages =        "2174--2201",
  day =          "17",
  month =        may,
  year =         "2010",
  CODEN =        "TCSCDI",
  ISSN =         "0304-3975 (print), 1879-2294 (electronic)",
  ISSN-L =       "0304-3975",
  bibdate =      "Mon Mar 28 17:10:32 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/03043975",
  abstract =     "Java interface types support multiple inheritance.
                 Because of this, the standard bytecode verifier ignores
                 them, since it is not able to model the class hierarchy
                 as a lattice. Thus, type checks on interfaces are
                 performed at run time. We propose a verification
                 methodology that removes the need for run-time checks.
                 The methodology consists of: (1) an augmented verifier
                 that is very similar to the standard one, but is also
                 able to check for interface types in most cases; (2)
                 for all other cases, a set of additional simpler
                 verifiers, each one specialized for a single interface
                 type. We obtain these verifiers in a systematic way by
                 using abstract interpretation techniques. Finally, we
                 describe an implementation of the methodology and
                 evaluate it on a large set of benchmarks.",
  acknowledgement = ack-nhfb,
}

@Article{Deitcher:2010:JEJ,
  author =       "Avi Deitcher",
  title =        "{JSormdb} --- an embedded {JavaScript} database",
  journal =      j-LINUX-J,
  volume =       "2010",
  number =       "192",
  pages =        "4:1--4:??",
  month =        apr,
  year =         "2010",
  CODEN =        "LIJOFX",
  ISSN =         "1075-3583 (print), 1938-3827 (electronic)",
  ISSN-L =       "1075-3583",
  bibdate =      "Tue Nov 23 11:41:54 MST 2010",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  articleno =    "4",
  fjournal =     "Linux Journal",
}

@Article{Dietrich:2010:POD,
  author =       "K. Dietrich and F. R{\"o}ck",
  title =        "Performance Optimizations for {DAA} Signatures on
                 {Java} enabled Platforms",
  journal =      j-J-UCS,
  volume =       "16",
  number =       "4",
  pages =        "519--??",
  month =        "????",
  year =         "2010",
  CODEN =        "????",
  ISSN =         "0948-6968",
  bibdate =      "Wed Aug 25 21:53:00 MDT 2010",
  bibsource =    "http://www.jucs.org/jucs",
  URL =          "http://www.jucs.org/jucs_16_4/performance_optimizations_for_daa",
  acknowledgement = ack-nhfb,
}

@Article{Elmas:2010:GRA,
  author =       "Tayfun Elmas and Shaz Qadeer and Serdar Tasiran",
  title =        "{Goldilocks}: a race-aware {Java} runtime",
  journal =      j-CACM,
  volume =       "53",
  number =       "11",
  pages =        "85--92",
  month =        nov,
  year =         "2010",
  CODEN =        "CACMA2",
  DOI =          "http://doi.acm.org/10.1145/1839676.1839698",
  ISSN =         "0001-0782 (print), 1557-7317 (electronic)",
  ISSN-L =       "0001-0782",
  bibdate =      "Fri Oct 29 17:02:13 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/cacm/",
  acknowledgement = ack-nhfb,
  fjournal =     "Communications of the ACM",
}

@Article{Flanagan:2010:AMD,
  author =       "Cormac Flanagan and Stephen N. Freund",
  title =        "Adversarial memory for detecting destructive races",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "244--254",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806625",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Multithreaded programs are notoriously prone to race
                 conditions, a problem exacerbated by the widespread
                 adoption of multi-core processors with complex memory
                 models and cache coherence protocols. Much prior work
                 has focused on static and dynamic analyses for race
                 detection, but these algorithms typically are unable to
                 distinguish destructive races that cause erroneous
                 behavior from benign races that do not. Performing this
                 classification manually is difficult, time consuming,
                 and error prone.\par

                 This paper presents a new dynamic analysis technique
                 that uses {\em adversarial memory\/} to classify race
                 conditions as destructive or benign on systems with
                 relaxed memory models. Unlike a typical language
                 implementation, which may only infrequently exhibit
                 non-sequentially consistent behavior, our adversarial
                 memory implementation exploits the full freedom of the
                 memory model to return older, unexpected, or stale
                 values for memory reads whenever possible, in an
                 attempt to crash the target program (that is, to force
                 the program to behave erroneously). A crashing
                 execution provides concrete evidence of a destructive
                 bug, and this bug can be strongly correlated with a
                 specific race condition in the target
                 program.\par

                 Experimental results with our Jumble prototype for Java
                 demonstrate that adversarial memory is highly effective
                 at identifying destructive race conditions, and in
                 distinguishing them from race conditions that are real
                 but benign. Adversarial memory can also reveal
                 destructive races that would not be detected by
                 traditional testing (even after thousands of runs) or
                 by model checkers that assume sequential consistency.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "concurrency; dynamic analysis; race conditions;
                 relaxed memory models",
}

@Article{Geoffray:2010:VSM,
  author =       "Nicolas Geoffray and Ga{\"e}l Thomas and Julia Lawall
                 and Gilles Muller and Bertil Folliot",
  title =        "{VMKit}: a substrate for managed runtime
                 environments",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "7",
  pages =        "51--62",
  month =        jul,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1735997.1736006",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:01 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Managed Runtime Environments (MREs), such as the JVM
                 and the CLI, form an attractive environment for program
                 execution, by providing portability and safety, via the
                 use of a bytecode language and automatic memory
                 management, as well as good performance, via
                 just-in-time (JIT) compilation. Nevertheless,
                 developing a fully featured MRE, including e.g. a
                 garbage collector and JIT compiler, is a herculean
                 task. As a result, new languages cannot easily take
                 advantage of the benefits of MREs, and it is difficult
                 to experiment with extensions of existing MRE based
                 languages.\par

                 This paper describes and evaluates VMKit, a first
                 attempt to build a common substrate that eases the
                 development of high-level MREs. We have successfully
                 used VMKit to build two MREs: a Java Virtual Machine
                 and a Common Language Runtime. We provide an extensive
                 study of the lessons learned in developing this
                 infrastructure, and assess the ease of implementing new
                 MREs or MRE extensions and the resulting performance.
                 In particular, it took one of the authors only one
                 month to develop a Common Language Runtime using VMKit.
                 VMKit furthermore has performance comparable to the
                 well-established open-source MREs Cacao, Apache Harmony
                 and Mono, and is 1.2 to 3 times slower than JikesRVM on
                 most of the Dacapo benchmarks.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "just in time compiler; virtual machine; vmkit",
}

@Article{Haubl:2010:CES,
  author =       "Christian H{\"a}ubl and Christian Wimmer and Hanspeter
                 M{\"o}ssenb{\"o}ck",
  title =        "Compact and efficient strings for {Java}",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "75",
  number =       "11",
  pages =        "1077--1094",
  day =          "1",
  month =        nov,
  year =         "2010",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Fri Apr 1 18:39:38 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Heidenreich:2010:GST,
  author =       "Florian Heidenreich and Jendrik Johannes and Mirko
                 Seifert and Christian Wende and Marcel B{\"o}hme",
  title =        "Generating safe template languages",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "99--108",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1621607.1621624",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Template languages are widely used within generative
                 programming, because they provide intuitive means to
                 generate software artefacts expressed in a specific
                 object language. However, most template languages
                 perform template instantiation on the level of string
                 literals, which allows neither syntax checks nor
                 semantics analysis. To make sure that generated
                 artefacts always conform to the object language, we
                 propose to perform static analysis at template design
                 time. In addition, the increasing popularity of
                 domainspecific languages (DSLs) demands an approach
                 that allows to reuse both the concepts of template
                 languages and the corresponding tools.\par

                 In this paper we address the issues mentioned above by
                 presenting how existing languages can be automatically
                 extended with generic template concepts (e.g.,
                 placeholders, loops, conditions) to obtain safe
                 template languages. These languages provide means for
                 syntax checking and static semantic analysis w.r.t. the
                 object language at template design time. We discuss the
                 prerequisites for this extension, analyse the types of
                 correctness properties that can be assured at template
                 design time, and exemplify the key benefits of this
                 approach on a textual DSL and Java.",
  acknowledgement = ack-nhfb,
  keywords =     "generative programming; language extension; safe
                 authoring; template language",
}

@Article{Hellyer:2010:LCW,
  author =       "Laurence Hellyer and Richard Jones and Antony L.
                 Hosking",
  title =        "The locality of concurrent write barriers",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "83--92",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806651.1806666",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Concurrent and incremental collectors require barriers
                 to ensure correct synchronisation between mutator and
                 collector. The overheads imposed by particular barriers
                 on particular systems have been widely studied.
                 Somewhat fewer studies have also compared barriers in
                 terms of their termination properties or the volume of
                 floating garbage they generate. Until now, the
                 consequences for locality of different barrier choices
                 has not been studied, although locality will be of
                 increasing importance for emerging architectures. This
                 paper provides a study of the locality of concurrent
                 write barriers, independent of the processor
                 architecture, virtual machine, compiler or garbage
                 collection algorithm.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "garbage collection; java; language implementation;
                 memory management",
}

@Article{Higuera-Toledano:2010:ISI,
  author =       "M. Teresa Higuera-Toledano and Doug Locke and Angelo
                 Corsaro",
  title =        "Introduction to special issue on {Java} technologies
                 for real-time and embedded systems",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "1:1--1:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814540",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  articleno =    "1",
}

@Article{Hsiao:2010:EST,
  author =       "Chun-Feng Hsiao and Chih-Ping Chu",
  title =        "Enhancing {SCORM} through creating a reusable {Java}
                 class repository",
  journal =      j-SPE,
  volume =       "40",
  number =       "10",
  pages =        "865--881",
  month =        sep,
  year =         "2010",
  CODEN =        "SPEXBL",
  DOI =          "http://dx.doi.org/10.1002/spe.979",
  ISSN =         "0038-0644",
  bibdate =      "Tue Jun 21 17:09:49 MDT 2011",
  acknowledgement = ack-nhfb,
  onlinedate =   "7 May 2010",
}

@Article{Joseph:2010:PII,
  author =       "Damien Joseph and Soon Ang and Roger H. L. Chang and
                 Sandra A. Slaughter",
  title =        "Practical intelligence in {IT}: assessing soft skills
                 of {IT} professionals",
  journal =      j-CACM,
  volume =       "53",
  number =       "2",
  pages =        "149--154",
  month =        feb,
  year =         "2010",
  CODEN =        "CACMA2",
  DOI =          "http://doi.acm.org/10.1145/1646353.1646391",
  ISSN =         "0001-0782",
  bibdate =      "Thu Feb 4 17:13:32 MST 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/cacm/",
  abstract =     "What qualities make a successful it professional?
                 Certainty strong technical skills are sine qua non. As
                 a result, the technology geek remains the stereotype of
                 an information technology (IT) professional. Indeed,
                 when companies hire IT professionals, their focus is
                 often on the 'hard' skills needed to perform the work,
                 such as years of Java programming
                 experience.\par

                 However, there is a growing (and gnawing) awareness
                 that technical skills alone are insufficient for
                 success in IT, particularly in today's dynamic,
                 distributed and complex workplace. Companies are
                 exploring outsourcing and offshoring to become more
                 flexible and contain costs while strategically
                 leveraging IT. Consequently, IT professionals (whether
                 onsite or offshore, in-house or outsourced) must
                 acquire a broader set of skills beyond their
                 traditional technical skills. These broader managerial
                 or interpersonal skills are generically labeled 'soft
                 skills.'\par

                 Despite the increasing importance of soft skills, very
                 little systematic research has conceptualized such
                 skills and even less has measured these skills. Given
                 this gap in the literature, this article introduces
                 'practical intelligence' as the overarching concept
                 that could provide a better understanding of this
                 broader set of skills required of IT professionals. We
                 describe the development of the SoftSkills for IT
                 (SSIT) instrument for assessing an IT professional's
                 level of practical intelligence, and report the results
                 of a study that validates this instrument by comparing
                 the practical intelligence of experienced IT
                 professionals versus novices. We conclude by drawing
                 out implications of our study for IT recruitment,
                 training and development, and suggest future research
                 directions.",
  acknowledgement = ack-nhfb,
}

@Article{Kienle:2010:ATT,
  author =       "Holger M. Kienle",
  title =        "It's About Time to Take {JavaScript} (More) Seriously",
  journal =      j-IEEE-SOFTWARE,
  volume =       "27",
  number =       "3",
  pages =        "60--62",
  month =        may # "\slash " # jun,
  year =         "2010",
  CODEN =        "IESOEG",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MS.2010.76",
  ISSN =         "0740-7459 (print), 0740-7459 (electronic)",
  ISSN-L =       "0740-7459",
  bibdate =      "Thu May 13 07:56:44 2010",
  bibsource =    "http://computer.org/software/so2010/",
  acknowledgement = ack-nhfb,
  fjournal =     "IEEE Software",
}

@Article{Kim:2010:EAE,
  author =       "Minseong Kim and Andy Wellings",
  title =        "Efficient asynchronous event handling in the real-time
                 specification for {Java}",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "5:1--5:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814544",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The Real-Time Specification for Java (RTSJ) is
                 becoming mature. It has been implemented, formed the
                 basis for research and used in serious applications.
                 Some strengths and weaknesses are emerging. One of the
                 areas that requires further elaboration is asynchronous
                 event handling (AEH). The primary goal for handlers in
                 the RTSJ is to have a lightweight concurrency
                 mechanism. Some implementation will, however, simply
                 map a handler to a real-time thread and this results in
                 undermining the original motivations and introduces
                 performance penalties. However it is generally unclear
                 how to map handlers to real-time threads effectively.
                 Also the support for nonblocking handlers in the RTSJ
                 is criticized as lacking in configurability as
                 implementations are unable to take advantage of them.
                 This article, therefore, examines the AEH techniques
                 used in some popular RTSJ implementations and proposes
                 two efficient AEH models for the RTSJ. We then define
                 formal models of the RTSJ AEH implementations using the
                 automata formalism provided by the UPPAAL model
                 checking tool. Using the automata models, their
                 properties are explored and verified. In the proposed
                 models, blocking and nonblocking handlers are serviced
                 by different algorithms. In this way, it is possible to
                 assign a real-time thread to a handler at the right
                 time in the right place while maintaining the fewest
                 possible threads overall and to give a certain level of
                 configurability to AEH. We also have implemented the
                 proposed models on an existing RTSJ implementation,
                 jRate and executed a set of performance tests that
                 measure their respective dispatch and multiple-handler
                 completion latencies. The results from the tests and
                 the verifications indicate that the proposed models
                 require fewer threads on average with better
                 performance than other approaches.",
  acknowledgement = ack-nhfb,
  articleno =    "5",
  keywords =     "asynchronous event handling; blocking handler;
                 multiple-server switching phenomenon; nonblocking
                 handler; RTSJ",
}

@Article{Ko:2010:EAW,
  author =       "Andrew J. Ko and Brad A. Myers",
  title =        "Extracting and answering why and why not questions
                 about {Java} program output",
  journal =      j-TOSEM,
  volume =       "20",
  number =       "2",
  pages =        "4:1--4:??",
  month =        aug,
  year =         "2010",
  CODEN =        "ATSMER",
  DOI =          "http://doi.acm.org/10.1145/1824760.1824761",
  ISSN =         "1049-331X",
  bibdate =      "Wed Sep 8 18:47:44 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/tosem/",
  abstract =     "When software developers want to understand the reason
                 for a program's behavior, they must translate their
                 questions about the behavior into a series of questions
                 about code, speculating about the causes in the
                 process. The Whyline is a new kind of debugging tool
                 that avoids such speculation by instead enabling
                 developers to select a question about program output
                 from a set of ``why did and why didn't'' questions
                 extracted from the program's code and execution. The
                 tool then finds one or more possible explanations for
                 the output in question. These explanations are derived
                 using a static and dynamic slicing, precise call
                 graphs, reachability analyses, and new algorithms for
                 determining potential sources of values. Evaluations of
                 the tool on two debugging tasks showed that developers
                 with the Whyline were three times more successful and
                 twice as fast at debugging, compared to developers with
                 traditional breakpoint debuggers. The tool has the
                 potential to simplify debugging and program
                 understanding in many software development contexts.",
  acknowledgement = ack-nhfb,
  articleno =    "4",
  keywords =     "debugging; questions; Whyline",
}

@Article{Kolling:2010:GPE,
  author =       "Michael K{\"o}lling",
  title =        "The {Greenfoot} Programming Environment",
  journal =      j-TOCE,
  volume =       "10",
  number =       "4",
  pages =        "14:1--14:??",
  month =        nov,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://dx.doi.org/10.1145/1868358.1868361",
  ISSN =         "1946-6226",
  bibdate =      "Thu Dec 9 11:26:15 MST 2010",
  bibsource =    "http://www.acm.org/pubs/toce",
  abstract =     "Greenfoot is an educational integrated development
                 environment aimed at learning and teaching programming.
                 It is aimed at a target audience of students from about
                 14 years old upwards, and is also suitable for college-
                 and university-level education. Greenfoot combines
                 graphical, interactive output with programming in Java,
                 a standard, text-based object-oriented programming
                 language. This article first describes Greenfoot and
                 then goes on to discuss design goals and motivations,
                 strengths and weaknesses of the system, and its
                 relation to two environments with similar goals,
                 Scratch and Alice.",
  acknowledgement = ack-nhfb,
  articleno =    "14",
  fjournal =     "ACM Transactions on Computing Education",
}

@Article{Lee:2010:JSD,
  author =       "Byeongcheol Lee and Ben Wiedermann and Martin Hirzel
                 and Robert Grimm and Kathryn S. McKinley",
  title =        "{Jinn}: synthesizing dynamic bug detectors for foreign
                 language interfaces",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "36--49",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1809028.1806601",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Programming language specifications mandate static and
                 dynamic analyses to preclude syntactic and semantic
                 errors. Although individual languages are usually
                 well-specified, composing languages is not, and this
                 poor specification is a source of many errors in {\em
                 multilingual\/} programs. For example, virtually all
                 Java programs compose Java and C using the Java Native
                 Interface (JNI). Since JNI is informally specified,
                 developers have difficulty using it correctly, and
                 current Java compilers and virtual machines (VMs)
                 inconsistently check only a subset of JNI
                 constraints.\par

                 This paper's most significant contribution is to show
                 how to synthesize dynamic analyses from state machines
                 to detect foreign function interface (FFI) violations.
                 We identify three classes of FFI constraints encoded by
                 eleven state machines that capture thousands of JNI and
                 Python/C FFI rules. We use a mapping function to
                 specify which state machines, transitions, and program
                 entities (threads, objects, references) to check at
                 each FFI call and return. From this function, we
                 synthesize a context-specific dynamic analysis to find
                 FFI bugs. We build bug detection tools for JNI and
                 Python/C using this approach. For JNI, we dynamically
                 and transparently interpose the analysis on Java and C
                 language transitions through the JVM tools interface.
                 The resulting tool, called Jinn, is compiler and
                 virtual machine {\em independent}. It detects and
                 diagnoses a wide variety of FFI bugs that other tools
                 miss. This approach greatly reduces the annotation
                 burden by exploiting common FFI constraints: whereas
                 the generated Jinn code is 22,000+ lines, we wrote only
                 1,400 lines of state machine and mapping code. Overall,
                 this paper lays the foundation for a more principled
                 approach to developing correct multilingual software
                 and a more concise and automated approach to FFI
                 specification.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "dynamic analysis; ffi bugs; foreign function
                 interfaces (FFI); java native interface (jni);
                 multilingual programs; python/C; specification;
                 specification generation",
}

@Article{Lerner:2010:FTJ,
  author =       "Reuven M. Lerner",
  title =        "At the forge: testing {JavaScript}",
  journal =      j-LINUX-J,
  volume =       "2010",
  number =       "191",
  pages =        "6:1--6:??",
  month =        mar,
  year =         "2010",
  CODEN =        "LIJOFX",
  ISSN =         "1075-3583 (print), 1938-3827 (electronic)",
  ISSN-L =       "1075-3583",
  bibdate =      "Tue Nov 23 11:41:53 MST 2010",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  articleno =    "6",
  fjournal =     "Linux Journal",
}

@Article{Lerner:2010:SDT,
  author =       "Benjamin S. Lerner and Herman Venter and Dan
                 Grossman",
  title =        "Supporting dynamic, third-party code customizations in
                 {JavaScript} using aspects",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "361--376",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869490",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Marino:2010:DSE,
  author =       "Daniel Marino and Abhayendra Singh and Todd Millstein
                 and Madanlal Musuvathi and Satish Narayanasamy",
  title =        "{DRFX}: a simple and efficient memory model for
                 concurrent programming languages",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "351--362",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806636",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The most intuitive memory model for shared-memory
                 multithreaded programming is {\em sequential
                 consistency\/} (SC), but it disallows the use of many
                 compiler and hardware optimizations thereby impacting
                 performance. Data-race-free (DRF) models, such as the
                 proposed C++0x memory model, guarantee SC execution for
                 datarace-free programs. But these models provide no
                 guarantee at all for racy programs, compromising the
                 safety and debuggability of such programs. To address
                 the safety issue, the Java memory model, which is also
                 based on the DRF model, provides a weak semantics for
                 racy executions. However, this semantics is subtle and
                 complex, making it difficult for programmers to reason
                 about their programs and for compiler writers to ensure
                 the correctness of compiler optimizations.\par

                 We present the DRFx memory model, which is simple for
                 programmers to understand and use while still
                 supporting many common optimizations. We introduce a
                 {\em memory model (MM) exception\/} which can be
                 signaled to halt execution. If a program executes
                 without throwing this exception, then DRFx guarantees
                 that the execution is SC. If a program throws an MM
                 exception during an execution, then DRFx guarantees
                 that the program has a data race. We observe that SC
                 violations can be detected in hardware through a
                 lightweight form of conflict detection. Furthermore,
                 our model safely allows aggressive compiler and
                 hardware optimizations within compiler-designated
                 program regions. We formalize our memory model, prove
                 several properties about this model, describe a
                 compiler and hardware design suitable for DRFx, and
                 evaluate the performance overhead due to our compiler
                 and hardware requirements.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "data races; memory model exception; memory models;
                 sequential consistency; soft fences",
}

@Article{Markstrum:2010:JDP,
  author =       "Shane Markstrum and Daniel Marino and Matthew Esquivel
                 and Todd Millstein and Chris Andreae and James Noble",
  title =        "{JavaCOP}: {Declarative} pluggable types for {Java}",
  journal =      j-TOPLAS,
  volume =       "32",
  number =       "2",
  pages =        "4:1--4:37",
  month =        jan,
  year =         "2010",
  CODEN =        "ATPSDT",
  DOI =          "http://doi.acm.org/10.1145/1667048.1667049",
  ISSN =         "0164-0925",
  bibdate =      "Fri May 21 12:46:35 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "Pluggable types enable users to enforce multiple type
                 systems in one programming language. We have developed
                 a suite of tools, called the JavaCOP framework, that
                 allows developers to create pluggable type systems for
                 Java. JavaCOP provides a simple declarative language in
                 which program constraints are defined over a program's
                 abstract syntax tree. The JavaCOP compiler
                 automatically enforces these constraints on programs
                 during compilation. The JavaCOP framework also includes
                 a dataflow analysis API in order to support type
                 systems which depend on flow-sensitive information.
                 Finally, JavaCOP includes a novel test framework which
                 helps users gain confidence in the correctness of their
                 pluggable type systems. We demonstrate the framework by
                 discussing a number of pluggable type systems which
                 have been implemented in JavaCOP in order to detect
                 errors and enforce strong invariants in programs. These
                 type systems range from general-purpose checkers, such
                 as a type system for nonnull references, to
                 domain-specific ones, such as a checker for conformance
                 to a library's usage rules.",
  acknowledgement = ack-nhfb,
  articleno =    "4",
  keywords =     "JavaCOP; pluggable type systems",
}

@Article{Mateos:2010:MJN,
  author =       "Cristian Mateos and Alejandro Zunino and Marcelo
                 Campo",
  title =        "{m-JGRIM}: a novel middleware for {Gridifying Java}
                 applications into mobile {Grid} services",
  journal =      j-SPE,
  volume =       "40",
  number =       "4",
  pages =        "331--362",
  day =          "10",
  month =        apr,
  year =         "2010",
  CODEN =        "SPEXBL",
  DOI =          "http://dx.doi.org/10.1002/spe.961",
  ISSN =         "0038-0644",
  bibdate =      "Wed Mar 17 10:16:22 MDT 2010",
  bibsource =    "http://www3.interscience.wiley.com/journalfinder.html;
                 http://www.interscience.wiley.com/jpages/0038-0644",
  acknowledgement = ack-nhfb,
  onlinedate =   "Feb 3 2010 10:58AM",
}

@Article{McGachey:2010:CJC,
  author =       "Phil McGachey and Antony L. Hosking and J. Eliot B.
                 Moss",
  title =        "Classifying {Java} class transformations for pervasive
                 virtualized access",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "75--84",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1621607.1621620",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The indirection of object accesses is a common theme
                 for target domains as diverse as transparent
                 distribution, persistence, and program instrumentation.
                 Virtualizing accesses to fields and methods (by
                 redirecting calls through accessor and indirection
                 methods) allows interposition of arbitrary code,
                 extending the functionality of an application beyond
                 that intended by the original developer.\par

                 We present class modifications performed by our RuggedJ
                 transparent distribution platform for standard Java
                 virtual machines. RuggedJ abstracts over the location
                 of objects by implementing a single object model for
                 local and remote objects. However the implementation of
                 this model is complicated by the presence of native and
                 system code; classes loaded by Java's bootstrap class
                 loader can be rewritten only in a limited manner, and
                 so cannot be modified to conform to RuggedJ's complex
                 object model. We observe that system code comprises the
                 majority of a given Java application: an average of
                 76\% in the applications we study. We consider the
                 constraints imposed upon pervasive class transformation
                 within Java, and present a framework for systematically
                 rewriting arbitrary applications. Our system
                 accommodates all system classes, allowing both user and
                 system classes alike to be referenced using a single
                 object model.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "Java; object model; program transformation",
}

@Article{McIlroy:2010:HJR,
  author =       "Ross McIlroy and Joe Sventek",
  title =        "{Hera-JVM}: a runtime system for heterogeneous
                 multi-core architectures",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "205--222",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869478",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Mitchell:2010:FTL,
  author =       "Nick Mitchell and Edith Schonberg and Gary Sevitsky",
  title =        "Four Trends Leading to {Java} Runtime Bloat",
  journal =      j-IEEE-SOFTWARE,
  volume =       "27",
  number =       "1",
  pages =        "56--63",
  month =        jan # "\slash " # feb,
  year =         "2010",
  CODEN =        "IESOEG",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MS.2010.7",
  ISSN =         "0740-7459 (print), 0740-7459 (electronic)",
  ISSN-L =       "0740-7459",
  bibdate =      "Thu May 13 07:56:44 2010",
  bibsource =    "http://computer.org/software/so2010/",
  acknowledgement = ack-nhfb,
  fjournal =     "IEEE Software",
}

@Article{Mytkowicz:2010:EAJ,
  author =       "Todd Mytkowicz and Amer Diwan and Matthias Hauswirth
                 and Peter F. Sweeney",
  title =        "Evaluating the accuracy of {Java} profilers",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "187--197",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806618",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Performance analysts profile their programs to find
                 methods that are worth optimizing: the 'hot' methods.
                 This paper shows that four commonly-used Java profilers
                 ({\em xprof , hprof , jprofile, and yourkit\/}) often
                 disagree on the identity of the hot methods. If two
                 profilers disagree, at least one must be incorrect.
                 Thus, there is a good chance that a profiler will
                 mislead a performance analyst into wasting time
                 optimizing a cold method with little or no performance
                 improvement.\par

                 This paper uses causality analysis to evaluate
                 profilers and to gain insight into the source of their
                 incorrectness. It shows that these profilers all
                 violate a fundamental requirement for sampling based
                 profilers: to be correct, a sampling-based profiler
                 must collect samples randomly.\par

                 We show that a proof-of-concept profiler, which
                 collects samples randomly, does not suffer from the
                 above problems. Specifically, we show, using a number
                 of case studies, that our profiler correctly identifies
                 methods that are important to optimize; in some cases
                 other profilers report that these methods are cold and
                 thus not worth optimizing.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "bias; observer effect; profiling",
}

@Article{Nakaike:2010:LER,
  author =       "Takuya Nakaike and Maged M. Michael",
  title =        "Lock elision for read-only critical sections in
                 {Java}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "269--278",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806627",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "It is not uncommon in parallel workloads to encounter
                 shared data structures with read-mostly access
                 patterns, where operations that update data are
                 infrequent and most operations are read-only.
                 Typically, data consistency is guaranteed using mutual
                 exclusion or read-write locks. The cost of atomic
                 update of lock variables result in high overheads and
                 high cache coherence traffic under active sharing, thus
                 slowing down single thread performance and limiting
                 scalability.\par

                 In this paper, we present {\em SOLERO (Software
                 Optimistic Lock Elision for Read-Only critical
                 sections)}, a new lock implementation called for
                 optimizing read-only critical sections in Java based on
                 sequential locks. SOLERO is compatible with the
                 conventional lock implementation of Java. However,
                 unlike the conventional implementation, only critical
                 sections that may write data or have side effects need
                 to update lock variables, while read-only critical
                 sections need only read lock variables without writing
                 them. Each writing critical section changes the lock
                 value to a new value. Hence, a read-only critical
                 section is guaranteed to be consistent if the lock is
                 free and its value does not change from the beginning
                 to the end of the read-only critical section.\par

                 Using Java workloads including SPECjbb2005 and the
                 HashMap and TreeMap Java classes, we evaluate the
                 performance impact of applying SOLERO to read-mostly
                 locks. Our experimental results show performance
                 improvements across the board, often substantial, in
                 both single thread speed and scalability over the
                 conventional lock implementation (mutual exclusion) and
                 read-write locks. SOLERO improves the performance of
                 SPECjbb2005 by 3-5\% on single and multiple threads.
                 The results using the HashMap and TreeMap benchmarks
                 show that SOLERO outperforms the conventional lock
                 implementation and read-write locks by substantial
                 multiples on multi-threads.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "java; just-in-time compiler; lock; lock elision;
                 monitor; optimization; synchronization",
}

@Article{Namjoshi:2010:NOP,
  author =       "Manjiri A. Namjoshi and Prasad A. Kulkarni",
  title =        "Novel online profiling for virtual machines",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "7",
  pages =        "133--144",
  month =        jul,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1735997.1736016",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:01 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Application {\em profiling\/} is a popular technique
                 to improve program performance based on its behavior.
                 {\em Offline\/} profiling, although beneficial for
                 several applications, fails in cases where prior
                 program runs may not be feasible, or if changes in
                 input cause the profile to not match the behavior of
                 the actual program run. Managed languages, like Java
                 and C\\#, provide a unique opportunity to overcome the
                 drawbacks of offline profiling by generating the
                 profile information online during the current program
                 run. Indeed, online profiling is extensively used in
                 current VMs, especially during selective compilation to
                 improve program {\em startup\/} performance, as well as
                 during other feedback-directed optimizations.\par

                 In this paper we illustrate the drawbacks of the
                 current {\em reactive\/} mechanism of online profiling
                 during selective compilation. Current VM profiling
                 mechanisms are slow -- thereby delaying associated
                 transformations, and estimate future behavior based on
                 the program's immediate past -- leading to potential
                 misspeculation that limit the benefits of compilation.
                 We show that these drawbacks produce an average
                 performance loss of over 14.5\% on our set of benchmark
                 programs, over an {\em ideal offline\/} approach that
                 accurately compiles the hot methods early. We then
                 propose and evaluate the potential of a novel strategy
                 to achieve similar performance benefits with an online
                 profiling approach. Our new online profiling strategy
                 uses early determination of loop iteration bounds to
                 predict future method hotness. We explore and present
                 promising results on the potential, feasibility, and
                 other issues involved for the successful implementation
                 of this approach.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "java; online profiling; virtual machines",
}

@Article{Nasseri:2010:CMR,
  author =       "E. Nasseri and S. Counsell and M. Shepperd",
  title =        "Class movement and re-location: {An} empirical study
                 of {Java} inheritance evolution",
  journal =      j-J-SYST-SOFTW,
  volume =       "83",
  number =       "2",
  pages =        "303--315",
  month =        feb,
  year =         "2010",
  CODEN =        "JSSODM",
  ISSN =         "0164-1212",
  bibdate =      "Tue Sep 7 07:27:05 MDT 2010",
  bibsource =    "http://www.sciencedirect.com/science/journal/01641212",
  acknowledgement = ack-nhfb,
}

@Article{Nieuwpoort:2010:SHL,
  author =       "Rob V. Van Nieuwpoort and Gosia Wrzesi{\'n}ska and
                 Ceriel J. H. Jacobs and Henri E. Bal",
  title =        "{Satin}: {A} high-level and efficient grid programming
                 model",
  journal =      j-TOPLAS,
  volume =       "32",
  number =       "3",
  pages =        "9:1--9:39",
  month =        mar,
  year =         "2010",
  CODEN =        "ATPSDT",
  DOI =          "http://doi.acm.org/10.1145/1709093.1709096",
  ISSN =         "0164-0925",
  bibdate =      "Fri May 21 12:46:48 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "Computational grids have an enormous potential to
                 provide compute power. However, this power remains
                 largely unexploited today for most applications, except
                 trivially parallel programs. Developing parallel grid
                 applications simply is too difficult. Grids introduce
                 several problems not encountered before, mainly due to
                 the highly heterogeneous and dynamic computing and
                 networking environment. Furthermore, failures occur
                 frequently, and resources may be claimed by
                 higher-priority jobs at any time.\par

                 In this article, we solve these problems for an
                 important class of applications: divide-and-conquer. We
                 introduce a system called Satin that simplifies the
                 development of parallel grid applications by providing
                 a rich high-level programming model that completely
                 hides communication. All grid issues are transparently
                 handled in the runtime system, not by the programmer.
                 Satin's programming model is based on Java, features
                 spawn-sync primitives and shared objects, and uses
                 asynchronous exceptions and an abort mechanism to
                 support speculative parallelism.\par

                 To allow an efficient implementation, Satin
                 consistently exploits the idea that grids are
                 hierarchically structured. Dynamic load-balancing is
                 done with a novel cluster-aware scheduling algorithm
                 that hides the long wide-area latencies by overlapping
                 them with useful local work. Satin's shared object
                 model lets the application define the consistency model
                 it needs. If an application needs only loose
                 consistency, it does not have to pay high performance
                 penalties for wide-area communication and
                 synchronization.\par

                 We demonstrate how grid problems such as resource
                 changes and failures can be handled transparently and
                 efficiently. Finally, we show that adaptivity is
                 important in grids. Satin can increase performance
                 considerably by adding and removing compute resources
                 automatically, based on the application's requirements
                 and the utilization of the machines and networks in the
                 grid.\par

                 Using an extensive evaluation on real grids with up to
                 960 cores, we demonstrate that it is possible to
                 provide a simple high-level programming model for
                 divide-and-conquer applications, while achieving
                 excellent performance on grids. At the same time, we
                 show that the divide-and-conquer model scales better on
                 large systems than the master-worker approach, since it
                 has no single central bottleneck.",
  acknowledgement = ack-nhfb,
  articleno =    "9",
  keywords =     "divide-and-conquer; Grid computing; programming
                 model",
}

@Article{Odaira:2010:ERT,
  author =       "Rei Odaira and Kazunori Ogata and Kiyokuni Kawachiya
                 and Tamiya Onodera and Toshio Nakatani",
  title =        "Efficient runtime tracking of allocation sites in
                 {Java}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "7",
  pages =        "109--120",
  month =        jul,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837854.1736014",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:01 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Tracking the allocation site of every object at
                 runtime is useful for reliable, optimized Java. To be
                 used in production environments, the tracking must be
                 accurate with minimal speed loss. Previous approaches
                 suffer from performance degradation due to the
                 additional field added to each object or track the
                 allocation sites only probabilistically. We propose two
                 novel approaches to track the allocation sites of every
                 object in Java with only a 1.0\% slow-down on average.
                 Our first approach, the {\em
                 Allocation-Site-as-a-Hash-code (ASH) Tracker}, encodes
                 the allocation site ID of an object into the hash code
                 field of its header by regarding the ID as part of the
                 hash code. ASH Tracker avoids an excessive increase in
                 hash code collisions by dynamically shrinking the
                 bit-length of the ID as more and more objects are
                 allocated at that site. For those Java VMs without the
                 hash code field, our second approach, the {\em
                 Allocation-Site-via-a-Class-pointer (ASC) Tracker},
                 makes the class pointer field in an object header refer
                 to the allocation site structure of the object, which
                 in turn points to the actual class structure. ASC
                 Tracker mitigates the indirection overhead by
                 constant-class-field duplication and allocation-site
                 equality checks. While a previous approach of adding a
                 4-byte field caused up to 14.4\% and an average 5\%
                 slowdown, both ASH and ASC Trackers incur at most a
                 2.0\% and an average 1.0\% loss. We demonstrate the
                 usefulness of our low-overhead trackers by an
                 allocation-site-aware memory leak detector and
                 allocation-site-based pretenuring in generational GC.
                 Our pretenuring achieved on average 1.8\% and up to
                 11.8\% speedups in SPECjvm2008.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "allocation site; hash code; memory allocation",
}

@Article{Ogata:2010:SJN,
  author =       "Kazunori Ogata and Dai Mikurube and Kiyokuni Kawachiya
                 and Scott Trent and Tamiya Onodera",
  title =        "A study of {Java}'s non-{Java} memory",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "191--204",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869477",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Pitter:2010:RTJ,
  author =       "Christof Pitter and Martin Schoeberl",
  title =        "A real-time {Java} chip-multiprocessor",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "9:1--9:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814548",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Chip-multiprocessors are an emerging trend for
                 embedded systems. In this article, we introduce a
                 real-time Java multiprocessor called JopCMP. It is a
                 symmetric shared-memory multiprocessor, and consists of
                 up to eight Java Optimized Processor (JOP) cores, an
                 arbitration control device, and a shared memory. All
                 components are interconnected via a system on chip bus.
                 The arbiter synchronizes the access of multiple CPUs to
                 the shared main memory. In this article, three
                 different arbitration policies are presented,
                 evaluated, and compared with respect to their real-time
                 and average-case performance: a fixed priority, a
                 fair-based, and a time-sliced arbiter.\par

                 Tasks running on different CPUs of a
                 chip-multiprocessor (CMP) influence each others'
                 execution times when accessing a shared memory.
                 Therefore, the system needs an arbiter that is able to
                 limit the worst-case execution time of a task running
                 on a CPU, even though tasks executing simultaneously on
                 other CPUs access the main memory. Our research shows
                 that timing analysis is in fact possible for
                 homogeneous multiprocessor systems with a shared
                 memory. The timing analysis of tasks, executing on the
                 CMP using time-sliced memory arbitration, leads to
                 viable worst-case execution time bounds.\par

                 The time-sliced arbiter divides the memory access time
                 into equal time slots, one time slot for each CPU. This
                 memory arbitration scheme allows for a calculation of
                 upper bounds of Java application worst-case execution
                 times, depending on the number of CPUs, the time slot
                 size, and the memory access time. Examples of
                 worst-case execution time calculation are presented,
                 and the analyzed results of a real-world application
                 task are compared to measured execution time results.
                 Finally, we evaluate the tradeoffs when using a
                 time-predictable solution compared to using
                 average-case optimized chip-multiprocessors, applying
                 three different benchmarks. These experiments are
                 carried out by executing the programs on the CMP
                 prototype.",
  acknowledgement = ack-nhfb,
  articleno =    "9",
  keywords =     "Java processor; multiprocessor; Real-time system;
                 shared memory; worst-case execution time",
}

@Article{Pizlo:2010:SFT,
  author =       "Filip Pizlo and Lukasz Ziarek and Petr Maj and Antony
                 L. Hosking and Ethan Blanton and Jan Vitek",
  title =        "{SCHISM}: fragmentation-tolerant real-time garbage
                 collection",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "146--159",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806615",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Managed languages such as Java and C\# are being
                 considered for use in hard real-time systems. A hurdle
                 to their widespread adoption is the lack of garbage
                 collection algorithms that offer predictable
                 space-and-time performance in the face of
                 fragmentation. We introduce SCHISM/CMR, a new
                 concurrent and real-time garbage collector that is
                 fragmentation tolerant and guarantees time-and-space
                 worst-case bounds while providing good throughput.
                 SCHISM/CMR combines mark-region collection of
                 fragmented objects and arrays (arraylets) with separate
                 replication-copying collection of immutable arraylet
                 spines, so as to cope with external fragmentation when
                 running in small heaps. We present an implementation of
                 SCHISM/CMR in the Fiji VM, a high-performance Java
                 virtual machine for mission-critical systems, along
                 with a thorough experimental evaluation on a wide
                 variety of architectures, including server-class and
                 embedded systems. The results show that SCHISM/CMR
                 tolerates fragmentation better than previous schemes,
                 with a much more acceptable throughput penalty.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "fragmentation; mark-region; mark-sweep; real-time;
                 replication-copying",
}

@Article{Richards:2010:ADB,
  author =       "Gregor Richards and Sylvain Lebresne and Brian Burg
                 and Jan Vitek",
  title =        "An analysis of the dynamic behavior of {JavaScript}
                 programs",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "1--12",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806598",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "The JavaScript programming language is widely used for
                 web programming and, increasingly, for general purpose
                 computing. As such, improving the correctness, security
                 and performance of JavaScript applications has been the
                 driving force for research in type systems, static
                 analysis and compiler techniques for this language.
                 Many of these techniques aim to reign in some of the
                 most dynamic features of the language, yet little seems
                 to be known about how programmers actually utilize the
                 language or these features. In this paper we perform an
                 empirical study of the dynamic behavior of a corpus of
                 widely-used JavaScript programs, and analyze how and
                 why the dynamic features are used. We report on the
                 degree of dynamism that is exhibited by these
                 JavaScript programs and compare that with assumptions
                 commonly made in the literature and accepted industry
                 benchmark suites.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "dynamic behavior; dynamic metrics; execution tracing;
                 javascript; program analysis",
}

@Article{Santos:2010:MPB,
  author =       "Osmar Marchi Dos Santos and Andy Wellings",
  title =        "Measuring and policing blocking times in real-time
                 systems",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "2:1--2:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814541",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "In real-time systems, the execution-time overrun of a
                 thread may lead to a deadline being missed by the
                 thread or even others threads in the system. From a
                 fault tolerance perspective, both execution time
                 overruns and deadline misses can be considered timing
                 errors that could potentially cause a failure in the
                 system's ability to deliver its services in a timely
                 manner. In this context, the ideal is to detect the
                 error in the system as soon as possible, so that the
                 propagation of the error can be limited and error
                 recovery strategies can take place with more accurate
                 information. The run-time support mechanism usually
                 deployed for monitoring the timing requirements of
                 real-time systems is based on deadline monitoring, that
                 is, the system calls specific application code whenever
                 a deadline is violated. Recognizing that deadline
                 monitoring may not be enough for providing an adequate
                 level of fault tolerance for timing errors, major
                 real-time programming standards, like Ada, POSIX and
                 the Real-Time Specification for Java (RTSJ), have
                 proposed different mechanisms for monitoring the
                 execution time of threads. Nevertheless, in order to
                 provide a complete fault tolerance approach for timing
                 errors, the potential blocking time of threads also has
                 to be monitored. In this article, we propose mechanisms
                 for measuring and policing the blocking time of threads
                 in the context of both {\em basic priority
                 inheritance\/} and {\em priority ceiling protocols}.
                 The notion of {\em blocking-time clocks and timers\/}
                 for the POSIX standard is proposed, implemented and
                 evaluated in the open-source real-time operating system
                 MaRTE OS. Also, a {\em blocking time monitoring
                 model\/} for measuring and policing blocking times in
                 the RTSJ framework is specified. This model is
                 implemented and evaluated in the (RTSJ-compliant)
                 open-source middleware jRate, running on top of MaRTE
                 OS.",
  acknowledgement = ack-nhfb,
  articleno =    "2",
  keywords =     "error detection; POSIX standard; Real-time
                 specification for Java; timing errors",
}

@Article{Sartor:2010:ZRD,
  author =       "Jennifer B. Sartor and Stephen M. Blackburn and Daniel
                 Frampton and Martin Hirzel and Kathryn S. McKinley",
  title =        "{Z}-rays: divide arrays and conquer speed and
                 flexibility",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "471--482",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806649",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Arrays are the ubiquitous organization for indexed
                 data. Throughout programming language evolution,
                 implementations have laid out arrays contiguously in
                 memory. This layout is problematic in space and time.
                 It causes heap fragmentation, garbage collection pauses
                 in proportion to array size, and wasted memory for
                 sparse and over-provisioned arrays. Because of array
                 virtualization in managed languages, an array layout
                 that consists of indirection pointers to fixed-size
                 discontiguous memory blocks can mitigate these problems
                 transparently. This design however incurs significant
                 overhead, but is justified when real-time deadlines and
                 space constraints trump performance.\par

                 This paper proposes {\em z-rays}, a discontiguous array
                 design with flexibility and efficiency. A z-ray has a
                 spine with indirection pointers to fixed-size memory
                 blocks called {\em arraylets}, and uses five
                 optimizations: (1) inlining the first N array bytes
                 into the spine, (2) lazy allocation, (3) zero
                 compression, (4) fast array copy, and (5) arraylet
                 copy-on-write. Whereas discontiguous arrays in prior
                 work improve responsiveness and space efficiency,
                 z-rays combine time efficiency and flexibility. On
                 average, the best z-ray configuration performs within
                 12.7\% of an unmodified Java Virtual Machine on 19
                 benchmarks, whereas previous designs have {\em two to
                 three times\/} higher overheads. Furthermore, language
                 implementers can configure z-ray optimizations for
                 various design goals. This combination of performance
                 and flexibility creates a better building block for
                 past and future array optimization.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "arraylets; arrays; compression; heap; z-rays",
}

@Article{Schmidt:2010:ERA,
  author =       "Richard B. Schmidt",
  title =        "Experience report: {Ada} \& {Java} integration in the
                 {FAA}'s {ERAM SWIM} program",
  journal =      j-SIGADA-LETTERS,
  volume =       "30",
  number =       "3",
  pages =        "33--34",
  month =        dec,
  year =         "2010",
  CODEN =        "AALEE5",
  DOI =          "http://dx.doi.org/10.1145/1879097.1879075",
  ISSN =         "0736-721X",
  bibdate =      "Mon Jan 10 13:57:43 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGAda Ada Letters",
}

@Article{Schoeberl:2010:NRT,
  author =       "Martin Schoeberl and Wolfgang Puffitsch",
  title =        "Nonblocking real-time garbage collection",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "6:1--6:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814545",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "A real-time garbage collector has to fulfill two basic
                 properties: ensure that programs with bounded
                 allocation rates do not run out of memory and provide
                 short blocking times. Even for incremental garbage
                 collectors, two major sources of blocking exist,
                 namely, root scanning and heap compaction. Finding root
                 nodes of an object graph is an integral part of tracing
                 garbage collectors and cannot be circumvented. Heap
                 compaction is necessary to avoid probably unbounded
                 heap fragmentation, which in turn would lead to
                 unacceptably high memory consumption. In this article,
                 we propose solutions to both issues.\par

                 Thread stacks are local to a thread, and root scanning,
                 therefore, only needs to be atomic with respect to the
                 thread whose stack is scanned. This fact can be
                 utilized by either blocking only the thread whose stack
                 is scanned, or by delegating the responsibility for
                 root scanning to the application threads. The latter
                 solution eliminates blocking due to root scanning
                 completely. The impact of this solution on the
                 execution time of a garbage collector is shown for two
                 different variants of such a root scanning
                 algorithm.\par

                 During heap compaction, objects are copied. Copying is
                 usually performed atomically to avoid interference with
                 application threads, which could render the state of an
                 object inconsistent. Copying of large objects and
                 especially large arrays introduces long blocking times
                 that are unacceptable for real-time systems. In this
                 article, an interruptible copy unit is presented that
                 implements nonblocking object copy. The unit can be
                 interrupted after a single word move.\par

                 We evaluate a real-time garbage collector that uses the
                 proposed techniques on a Java processor. With this
                 garbage collector, it is possible to run high-priority
                 hard real-time tasks at 10 kHz parallel to the garbage
                 collection task on a 100 MHz system.",
  acknowledgement = ack-nhfb,
  articleno =    "6",
  keywords =     "Garbage collection; nonblocking copying; real-time;
                 root scanning",
}

@Article{Schoeberl:2010:WCE,
  author =       "Martin Schoeberl and Wolfgang Puffitsch and Rasmus
                 Ulslev Pedersen and Benedikt Huber",
  title =        "Worst-case execution time analysis for a {Java}
                 processor",
  journal =      j-SPE,
  volume =       "40",
  number =       "6",
  pages =        "507--542",
  month =        may,
  year =         "2010",
  CODEN =        "SPEXBL",
  DOI =          "http://dx.doi.org/10.1002/spe.968",
  ISSN =         "0038-0644",
  bibdate =      "Tue Jun 21 17:09:46 MDT 2011",
  acknowledgement = ack-nhfb,
  onlinedate =   "6 Apr 2010",
}

@Article{Schultz:2010:WAJ,
  author =       "Christopher Schultz",
  title =        "{Web} applications with {Java\slash JSP}",
  journal =      j-LINUX-J,
  volume =       "2010",
  number =       "197",
  pages =        "4:1--4:??",
  month =        sep,
  year =         "2010",
  CODEN =        "LIJOFX",
  ISSN =         "1075-3583 (print), 1938-3827 (electronic)",
  ISSN-L =       "1075-3583",
  bibdate =      "Tue Nov 23 11:41:55 MST 2010",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  articleno =    "4",
  fjournal =     "Linux Journal",
}

@Article{Sciampacone:2010:EMS,
  author =       "R. A. Sciampacone and V. Sundaresan and D. Maier and
                 T. Gray-Donald",
  title =        "Exploitation of multicore systems in a {Java} virtual
                 machine",
  journal =      j-IBM-JRD,
  volume =       "54",
  number =       "5",
  pages =        "1:1--1:11",
  month =        "????",
  year =         "2010",
  CODEN =        "IBMJAE",
  DOI =          "http://dx.doi.org/10.1147/JRD.2010.2057911",
  ISSN =         "0018-8646",
  bibdate =      "Sun Feb 20 14:29:19 MST 2011",
  bibsource =    "http://www.research.ibm.com/journal/",
  acknowledgement = ack-nhfb,
}

@Article{Servetto:2010:MMC,
  author =       "Marco Servetto and Elena Zucca",
  title =        "{MetaFJig}: a meta-circular composition language for
                 {Java}-like classes",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "464--483",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869498",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Siebert:2010:CPR,
  author =       "Fridtjof Siebert",
  title =        "Concurrent, parallel, real-time garbage-collection",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "11--20",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837855.1806654",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "With the current developments in CPU implementations,
                 it becomes obvious that ever more parallel multicore
                 systems will be used even in embedded controllers that
                 require real-time guarantees. When garbage collection
                 is used in these systems, parallel and concurrent
                 garbage collection brings important performance
                 advantages in the average case. In a real-time system,
                 however, guarantees on the GC's performance in the
                 worst case are required.\par

                 This paper explains how the single-CPU real-time GC of
                 the Java implementation JamaicaVM was changed to make
                 it a hard real-time garbage collector that is parallel
                 and concurrent. Parallel means that an arbitrary number
                 of CPUs may perform GC work in parallel, while
                 concurrent means that the GC work can be performed
                 concurrently to the application code without
                 pre-empting the application. In addition, the single
                 units of work that this garbage collector has to
                 perform are very small and uniform and the total amount
                 of GC work is bounded by a function of the heap size,
                 such that it becomes possible for any application that
                 has a bounded amount of reachable memory to run the GC
                 work such that sufficient GC progress can be ensured
                 for the application never to run out of heap space.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "concurrent; garbage collection; java; multicore;
                 parallel; real-time",
}

@Article{Singer:2010:EGC,
  author =       "Jeremy Singer and Richard E. Jones and Gavin Brown and
                 Mikel Luj{\'a}n",
  title =        "The economics of garbage collection",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "103--112",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806651.1806669",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "This paper argues that economic theory can improve our
                 understanding of memory management. We introduce the
                 {\em allocation curve}, as an analogue of the demand
                 curve from microeconomics. An allocation curve for a
                 program characterises how the amount of garbage
                 collection activity required during its execution
                 varies in relation to the heap size associated with
                 that program. The standard treatment of microeconomic
                 demand curves (shifts and elasticity) can be applied
                 directly and intuitively to our new allocation curves.
                 As an application of this new theory, we show how {\em
                 allocation elasticity\/} can be used to control the
                 heap growth rate for variable sized heaps in Jikes
                 RVM.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "allocation curve; elasticity; garbage collection;
                 java; memory management; microeconomics",
}

@Article{Spoto:2010:MSL,
  author =       "Fausto Spoto and {\'E}tienne Payet",
  title =        "Magic-sets for localised analysis of {Java} bytecode",
  journal =      j-HIGHER-ORDER-SYMB-COMPUT,
  volume =       "23",
  number =       "1",
  pages =        "29--86",
  month =        mar,
  year =         "2010",
  CODEN =        "LSCOEX",
  ISSN =         "1388-3690 (print), 2212-0793 (electronic)",
  ISSN-L =       "1388-3690",
  bibdate =      "Tue Sep 6 16:06:25 MDT 2011",
  bibsource =    "http://springerlink.metapress.com/openurl.asp?genre=issue&issn=1388-3690&volume=23&issue=1",
  URL =          "http://www.springerlink.com/openurl.asp?genre=article&issn=1388-3690&volume=23&issue=1&spage=29",
  acknowledgement = ack-nhfb,
}

@Article{Spoto:2010:TAJ,
  author =       "Fausto Spoto and Fred Mesnard and {\'E}tienne Payet",
  title =        "A termination analyzer for {Java} bytecode based on
                 path-length",
  journal =      j-TOPLAS,
  volume =       "32",
  number =       "3",
  pages =        "8:1--8:70",
  month =        mar,
  year =         "2010",
  CODEN =        "ATPSDT",
  DOI =          "http://doi.acm.org/10.1145/1709093.1709095",
  ISSN =         "0164-0925",
  bibdate =      "Fri May 21 12:46:48 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "It is important to prove that supposedly terminating
                 programs actually terminate, particularly if those
                 programs must be run on critical systems or downloaded
                 into a client such as a mobile phone. Although
                 termination of computer programs is generally
                 undecidable, it is possible and useful to prove
                 termination of a large, nontrivial subset of the
                 terminating programs. In this article, we present our
                 termination analyzer for sequential Java bytecode,
                 based on a program property called {\em path-length}.
                 We describe the analyses which are needed before the
                 path-length can be computed such as sharing, cyclicity,
                 and aliasing. Then we formally define the path-length
                 analysis and prove it correct with respect to a
                 reference denotational semantics of the bytecode. We
                 show that a constraint logic program {\em P\/}$_{{\em
                 CLP\/}}$ can be built from the result of the
                 path-length analysis of a Java bytecode program {\em
                 P\/} and formally prove that if {\em P\/}$_{{\em
                 CLP\/}}$ terminates, then {\em P\/} also terminates.
                 Hence a termination prover for constraint logic
                 programs can be applied to prove the termination of
                 {\em P}. We conclude with some discussion of the
                 possibilities and limitations of our approach. Ours is
                 the first existing termination analyzer for Java
                 bytecode dealing with any kind of data structures
                 dynamically allocated on the heap and which does not
                 require any help or annotation on the part of the
                 user.",
  acknowledgement = ack-nhfb,
  articleno =    "8",
  keywords =     "Abstract interpretation; Java; Java bytecode;
                 termination analysis",
}

@Article{Spring:2010:RAI,
  author =       "Jesper Honig Spring and Filip Pizlo and Jean Privat
                 and Rachid Guerraoui and Jan Vitek",
  title =        "{Reflexes}: {Abstractions} for integrating highly
                 responsive tasks into {Java} applications",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "4:1--4:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814543",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Achieving submillisecond response times in a managed
                 language environment such as Java or C\# requires
                 overcoming significant challenges. In this article, we
                 propose Reflexes, a programming model and runtime
                 system infrastructure that lets developers seamlessly
                 mix highly responsive tasks and timing-oblivious Java
                 applications. Thus enabling gradual addition of
                 real-time features, to a non-real-time application
                 without having to resort to recoding the real-time
                 parts in a different language such as C or Ada.
                 Experiments with the Reflex prototype implementation
                 show that it is possible to run a real-time task with a
                 period of 45$\mu$s with an accuracy of 99.996\% (only
                 0.001\% worse than the corresponding C implementation)
                 in the presence of garbage collection and heavy load
                 ordinary Java threads.",
  acknowledgement = ack-nhfb,
  articleno =    "4",
  keywords =     "Java virtual machine; memory management; Real-time
                 systems",
}

@Book{Stark:2010:BIA,
  author =       "Jonathan Stark",
  title =        "Building {iPhone} apps with {HTML}, {CSS}, and
                 {JavaScript}: Making {App Store} apps without
                 {Objective-C} or {Cocoa}",
  publisher =    pub-ORA-MEDIA,
  address =      pub-ORA-MEDIA:adr,
  pages =        "xv + 166",
  year =         "2010",
  ISBN =         "1-4493-8023-9, 0-596-80578-0",
  ISBN-13 =      "978-1-4493-8023-6, 978-0-596-80578-4",
  LCCN =         "????",
  bibdate =      "Wed Jul 28 09:12:55 MDT 2010",
  bibsource =    "z3950.bibsys.no:2100/BIBSYS",
  acknowledgement = ack-nhfb,
  subject =      "Cascading Style Sheets; HTML (document markup
                 language); computer software; development; iPhone
                 (Smartphone); programming; JavaScript (computer program
                 language)",
}

@Book{Stefanov:2010:JP,
  author =       "Stoyan Stefanov",
  title =        "{JavaScript} patterns",
  publisher =    pub-ORA,
  address =      pub-ORA:adr,
  pages =        "xvi + 216",
  year =         "2010",
  ISBN =         "1-4493-9911-8 (paperback), 0-596-80675-2 (paperback)",
  ISBN-13 =      "978-1-4493-9911-5 (paperback), 978-0-596-80675-0
                 (paperback)",
  LCCN =         "QA76.73.J39 S734 2010",
  bibdate =      "Wed Apr 27 11:12:26 MDT 2011",
  bibsource =    "melvyl.cdlib.org:210/CDL90",
  acknowledgement = ack-nhfb,
  subject =      "JavaScript (Computer program language); Software
                 patterns; Web site development",
}

@Article{Steimann:2010:TMI,
  author =       "Friedrich Steimann and Thomas Pawlitzki and Sven Apel
                 and Christian K{\"a}stner",
  title =        "Types and modularity for implicit invocation with
                 implicit announcement",
  journal =      j-TOSEM,
  volume =       "20",
  number =       "1",
  pages =        "1:1--1:??",
  month =        jun,
  year =         "2010",
  CODEN =        "ATSMER",
  DOI =          "http://doi.acm.org/10.1145/1767751.1767752",
  ISSN =         "1049-331X",
  bibdate =      "Tue Jul 6 16:17:49 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/tosem/",
  abstract =     "Through implicit invocation, procedures are called
                 without explicitly referencing them. Implicit
                 announcement adds to this implicitness by not only
                 keeping implicit which procedures are called, but also
                 where or when --- under implicit invocation with
                 implicit announcement, the call site contains no signs
                 of that, or what it calls. Recently, aspect-oriented
                 programming has popularized implicit invocation with
                 implicit announcement as a possibility to separate
                 concerns that lead to interwoven code if conventional
                 programming techniques are used. However, as has been
                 noted elsewhere, as currently implemented it
                 establishes strong implicit dependencies between
                 components, hampering independent software development
                 and evolution. To address this problem, we present a
                 type-based modularization of implicit invocation with
                 implicit announcement that is inspired by how
                 interfaces and exceptions are realized in Java. By
                 extending an existing compiler and by rewriting several
                 programs to make use of our proposed language
                 constructs, we found that the imposed declaration
                 clutter tends to be moderate; in particular, we found
                 that, for general applications of implicit invocation
                 with implicit announcement, fears that programs
                 utilizing our form of modularization become
                 unreasonably verbose are unjustified.",
  acknowledgement = ack-nhfb,
  articleno =    "1",
  keywords =     "aspect-oriented programming; event-driven programming;
                 Implicit invocation; modularity; publish/subscribe;
                 typing",
}

@Article{Sutherland:2010:CTC,
  author =       "Dean F. Sutherland and William L. Scherlis",
  title =        "Composable thread coloring",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "5",
  pages =        "233--244",
  month =        may,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1693453.1693485",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:39:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "This paper introduces the language-independent concept
                 of ``thread usage policy.'' Many multi-threaded
                 software systems contain policies that regulate
                 associations among threads, executable code, and
                 potentially shared state. A system, for example, may
                 constrain which threads are permitted to execute
                 particular code segments, usually as a means to
                 constrain those threads from accessing or writing
                 particular elements of state. These policies ensure
                 properties such as state confinement or reader/writer
                 constraints, often without recourse to locking or
                 transaction discipline.\par

                 Our approach allows developers to concisely document
                 their thread usage policies in a manner that enables
                 the use of sound scalable analysis to assess
                 consistency of policy and as-written code. This paper
                 identifies the key semantic concepts of our thread
                 coloring language and illustrates how to use its
                 succinct source-level annotations to express models of
                 thread usage policies, following established annotation
                 conventions for Java.\par

                 We have built a prototype static analysis tool,
                 implemented as an integrated development environment
                 plug-in (for the Eclipse IDE), that notifies developers
                 of discrepancies between policy annotations and
                 as-written code. Our analysis technique uses several
                 underlying algorithms based on abstract interpretation,
                 call-graphs, and type inference. The resulting overall
                 analysis is both sound and composable. We have used
                 this prototype analysis tool in case studies to model
                 and analyze more than a million lines of code.\par

                 Our validation process included field trials on a wide
                 variety of complex large-scale production code selected
                 by the host organizations. Our in-field experience led
                 us to focus on potential adoptability by real-world
                 developers. We have developed techniques that can
                 reduce annotation density to less than one line per
                 thousand lines of code (KLOC). In addition, the
                 prototype analysis tool supports an incremental and
                 iterative approach to modeling and analysis. This
                 approach enabled field trial partners to directly
                 target areas of greatest concern and to achieve useful
                 results within a few hours.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "annotation; Java; keywords: state consistency;
                 multicore; race conditions; state confinement; thread
                 policy",
}

@Article{Tatsubori:2010:EJT,
  author =       "Michiaki Tatsubori and Akihiko Tozawa and Toyotaro
                 Suzumura and Scott Trent and Tamiya Onodera",
  title =        "Evaluation of a just-in-time compiler retrofitted for
                 {PHP}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "7",
  pages =        "121--132",
  month =        jul,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1735997.1736015",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:01 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Programmers who develop Web applications often use
                 dynamic scripting languages such as Perl, PHP, Python,
                 and Ruby. For general purpose scripting language usage,
                 interpreter-based implementations are efficient and
                 popular but the server-side usage for Web application
                 development implies an opportunity to significantly
                 enhance Web server throughput. This paper summarizes a
                 study of the optimization of PHP script processing. We
                 developed a PHP processor, P9, by adapting an existing
                 production-quality just-in-time (JIT) compiler for a
                 Java virtual machine, for which optimization
                 technologies have been well-established, especially for
                 server-side application. This paper describes and
                 contrasts microbenchmarks and SPECweb2005 benchmark
                 results for a well-tuned configuration of a traditional
                 PHP interpreter and our JIT compiler-based
                 implementation, P9. Experimental results with the
                 microbenchmarks show 2.5-9.5x advantage with P9, and
                 the SPECweb2005 measurements show about 20-30\%
                 improvements. These results show that the acceleration
                 of dynamic scripting language processing does matter in
                 a realistic Web application server environment. CPU
                 usage profiling shows our simple JIT compiler
                 introduction reduces the PHP core runtime overhead from
                 45\% to 13\% for a SPECweb2005 scenario, implying that
                 further improvements of dynamic compilers would provide
                 little additional return unless other major overheads
                 such as heavy memory copy between the language runtime
                 and Web server frontend are reduced.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "dynamic scripting languages; just-in-time compiler;
                 php",
}

@Article{Teng:2010:TPA,
  author =       "Q. M. Teng and H. C. Wang and Z. Xiao and P. F.
                 Sweeney and E. Duesterwald",
  title =        "{THOR}: {A} performance analysis tool for {Java}
                 applications running on multicore systems",
  journal =      j-IBM-JRD,
  volume =       "54",
  number =       "5",
  pages =        "4:1--4:17",
  month =        "????",
  year =         "2010",
  CODEN =        "IBMJAE",
  DOI =          "http://dx.doi.org/10.1147/JRD.2010.2058481",
  ISSN =         "0018-8646",
  bibdate =      "Sun Feb 20 14:29:19 MST 2011",
  bibsource =    "http://www.research.ibm.com/journal/",
  acknowledgement = ack-nhfb,
}

@Article{Titzer:2010:ICR,
  author =       "Ben L. Titzer and Thomas W{\"u}rthinger and Doug Simon
                 and Marcelo Cintra",
  title =        "Improving compiler-runtime separation with {XIR}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "7",
  pages =        "39--50",
  month =        jul,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837854.1736005",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:01 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Intense research on virtual machines has highlighted
                 the need for flexible software architectures that allow
                 quick evaluation of new design and implementation
                 techniques. The interface between the compiler and
                 runtime system is a principal factor in the flexibility
                 of both components and is critical to enabling rapid
                 pursuit of new optimizations and features. Although
                 many virtual machines have demonstrated modularity for
                 many components, significant dependencies often remain
                 between the compiler and the runtime system components
                 such as the object model and memory management system.
                 This paper addresses this challenge with a carefully
                 designed strict compiler-runtime interface and the XIR
                 language. Instead of the compiler backend lowering
                 object operations to machine operations using
                 hard-wired runtime-specific logic, XIR allows the
                 runtime system to implement this logic, simultaneously
                 simplifying and separating the backend from
                 runtime-system details. In this paper we describe the
                 design and implementation of this compiler-runtime
                 interface and the XIR language in the C1X dynamic
                 compiler, a port of the HotSpotTM Client compiler. Our
                 results show a significant reduction in backend
                 complexity with XIR and an overall reduction in the
                 compiler-runtime interface complexity while still
                 generating comparable quality code with only minor
                 impact on compilation time.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "compilers; intermediate representations; java; JIT;
                 lowering; object model; register allocation; runtime
                 interface; software architecture; virtual machines",
}

@Article{Torlak:2010:MCA,
  author =       "Emina Torlak and Mandana Vaziri and Julian Dolby",
  title =        "{MemSAT}: checking axiomatic specifications of memory
                 models",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "341--350",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806635",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Memory models are hard to reason about due to their
                 complexity, which stems from the need to strike a
                 balance between ease-of-programming and allowing
                 compiler and hardware optimizations. In this paper, we
                 present an automated tool, MemSAT, that helps in
                 debugging and reasoning about memory models. Given an
                 axiomatic specification of a memory model and a
                 multi-threaded test program containing assertions,
                 MemSAT outputs a trace of the program in which both the
                 assertions and the memory model axioms are satisfied,
                 if one can be found. The tool is fully automatic and is
                 based on a SAT solver. If it cannot find a trace, it
                 outputs a minimal subset of the memory model and
                 program constraints that are unsatisfiable. We used
                 MemSAT to check several existing memory models against
                 their published test cases, including the current Java
                 Memory Model by Manson et al. and a revised version of
                 it by Sevcik and Aspinall. We found subtle
                 discrepancies between what was expected and the actual
                 results of test programs.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "axiomatic specifications; bounded model checking;
                 memory models; sat",
}

@Article{Ugawa:2010:IRB,
  author =       "Tomoharu Ugawa and Hideya Iwasaki and Taiichi Yuasa",
  title =        "Improved replication-based incremental garbage
                 collection for embedded systems",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "73--82",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806651.1806664",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "We have developed an incremental compacting garbage
                 collector for embedded Java systems. The collector
                 divides the heap into equal sized pages and uses the
                 segregated free lists for fast allocation. Collectors
                 that have such a heap layout have a problem of
                 fragmentation in allocating objects larger than the
                 page size. We solve this problem by using the
                 replication-based incremental compaction. The compactor
                 evacuates all objects in one area, the evacuation area,
                 of the heap, thereby creating a large chunk of free
                 space. We developed an algorithm for choosing the
                 evacuation area that effectively cures fragmentation.
                 The compactor does not use any read-barriers. Instead,
                 it uses a technique similar to the replication-based
                 incremental copying collection. This needs forwarding
                 pointers for all evacuated objects. Rather than
                 introducing an extra field for each object, we use a
                 hash table to store forwarding pointers.\par

                 Evaluation of this garbage collector implemented in
                 Sun's J2ME Java Virtual Machine showed that all the
                 benchmarks used were able to run without memory
                 starvation using the heap sizes of only 151\%-286\% of
                 the maximum amount of live data plus 8 KB of the hash
                 table. Experiments on a desktop computer, though it is
                 not a platform for embedded systems, showed that the
                 maximum pause time was shorter than 200 &\#956;s, which
                 was comparable to that of our implementation of the
                 snapshot-at-the-beginning collector without compaction.
                 On an ARM processor, the runtime overhead was 1\%-16\%
                 with 8.0\% on average compared to the mark-sweep
                 collector.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "compaction; embedded systems; fragmentation; garbage
                 collection; real-time garbage collection",
}

@Article{Upadhyaya:2010:UDS,
  author =       "Gautam Upadhyaya and Samuel P. Midkiff and Vijay S.
                 Pai",
  title =        "Using data structure knowledge for efficient lock
                 generation and strong atomicity",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "5",
  pages =        "281--292",
  month =        may,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1693453.1693490",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:39:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "To achieve high-performance on multicore systems,
                 sharedmemory parallel languages must efficiently
                 implement atomic operations. The commonly used and
                 studied paradigms for atomicity are fine-grained
                 locking, which is both difficult to program and
                 error-prone; optimistic software transactions, which
                 require substantial overhead to detect and recover from
                 atomicity violations; and compiler-generation of locks
                 from programmer-specified atomic sections, which leads
                 to serialization whenever imprecise pointer analysis
                 suggests the mere possibility of a conflicting
                 operation. This paper presents a new strategy for
                 compiler-generated locking that uses data structure
                 knowledge to facilitate more precise alias and lock
                 generation analyses and reduce unnecessary
                 serialization. Implementing and evaluating these ideas
                 in the Java language shows that the new strategy
                 achieves eight-thread speedups of 0.83 to 5.9 for the
                 five STAMP benchmarks studied, outperforming software
                 transactions on all but one benchmark, and nearly
                 matching programmer-specified fine-grained locks on all
                 but one benchmark. The results also indicate that
                 compiler knowledge of data structures improves the
                 effectiveness of compiler analysis, boosting
                 eight-thread performance by up to 300\%. Further, the
                 new analysis allows for software support of strong
                 atomicity with less than 1\% overhead for two
                 benchmarks and less than 20\% for three others. The
                 strategy also nearly matches the performance of
                 programmer-specified fine-grained locks for the
                 SPECjbb2000 benchmark, which has traditionally not been
                 amenable to static analyses.",
  acknowledgement = ack-nhfb,
  keywords =     "automatic lock generation; parallel programming;
                 transactional memory",
}

@Article{Vechev:2010:PPC,
  author =       "Martin Vechev and Eran Yahav and Greta Yorsh",
  title =        "{PHALANX}: parallel checking of expressive heap
                 assertions",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "8",
  pages =        "41--50",
  month =        aug,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1837855.1806658",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:55:48 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Unrestricted use of heap pointers makes software
                 systems difficult to understand and to debug. To
                 address this challenge, we developed PHALANX -- a
                 practical framework for dynamically checking expressive
                 heap properties such as ownership, sharing and
                 reachability. PHALANX uses novel parallel algorithms to
                 efficiently check a wide range of heap properties
                 utilizing the available cores.\par

                 PHALANX runtime is implemented on top of IBM's Java
                 production virtual machine. This has enabled us to
                 apply our new techniques to real world software. We
                 checked expressive heap properties in various scenarios
                 and found the runtime support to be valuable for
                 debugging and program understanding. Further, our
                 experimental results on DaCapo and other benchmarks
                 indicate that evaluating heap queries using parallel
                 algorithms can lead to significant performance
                 improvements, often resulting in linear speedups as the
                 number of cores increases.\par

                 To encourage adoption by programmers, we extended an
                 existing JML compiler to translate expressive JML
                 assertions about the heap into their efficient
                 implementation provided by PHALANX. To debug her
                 program, a programmer can annotate it with expressive
                 heap assertions in JML, that are efficiently checked by
                 PHALANX.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "ownership; parallel garbage collector; virtual
                 machine",
}

@Article{Villazon:2010:ARA,
  author =       "Alex Villaz{\'o}n and Walter Binder and Danilo
                 Ansaloni and Philippe Moret",
  title =        "Advanced runtime adaptation for {Java}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "85--94",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1621607.1621621",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Dynamic aspect-oriented programming (AOP) enables
                 runtime adaptation of aspects, which is important for
                 building sophisticated, aspect-based software
                 engineering tools, such as adaptive profilers or
                 debuggers that dynamically modify instrumentation code
                 in response to user interactions. Today, many AOP
                 frameworks for Java, notably AspectJ, focus on aspect
                 weaving at compile-time or at load-time, and offer only
                 limited support for aspect adaptation and reweaving at
                 runtime. In this paper, we introduce HotWave, an AOP
                 framework based on AspectJ for standard Java Virtual
                 Machines (JVMs). HotWave supports dynamic (re)weaving
                 of previously loaded classes, and it ensures that all
                 classes loaded in a JVM can be (re)woven, including the
                 classes of the standard Java class library. HotWave
                 features a novel mechanism for inter-advice
                 communication, enabling efficient data passing between
                 advices that are woven into the same method. We explain
                 HotWave's programming model and discuss our
                 implementation techniques. As case study, we present an
                 adaptive, aspect-based profiler that leverages
                 HotWave's distinguishing features.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "AspectJ; bytecode instrumentation; code hotswapping;
                 dynamic aspect-oriented programming; Java Virtual
                 Machine; runtime aspect adaptation and (re)weaving",
}

@Article{Villazon:2010:HCA,
  author =       "Alex Villaz{\'o}n and Walter Binder and Danilo
                 Ansaloni and Philippe Moret",
  title =        "{HotWave}: creating adaptive tools with dynamic
                 aspect-oriented programming in {Java}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "95--98",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1621607.1621622",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Developing tools for profiling, debugging, testing,
                 and reverse engineering is error-prone, time-consuming,
                 and therefore costly when using low-level techniques,
                 such as bytecode instrumentation. As a solution to
                 these problems, we promote tool development in Java
                 using high-level aspect-oriented programming (AOP). We
                 demonstrate that the use of aspects yields compact
                 tools that are easy to develop and extend. As enabling
                 technology, we rely on HotWave, a new tool for dynamic
                 and comprehensive aspect weaving. HotWave reconciles
                 compatibility with existing virtual machine and AOP
                 technologies. It provides support for runtime
                 adaptation of aspects and reweaving of previously
                 loaded code, as well as the ability to weave aspects
                 into all methods executing in a Java Virtual Machine,
                 including methods in the standard Java class library.
                 HotWave also features a new mechanism for efficiently
                 passing data between advices that are woven into the
                 same method. We demonstrate the benefits of HotWave's
                 distinguishing features with two case studies in the
                 area of profiling.",
  acknowledgement = ack-nhfb,
  keywords =     "AspectJ; bytecode instrumentation; code hotswapping;
                 dynamic aspect-oriented programming; Java Virtual
                 Machine; profiling; runtime weaving",
}

@Article{Wehr:2010:JBP,
  author =       "Stefan Wehr and Peter Thiemann",
  title =        "{JavaGI} in the battlefield: practical experience with
                 generalized interfaces",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "2",
  pages =        "65--74",
  month =        feb,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1621607.1621619",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue Aug 31 22:37:56 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Generalized interfaces are an extension of the
                 interface concept found in object-oriented languages
                 such as Java or C\#. The extension is inspired by
                 Haskell's type classes. It supports retroactive and
                 type-conditional interface implementations, binary
                 methods, symmetric multimethods, interfaces over
                 families of types, and static interface
                 methods.\par

                 This article reports practical experience with
                 generalized interfaces as implemented in the JavaGI
                 language. Several real-world case studies demonstrate
                 how generalized interfaces provide solutions to
                 extension and integration problems with components in
                 binary form, how they make certain design patterns
                 redundant, and how they eliminate various run-time
                 errors. In each case study, the use of JavaGI results
                 in elegant and highly readable code.\par

                 Furthermore, the article discusses the implementation
                 of a compiler and a run-time system for JavaGI.
                 Benchmarks show that our implementation offers
                 acceptable performance.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "case studies; external methods; JavaGI; multimethods;
                 retroactive interface implementation",
}

@Article{Wendykier:2010:PCH,
  author =       "Piotr Wendykier and James G. Nagy",
  title =        "{Parallel Colt}: {A} High-Performance {Java} Library
                 for Scientific Computing and Image Processing",
  journal =      j-TOMS,
  volume =       "37",
  number =       "3",
  pages =        "31:1--31:22",
  month =        sep,
  year =         "2010",
  CODEN =        "ACMSCU",
  DOI =          "http://doi.acm.org/10.1145/1824801.1824809",
  ISSN =         "0098-3500",
  bibdate =      "Mon Sep 27 10:15:50 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toms/",
  abstract =     "Major breakthroughs in chip and software design have
                 been observed for the last nine years. In October 2001,
                 IBM released the world's first multicore processor:
                 POWER4. Six years later, in February 2007, NVIDIA made
                 a public release of CUDA SDK, a set of development
                 tools to write algorithms for execution on Graphic
                 Processing Units (GPUs). Although software vendors have
                 started working on parallelizing their products, the
                 vast majority of existing code is still sequential and
                 does not effectively utilize modern multicore CPUs and
                 manycore GPUs.\par

                 This article describes Parallel Colt, a multithreaded
                 Java library for scientific computing and image
                 processing. In addition to describing the design and
                 functionality of Parallel Colt, a comparison to MATLAB
                 is presented. Two ImageJ plugins for iterative image
                 deblurring and motion correction of PET brain images
                 are described as typical applications of this library.
                 Performance comparisons with MATLAB, including GPU
                 computations via AccelerEyes' Jacket toolbox are also
                 given.",
  acknowledgement = ack-nhfb,
  articleno =    "31",
  keywords =     "Deconvolution; FFT; inverse problems; iterative
                 methods; motion correction; multithreading; PET;
                 regularization",
}

@Article{Westbrook:2010:MJM,
  author =       "Edwin Westbrook and Mathias Ricken and Jun Inoue and
                 Yilong Yao and Tamer Abdelatif and Walid Taha",
  title =        "{Mint}: {Java} multi-stage programming using weak
                 separability",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "400--411",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1809028.1806642",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Multi-stage programming (MSP) provides a disciplined
                 approach to run-time code generation. In the purely
                 functional setting, it has been shown how MSP can be
                 used to reduce the overhead of abstractions, allowing
                 clean, maintainable code without paying performance
                 penalties. Unfortunately, MSP is difficult to combine
                 with imperative features, which are prevalent in
                 mainstream languages. The central difficulty is scope
                 extrusion, wherein free variables can inadvertently be
                 moved outside the scopes of their binders. This paper
                 proposes a new approach to combining MSP with
                 imperative features that occupies a 'sweet spot' in the
                 design space in terms of how well useful MSP
                 applications can be expressed and how easy it is for
                 programmers to understand. The key insight is that
                 escapes (or 'anti-quotes') must be weakly separable
                 from the rest of the code, i.e. the computational
                 effects occurring inside an escape that are visible
                 outside the escape are guaranteed to not contain code.
                 To demonstrate the feasibility of this approach, we
                 formalize a type system based on Lightweight Java which
                 we prove sound, and we also provide an implementation,
                 called Mint, to validate both the expressivity of the
                 type system and the effect of staging on the
                 performance of Java programs.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "java; multi-staged languages; multi-stage programming;
                 type systems",
}

@Article{Wimmer:2010:AFD,
  author =       "Christian Wimmer and Hanspeter M{\"o}ssenb{\"o}sck",
  title =        "Automatic feedback-directed object fusing",
  journal =      j-TACO,
  volume =       "7",
  number =       "2",
  pages =        "7:1--7:??",
  month =        sep,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1839667.1839669",
  ISSN =         "1544-3566",
  bibdate =      "Sat Oct 2 18:05:46 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Object fusing is an optimization that embeds certain
                 referenced objects into their referencing object. The
                 order of objects on the heap is changed in such a way
                 that objects that are accessed together are placed next
                 to each other in memory. Their offset is then fixed,
                 that is, the objects are colocated, allowing field
                 loads to be replaced by address arithmetic. Array
                 fusing specifically optimizes arrays, which are
                 frequently used for the implementation of dynamic data
                 structures. Therefore, the length of arrays often
                 varies, and fields referencing such arrays have to be
                 changed. An efficient code pattern detects these
                 changes and allows the optimized access of such
                 fields.\par

                 We integrated these optimizations into Sun
                 Microsystems' Java HotSpot\TM{} VM. The analysis is
                 performed automatically at runtime, requires no actions
                 on the part of the programmer, and supports dynamic
                 class loading. To safely eliminate a field load, the
                 colocation of the object that holds the field and the
                 object that is referenced by the field must be
                 guaranteed. Two preconditions must be satisfied: The
                 objects must be allocated at the same time, and the
                 field must not be overwritten later. These
                 preconditions are checked by the just-in-time compiler
                 to avoid an interprocedural data flow analysis. The
                 garbage collector ensures that groups of colocated
                 objects are not split by copying groups as a whole. The
                 evaluation shows that the dynamic approach successfully
                 identifies and optimizes frequently accessed fields for
                 several benchmarks with a low compilation and analysis
                 overhead. It leads to a speedup of up to 76\% for
                 simple benchmarks and up to 6\% for complex
                 workloads.",
  acknowledgement = ack-nhfb,
  articleno =    "7",
  fjournal =     "ACM Transactions on Architecture and Code Optimization
                 (TACO)",
  keywords =     "cache performance; garbage collection; Java;
                 just-in-time compilation; object colocation; object
                 fusing; object inlining; optimization",
}

@Article{Witman:2010:TBR,
  author =       "Paul D. Witman and Terry Ryan",
  title =        "Think big for reuse",
  journal =      j-CACM,
  volume =       "53",
  number =       "1",
  pages =        "142--147",
  month =        jan,
  year =         "2010",
  CODEN =        "CACMA2",
  DOI =          "http://doi.acm.org/10.1145/1629175.1629209",
  ISSN =         "0001-0782",
  bibdate =      "Thu Feb 4 17:12:32 MST 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/cacm/",
  abstract =     "Many organizations are successful with software reuse
                 at fine to medium granularities -- ranging from
                 objects, subroutines, and components through software
                 product lines. However, relatively little has been
                 published on very large-grained reuse. One example of
                 this type of large-grained reuse might be that of an
                 entire Internet banking system (applications and
                 infrastructure) reused in business units all over the
                 world. In contrast, 'large scale' software reuse in
                 current research generally refers to systems that reuse
                 a large number of smaller components, or that perhaps
                 reuse subsystems. In this article, we explore a case of
                 an organization with an internal development group that
                 has been very successful with large-grained software
                 reuse.\par

                 BigFinancial, and the BigFinancial Technology Center
                 (BTC) in particular, have created a number of software
                 systems that have been reused in multiple businesses
                 and in multiple countries. BigFinancial and BTC thus
                 provided a rich source of data for case studies to look
                 at the characteristics of those projects and why they
                 have been successful, as well as to look at projects
                 that have been less successful and to understand what
                 has caused those results and what might be done
                 differently to prevent issues in the future. The
                 research is focused on technology, process, and
                 organizational elements of the development process,
                 rather than on specific product features and
                 functions.\par

                 Supporting reuse at a large-grained level may help to
                 alleviate some of the issues that occur in more
                 traditional reuse programs, which tend to be
                 finer-grained. In particular, because BigFinancial was
                 trying to gain commonality in business processes and
                 operating models, reuse of large-grained components was
                 more closely aligned with its business goals. This same
                 effect may well not have happened with finer-grained
                 reuse, due to the continued ability of business units
                 to more readily pick and choose components for
                 reuse.\par

                 BTC is a technology development unit of BigFinancial,
                 with operations in both the eastern and western US.
                 Approximately 500 people are employed by BTC, reporting
                 ultimately through a single line manager responsible to
                 the Global Retail Business unit head of BigFinancial.
                 BTC is organized to deliver both products and
                 infrastructure components to BigFinancial, and its
                 product line has through the years included consumer
                 Internet banking services, teller systems, ATM
                 software, and network management tools. BigFinancial
                 has its U.S. operations headquartered in the eastern
                 U.S., and employs more than 8,000 technologists
                 worldwide.\par

                 In cooperation with BTC, we selected three cases for
                 further study from a pool of about 25. These cases were
                 the Java Banking Toolkit (JBT) and its related
                 application systems, the Worldwide Single Signon (WSSO)
                 subsystem, and the BigFinancial Message Switch (BMS).",
  acknowledgement = ack-nhfb,
}

@Article{Xu:2010:DIU,
  author =       "Guoqing Xu and Atanas Rountev",
  title =        "Detecting inefficiently-used containers to avoid
                 bloat",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "160--173",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806616",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Runtime bloat degrades significantly the performance
                 and scalability of software systems. An important
                 source of bloat is the inefficient use of containers.
                 It is expensive to create inefficiently-used containers
                 and to invoke their associated methods, as this may
                 ultimately execute large volumes of code, with call
                 stacks dozens deep, and allocate many temporary
                 objects.\par

                 This paper presents practical static and dynamic tools
                 that can find inappropriate use of containers in Java
                 programs. At the core of these tools is a base static
                 analysis that identifies, for each container, the
                 objects that are added to this container and the key
                 statements (i.e., heap loads and stores) that achieve
                 the semantics of common container operations such as
                 {\em ADD\/} and {\em GET}. The static tool finds
                 problematic uses of containers by considering the
                 nesting relationships among the loops where these {\em
                 semantics-achieving statements\/} are located, while
                 the dynamic tool can instrument these statements and
                 find inefficiencies by profiling their execution
                 frequencies.\par

                 The high precision of the base analysis is achieved by
                 taking advantage of a context-free language
                 (CFL)-reachability formulation of points-to analysis
                 and by accounting for container-specific properties. It
                 is demand-driven and client-driven, facilitating
                 refinement specific to each queried container object
                 and increasing scalability. The tools built with the
                 help of this analysis can be used both to avoid the
                 creation of container-related performance problems
                 early during development, and to help with diagnosis
                 when problems are observed during tuning. Our
                 experimental results show that the static tool has a
                 low false positive rate and produces more relevant
                 information than its dynamic counterpart. Further case
                 studies suggest that significant optimization
                 opportunities can be found by focusing on
                 statically-identified containers for which high
                 allocation frequency is observed at run time.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "cfl reachability; container bloat; points-to
                 analysis",
}

@Article{Xu:2010:FLU,
  author =       "Guoqing Xu and Nick Mitchell and Matthew Arnold and
                 Atanas Rountev and Edith Schonberg and Gary Sevitsky",
  title =        "Finding low-utility data structures",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "6",
  pages =        "174--186",
  month =        jun,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://doi.acm.org/10.1145/1806596.1806617",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Fri Oct 8 17:53:18 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Many opportunities for easy, big-win, program
                 optimizations are missed by compilers. This is
                 especially true in highly layered Java applications.
                 Often at the heart of these missed optimization
                 opportunities lie computations that, with great
                 expense, produce data values that have little impact on
                 the program's final output. Constructing a new date
                 formatter to format every date, or populating a large
                 set full of expensively constructed structures only to
                 check its size: these involve costs that are out of
                 line with the benefits gained. This disparity between
                 the formation costs and accrued benefits of data
                 structures is at the heart of much runtime
                 bloat.\par

                 We introduce a run-time analysis to discover these {\em
                 low-utility\/} data structures. The analysis employs
                 dynamic thin slicing, which naturally associates costs
                 with value flows rather than raw data flows. It
                 constructs a model of the incremental, hop-to-hop,
                 costs and benefits of each data structure. The analysis
                 then identifies suspicious structures based on
                 imbalances of its incremental costs and benefits. To
                 decrease the memory requirements of slicing, we
                 introduce {\em abstract dynamic thin slicing}, which
                 performs thin slicing over bounded abstract domains. We
                 have modified the IBM J9 commercial JVM to implement
                 this approach.\par

                 We demonstrate two client analyses: one that finds
                 objects that are expensive to construct but are not
                 necessary for the forward execution, and second that
                 pinpoints ultimately-dead values. We have successfully
                 applied them to large-scale and long-running Java
                 applications. We show that these analyses are effective
                 at detecting operations that have unbalanced costs and
                 benefits.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  keywords =     "abstract dynamic thin slicing; cost benefit analysis;
                 memory bloat",
}

@Article{Yahav:2010:VSP,
  author =       "Eran Yahav and Mooly Sagiv",
  title =        "Verifying safety properties of concurrent
                 heap-manipulating programs",
  journal =      j-TOPLAS,
  volume =       "32",
  number =       "5",
  pages =        "18:1--18:50",
  month =        may,
  year =         "2010",
  CODEN =        "ATPSDT",
  DOI =          "http://doi.acm.org/10.1145/1745312.1745315",
  ISSN =         "0164-0925",
  bibdate =      "Fri May 21 12:28:30 MDT 2010",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "We provide a parametric framework for verifying safety
                 properties of concurrent heap-manipulating programs.
                 The framework combines thread-scheduling information
                 with information about the shape of the heap. This
                 leads to verification algorithms that are more precise
                 than existing techniques. The framework also provides a
                 precise shape-analysis algorithm for concurrent
                 programs. In contrast to most existing verification
                 techniques, we do not put a bound on the number of
                 allocated objects. The framework produces interesting
                 results even when analyzing programs with an unbounded
                 number of threads. The framework is applied to
                 successfully verify the following properties of a
                 concurrent program:\par

                 --- Concurrent manipulation of linked-list based ADT
                 preserves the ADT datatype invariant.\par

                 --- The program does not perform inconsistent updates
                 due to interference.\par

                 --- The program does not reach a deadlock.\par

                 --- The program does not produce runtime errors due to
                 illegal thread interactions.\par

                 We also found bugs in erroneous programs violating such
                 properties. A prototype of our framework has been
                 implemented and applied to small, but interesting,
                 example programs.",
  acknowledgement = ack-nhfb,
  articleno =    "18",
  keywords =     "Abstract interpretation; concurrency; Java; safety
                 properties; shape-analysis; verification",
}

@Book{Zakas:2010:HPJ,
  author =       "Nicholas C. Zakas",
  title =        "High performance {JavaScript}",
  publisher =    pub-ORA,
  address =      pub-ORA:adr,
  pages =        "xviii + 209",
  year =         "2010",
  ISBN =         "0-596-80279-x, 1-4493-8230-4",
  ISBN-13 =      "978-0-596-80279-0, 978-1-4493-8230-8",
  LCCN =         "????",
  bibdate =      "Wed Apr 27 11:14:30 MDT 2011",
  bibsource =    "z3950.bibsys.no:2100/BIBSYS",
  acknowledgement = ack-nhfb,
  subject =      "Web servers; World Wide Web; JavaScript (Computer
                 program language); Document Object Model (Web site
                 development technology)",
}

@Article{Zerzelidis:2010:FFS,
  author =       "Alexandros Zerzelidis and Andy Wellings",
  title =        "A framework for flexible scheduling in the {RTSJ}",
  journal =      j-TECS,
  volume =       "10",
  number =       "1",
  pages =        "3:1--3:??",
  month =        aug,
  year =         "2010",
  CODEN =        "????",
  DOI =          "http://doi.acm.org/10.1145/1814539.1814542",
  ISSN =         "1539-9087",
  bibdate =      "Mon Aug 30 15:29:45 MDT 2010",
  bibsource =    "http://portal.acm.org/",
  abstract =     "This article presents a viable solution to introducing
                 flexible scheduling in the Real-Time specification for
                 Java (RTSJ), in the form of a flexible scheduling
                 framework. The framework allows the concurrent use of
                 multiple application-defined scheduling policies, each
                 scheduling a subset of the total set of threads.
                 Moreover, all threads, regardless of the policy under
                 which they are scheduled, are permitted to share common
                 resources. Thus, the framework can accommodate a
                 variety of interworking applications (soft, firm, and
                 hard) running under the RTSJ. The proposed approach is
                 a two-level scheduling framework, where the first level
                 is the RTSJ priority scheduler and the second level is
                 under application control. This article describes the
                 framework's protocol, examines the different types of
                 scheduling policies that can be supported, and
                 evaluates the proposed framework by measuring its
                 execution cost. A description of an application-defined
                 Earliest-Deadline-First (EDF) scheduler illustrates how
                 the interface can be used. Minimum backward-compatible
                 changes to the RTSJ specification are discussed to
                 motivate the required interface. The only assumptions
                 made about the underlying real-time operating system is
                 that it supports preemptive priority-based dispatching
                 of threads and that changes to priorities have
                 immediate effect.",
  acknowledgement = ack-nhfb,
  articleno =    "3",
  keywords =     "flexible scheduling; RTSJ; Scheduling framework",
}

@Article{Zibin:2010:OIG,
  author =       "Yoav Zibin and Alex Potanin and Paley Li and Mahmood
                 Ali and Michael D. Ernst",
  title =        "Ownership and immutability in generic {Java}",
  journal =      j-SIGPLAN,
  volume =       "45",
  number =       "10",
  pages =        "598--617",
  month =        oct,
  year =         "2010",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1932682.1869509",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Wed Jan 26 15:13:46 MST 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Aiello:2011:JBA,
  author =       "Francesco Aiello and Giancarlo Fortino and Raffaele
                 Gravina and Antonio Guerrieri",
  title =        "A {Java}-Based Agent Platform for Programming Wireless
                 Sensor Networks",
  journal =      j-COMP-J,
  volume =       "54",
  number =       "3",
  pages =        "439--454",
  month =        mar,
  year =         "2011",
  CODEN =        "CMPJA6",
  DOI =          "http://dx.doi.org/10.1093/comjnl/bxq019",
  ISSN =         "0010-4620 (print), 1460-2067 (electronic)",
  ISSN-L =       "0010-4620",
  bibdate =      "Fri Feb 25 15:49:03 MST 2011",
  bibsource =    "http://comjnl.oxfordjournals.org/content/54/3.toc",
  URL =          "http://comjnl.oxfordjournals.org/content/54/3/439.full.pdf+html",
  acknowledgement = ack-nhfb,
  fjournal =     "Computer Journal",
  onlinedate =   "February 22, 2010",
}

@Article{Arnold:2011:AOJ,
  author =       "Matthew Arnold and Stephen Fink and David Grove and
                 Michael Hind and Peter F. Sweeney",
  title =        "Adaptive optimization in the {Jalapeno JVM}",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "4",
  pages =        "65--83",
  month =        apr,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1988042.1988048",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue May 24 10:55:07 MDT 2011",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Future high-performance virtual machines will improve
                 performance through sophisticated online
                 feedback-directed optimizations. This paper presents
                 the architecture of the Jalapeno Adaptive Optimization
                 System, a system to support leading-edge virtual
                 machine technology and enable ongoing research on
                 online feedback-directed optimizations. We describe the
                 extensible system architecture, based on a federation
                 of threads with asynchronous communication. We present
                 an implementation of the general architecture that
                 supports adaptive multi-level optimization based purely
                 on statistical sampling. We empirically demonstrate
                 that this profiling technique has low overhead and can
                 improve startup and steady-state performance, even
                 without the presence of online feedback-directed
                 optimizations. The paper also describes and evaluates
                 an online feedback-directed inlining optimization based
                 on statistical edge sampling.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Bala:2011:DTD,
  author =       "Vasanth Bala and Evelyn Duesterwald and Sanjeev
                 Banerjia",
  title =        "{Dynamo}: a transparent dynamic optimization system",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "4",
  pages =        "41--52",
  month =        apr,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1988042.1988044",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue May 24 10:55:07 MDT 2011",
  bibsource =    "http://portal.acm.org/",
  abstract =     "We describe the design and implementation of Dynamo, a
                 software dynamic optimization system that is capable of
                 transparently improving the performance of a native
                 instruction stream as it executes on the processor. The
                 input native instruction stream to Dynamo can be
                 dynamically generated (by a JIT for example), or it can
                 come from the execution of a statically compiled native
                 binary. This paper evaluates the Dynamo system in the
                 latter, more challenging situation, in order to
                 emphasize the limits, rather than the potential, of the
                 system. Our experiments demonstrate that even
                 statically optimized native binaries can be accelerated
                 Dynamo, and often by a significant degree.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Borstler:2011:QEI,
  author =       "J{\"u}rgen B{\"o}rstler and Marie Nordstr{\"o}m and
                 James H. Paterson",
  title =        "On the Quality of Examples in Introductory Java
                 Textbooks",
  journal =      j-TOCE,
  volume =       "11",
  number =       "1",
  pages =        "3:1--3:??",
  month =        feb,
  year =         "2011",
  CODEN =        "????",
  ISSN =         "1946-6226",
  bibdate =      "Mon Feb 28 16:08:34 MST 2011",
  bibsource =    "http://www.acm.org/pubs/toce",
  abstract =     "Example programs play an important role in the
                 teaching and learning of programming. Students as well
                 as teachers rank examples as the most important
                 resources for learning to program. Example programs
                 work as role models and must therefore always be
                 consistent with the principles and rules we are
                 teaching. However, it is difficult to find or develop
                 examples that are fully faithful to all principles and
                 guidelines of the object-oriented paradigm and also
                 follow general pedagogical principles and practices.
                 Unless students are able to engage with good examples,
                 they will not be able to tell desirable from
                 undesirable properties in their own and others'
                 programs.",
  acknowledgement = ack-nhfb,
  articleno =    "3",
  fjournal =     "ACM Transactions on Computing Education",
}

@Book{Cecco:2011:SJG,
  author =       "Raffaele Cecco",
  title =        "Supercharged {JavaScript} Graphics",
  publisher =    pub-ORA,
  address =      pub-ORA:adr,
  pages =        "400 (est.)",
  year =         "2011",
  ISBN =         "1-4493-9363-2",
  ISBN-13 =      "978-1-4493-9363-2",
  LCCN =         "????",
  bibdate =      "Wed Apr 27 10:01:59 2011",
  acknowledgement = ack-nhfb,
}

@Article{Deitcher:2011:SPJ,
  author =       "Avi Deitcher",
  title =        "Simplicity and performance: {JavaScript} on the
                 server",
  journal =      j-LINUX-J,
  volume =       "2011",
  number =       "204",
  pages =        "3:1--3:??",
  month =        apr,
  year =         "2011",
  CODEN =        "LIJOFX",
  ISSN =         "1075-3583 (print), 1938-3827 (electronic)",
  ISSN-L =       "1075-3583",
  bibdate =      "Fri May 13 12:05:08 MDT 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  articleno =    "3",
  fjournal =     "Linux Journal",
}

@Article{Duarte:2011:ICS,
  author =       "Rafael Duarte and Alexandre Mota and Augusto
                 Sampaio",
  title =        "Introducing concurrency in sequential {Java} via
                 laws",
  journal =      j-INFO-PROC-LETT,
  volume =       "111",
  number =       "3",
  pages =        "129--134",
  day =          "1",
  month =        jan,
  year =         "2011",
  CODEN =        "IFPLAT",
  ISSN =         "0020-0190 (print), 1872-6119 (electronic)",
  ISSN-L =       "0020-0190",
  bibdate =      "Thu Mar 31 12:46:53 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/00200190",
  acknowledgement = ack-nhfb,
  fjournal =     "Information Processing Letters",
}

@Article{Esquembre:2011:TPL,
  author =       "Francisco Esquembre",
  title =        "There Is Parallel Life for {Java} Scientific
                 Programmers!",
  journal =      j-COMPUT-SCI-ENG,
  volume =       "13",
  number =       "4",
  pages =        "6--10",
  month =        jul # "\slash " # aug,
  year =         "2011",
  CODEN =        "CSENFA",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MCSE.2011.72",
  ISSN =         "1521-9615 (print), 1558-366X (electronic)",
  ISSN-L =       "1521-9615",
  bibdate =      "Fri Jul 22 06:47:06 2011",
  acknowledgement = ack-nhfb,
  fjournal =     "Computing in Science and Engineering",
}

@Article{Gampe:2011:SMB,
  author =       "Andreas Gampe and Jeffery von Ronne and David
                 Niedzielski and Jonathan Vasek and Kleanthis Psarris",
  title =        "Safe, multiphase bounds check elimination in {Java}",
  journal =      j-SPE,
  volume =       "41",
  number =       "7",
  pages =        "753--788",
  month =        jun,
  year =         "2011",
  CODEN =        "SPEXBL",
  DOI =          "http://dx.doi.org/10.1002/spe.1028",
  ISSN =         "0038-0644",
  bibdate =      "Tue Jun 21 17:09:57 MDT 2011",
  acknowledgement = ack-nhfb,
  onlinedate =   "25 Nov 2010",
}

@Article{Giacaman:2011:OOP,
  author =       "Nasser Giacaman and Oliver Sinnen",
  title =        "Object-Oriented Parallelisation of {Java} Desktop
                 Programs",
  journal =      j-IEEE-SOFTWARE,
  volume =       "28",
  number =       "1",
  pages =        "32--38",
  month =        jan # "\slash " # feb,
  year =         "2011",
  CODEN =        "IESOEG",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MS.2010.135",
  ISSN =         "0740-7459 (print), 0740-7459 (electronic)",
  ISSN-L =       "0740-7459",
  bibdate =      "Thu Dec 23 16:29:15 2010",
  acknowledgement = ack-nhfb,
  fjournal =     "IEEE Software",
}

@Article{Grech:2011:JGE,
  author =       "Neville Grech and Julian Rathke and Bernd Fischer",
  title =        "{JEqualityGen}: generating equality and hashing
                 methods",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "2",
  pages =        "177--186",
  month =        feb,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1942788.1868320",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Mon Feb 14 16:37:34 MST 2011",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Manually implementing equals (for object comparisons)
                 and hashCode (for object hashing) methods in large
                 software projects is tedious and error-prone. This is
                 due to many special cases, such as field shadowing,
                 comparison between different types, or cyclic object
                 graphs. Here, we present JEqualityGen, a source code
                 generator that automatically derives implementations of
                 these methods. JEqualityGen proceeds in two states: it
                 first uses source code reflection in MetaAspectJ to
                 generate aspects that contain the method
                 implementations, before it uses weaving on the bytecode
                 level to insert these into the target application.
                 JEqualityGen generates not only correct, but efficient
                 source code that on a typical large-scale Java
                 application exhibits a performance improvement of more
                 than two orders of magnitude in the equality operations
                 generated, compared to an existing system based on
                 runtime reflection.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Haubl:2011:ECE,
  author =       "Christian H{\"a}ubl and Christian Wimmer and Hanspeter
                 M{\"o}ssenb{\"o}ck",
  title =        "Erratum to {``Compact and Efficient Strings for Java''
                 [Science of Computer Programming {\bf 75} (2010)
                 1077--1094]}",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "1073--1073",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Book{Haverbeke:2011:EJM,
  author =       "Marijn Haverbeke",
  title =        "Eloquent {JavaScript}: a modern introduction to
                 programming",
  publisher =    pub-NO-STARCH,
  address =      pub-NO-STARCH:adr,
  pages =        "xiv + 205",
  year =         "2011",
  ISBN =         "1-59327-282-0",
  ISBN-13 =      "978-1-59327-282-1",
  LCCN =         "QA76.73.J39 HAV 2011; QA76.73.J39 H38 2009",
  bibdate =      "Wed Apr 27 11:18:12 MDT 2011",
  bibsource =    "library.ox.ac.uk:210/ADVANCE",
  URL =          "http://www.loc.gov/catdir/enhancements/fy1012/2010032246-b.html;
                 http://www.loc.gov/catdir/enhancements/fy1012/2010032246-d.html;
                 http://www.loc.gov/catdir/enhancements/fy1107/2010032246-t.html",
  acknowledgement = ack-nhfb,
  subject =      "JavaScript (Computer program language)",
}

@Article{Hofmann:2011:EOS,
  author =       "Owen S. Hofmann and Alan M. Dunn and Sangman Kim and
                 Indrajit Roy and Emmett Witchel",
  title =        "Ensuring operating system kernel integrity with
                 {OSck}",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "3",
  pages =        "279--290",
  month =        mar,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1961296.1950398",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Tue May 24 10:55:08 MDT 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
  remark =       "ASPLOS '11 conference proceedings",
}

@Article{Horspool:2011:PPP,
  author =       "R. Nigel Horspool and Ralf Gitzel and Giacomo Cabri
                 and Markus Aleksy",
  title =        "Principles and Practice of Programming in {Java
                 2008}---Special issue",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "969--969",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Huang:2011:SBA,
  author =       "Gang Huang and Weihu Wang and Tiancheng Liu and Hong
                 Mei",
  title =        "Simulation-based analysis of middleware service impact
                 on system reliability: {Experiment} on {Java}
                 application server",
  journal =      j-J-SYST-SOFTW,
  volume =       "84",
  number =       "7",
  pages =        "1160--1170",
  month =        jul,
  year =         "2011",
  CODEN =        "JSSODM",
  ISSN =         "0164-1212",
  bibdate =      "Tue Jun 21 10:22:31 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01641212",
  acknowledgement = ack-nhfb,
  fjournal =     "Journal of Systems and Software",
}

@Book{Hughes-Croucher:2011:NRS,
  author =       "Tom Hughes-Croucher",
  title =        "Node: Up and Running : Scalable Server-Side Code with
                 {JavaScript}",
  publisher =    pub-ORA,
  address =      pub-ORA:adr,
  pages =        "????",
  year =         "2011",
  ISBN =         "1-4493-9858-8",
  ISBN-13 =      "978-1-4493-9858-3",
  LCCN =         "????",
  bibdate =      "Wed Apr 27 10:01:59 2011",
  acknowledgement = ack-nhfb,
}

@Article{Jovic:2011:LLP,
  author =       "Milan Jovic and Matthias Hauswirth",
  title =        "Listener latency profiling: {Measuring} the
                 perceptible performance of interactive {Java}
                 applications",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "1054--1072",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Kabanov:2011:DSF,
  author =       "Jevgeni Kabanov and Michael Hunger and Rein
                 Raudj{\"a}rv",
  title =        "On designing safe and flexible embedded {DSLs} with
                 {Java 5}",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "970--991",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Kalibera:2011:SRT,
  author =       "Tomas Kalibera and Filip Pizlo and Antony L. Hosking
                 and Jan Vitek",
  title =        "Scheduling real-time garbage collection on
                 uniprocessors",
  journal =      j-TOCS,
  volume =       "29",
  number =       "3",
  pages =        "8:1--8:??",
  month =        aug,
  year =         "2011",
  CODEN =        "ACSYEC",
  DOI =          "http://dx.doi.org/10.1145/2003690.2003692",
  ISSN =         "0734-2071",
  bibdate =      "Wed Aug 24 18:08:12 MDT 2011",
  bibsource =    "http://www.acm.org/pubs/contents/journals/tocs/",
  abstract =     "Managed languages such as Java and C{\SGMLnum} are
                 increasingly being considered for hard real-time
                 applications because of their productivity and software
                 engineering advantages. Automatic memory management, or
                 garbage collection, is a key enabler for robust,
                 reusable libraries, yet remains a challenge for
                 analysis and implementation of real-time execution
                 environments. This article comprehensively compares
                 leading approaches to hard real-time garbage
                 collection. There are many design decisions involved in
                 selecting a real-time garbage collection algorithm. For
                 time-based garbage collectors on uniprocessors one must
                 choose whether to use periodic, slack-based or hybrid
                 scheduling. A significant impediment to valid
                 experimental comparison of such choices is that
                 commercial implementations use completely different
                 proprietary infrastructures.",
  acknowledgement = ack-nhfb,
  articleno =    "8",
  fjournal =     "ACM Transactions on Computer Systems",
}

@Article{Kim:2011:MAE,
  author =       "Minseong Kim and Andy Wellings",
  title =        "Multiprocessors and Asynchronous Event Handling in the
                 Real-Time Specification for {Java}",
  journal =      j-COMP-J,
  volume =       "54",
  number =       "8",
  pages =        "1308--1324",
  month =        aug,
  year =         "2011",
  CODEN =        "CMPJA6",
  DOI =          "http://dx.doi.org/10.1093/comjnl/bxr030",
  ISSN =         "0010-4620 (print), 1460-2067 (electronic)",
  ISSN-L =       "0010-4620",
  bibdate =      "Wed Aug 17 16:34:11 MDT 2011",
  bibsource =    "http://comjnl.oxfordjournals.org/content/54/8.toc",
  URL =          "http://comjnl.oxfordjournals.org/content/54/8/1308.full.pdf+html",
  acknowledgement = ack-nhfb,
  fjournal =     "Computer Journal",
  onlinedate =   "March 26, 2011",
}

@Article{Krieger:2011:AES,
  author =       "Matthias P. Krieger and Alexander Knapp and Burkhart
                 Wolff",
  title =        "Automatic and efficient simulation of operation
                 contracts",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "2",
  pages =        "53--62",
  month =        feb,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1942788.1868303",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Mon Feb 14 16:37:34 MST 2011",
  bibsource =    "http://portal.acm.org/",
  abstract =     "Operation contracts consisting of pre- and
                 postconditions are a well-known means of specifying
                 operations. In this paper we deal with the problem of
                 operation contract simulation, i.e., determining
                 operation results satisfying the postconditions based
                 on input data supplied by the user; simulating
                 operation contracts is an important technique for
                 requirements validation and prototyping. Current
                 approaches to operation contract simulation exhibit
                 poor performance for large sets of input data or
                 require additional guidance from the user. We show how
                 these problems can be alleviated and describe an
                 efficient as well as fully automatic approach. It is
                 implemented in our tool OCLexec that generates from
                 UML/OCL operation contracts corresponding Java
                 implementations which call a constraint solver at
                 runtime.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Papadimitriou:2011:SES,
  author =       "Stergios Papadimitriou and Konstantinos Terzidis and
                 Seferina Mavroudi and Spiridon Likothanassis",
  title =        "{ScalaLab}: An Effective {Scala}-Based Scientific
                 Programming Environment for {Java}",
  journal =      j-COMPUT-SCI-ENG,
  volume =       "13",
  number =       "5",
  pages =        "43--55",
  month =        sep # "\slash " # oct,
  year =         "2011",
  CODEN =        "CSENFA",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MCSE.2010.77",
  ISSN =         "1521-9615 (print), 1558-366X (electronic)",
  ISSN-L =       "1521-9615",
  bibdate =      "Wed Aug 31 18:09:32 2011",
  acknowledgement = ack-nhfb,
  fjournal =     "Computing in Science and Engineering",
}

@Article{Park:2011:DCM,
  author =       "Heewan Park and Hyun-il Lim and Seokwoo Choi and
                 Taisook Han",
  title =        "Detecting Common Modules in {Java} Packages Based on
                 Static Object Trace Birthmark",
  journal =      j-COMP-J,
  volume =       "54",
  number =       "1",
  pages =        "108--124",
  month =        jan,
  year =         "2011",
  CODEN =        "CMPJA6",
  DOI =          "http://dx.doi.org/10.1093/comjnl/bxp095",
  ISSN =         "0010-4620 (print), 1460-2067 (electronic)",
  ISSN-L =       "0010-4620",
  bibdate =      "Tue Dec 21 19:26:47 MST 2010",
  bibsource =    "http://comjnl.oxfordjournals.org/content/54/1.toc",
  URL =          "http://comjnl.oxfordjournals.org/content/54/1/108.full.pdf+html",
  acknowledgement = ack-nhfb,
  fjournal =     "Computer Journal",
  onlinedate =   "November 5, 2009",
}

@Article{Ricci:2011:SAO,
  author =       "Alessandro Ricci and Mirko Viroli and Giulio
                 Piancastelli",
  title =        "{simpA} : {An} agent-oriented approach for programming
                 concurrent applications on top of {Java}",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "1",
  pages =        "37--62",
  day =          "1",
  month =        jan,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Fri Apr 1 18:39:40 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Tate:2011:TWJ,
  author =       "Ross Tate and Alan Leung and Sorin Lerner",
  title =        "Taming wildcards in {Java}'s type system",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "6",
  pages =        "614--627",
  month =        jun,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1993316.1993570",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Thu Jun 9 10:23:33 MDT 2011",
  bibsource =    "http://portal.acm.org/",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}

@Article{Toledo:2011:ACJ,
  author =       "Rodolfo Toledo and Eric Tanter",
  title =        "Access Control in {JavaScript}",
  journal =      j-IEEE-SOFTWARE,
  volume =       "28",
  number =       "5",
  pages =        "76--84",
  month =        sep # "\slash " # oct,
  year =         "2011",
  CODEN =        "IESOEG",
  DOI =          "http://doi.ieeecomputersociety.org/10.1109/MS.2010.154",
  ISSN =         "0740-7459 (print), 0740-7459 (electronic)",
  ISSN-L =       "0740-7459",
  bibdate =      "Wed Aug 31 17:16:45 2011",
  acknowledgement = ack-nhfb,
  fjournal =     "IEEE Software",
}

@Article{Villazon:2011:CAW,
  author =       "Alex Villaz{\'o}n and Walter Binder and Philippe Moret
                 and Danilo Ansaloni",
  title =        "Comprehensive aspect weaving for {Java}",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "1015--1036",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Wagner:2011:SJV,
  author =       "Gregor Wagner and Andreas Gal and Michael Franz",
  title =        "``Slimming'' a {Java} virtual machine by way of cold
                 code removal and optimistic partial program loading",
  journal =      j-SCI-COMPUT-PROGRAM,
  volume =       "76",
  number =       "11",
  pages =        "1037--1053",
  day =          "1",
  month =        nov,
  year =         "2011",
  CODEN =        "SCPGD4",
  ISSN =         "0167-6423",
  bibdate =      "Tue Jun 21 10:31:56 MDT 2011",
  bibsource =    "http://www.sciencedirect.com/science/journal/01676423",
  acknowledgement = ack-nhfb,
  fjournal =     "Science of Computer Programming",
}

@Article{Wang:2011:EEU,
  author =       "Alf Inge Wang",
  title =        "Extensive Evaluation of Using a Game Project in a
                 Software Architecture Course",
  journal =      j-TOCE,
  volume =       "11",
  number =       "1",
  pages =        "5:1--5:??",
  month =        feb,
  year =         "2011",
  CODEN =        "????",
  ISSN =         "1946-6226",
  bibdate =      "Mon Feb 28 16:08:34 MST 2011",
  bibsource =    "http://www.acm.org/pubs/toce",
  abstract =     "This article describes an extensive evaluation of
                 introducing a game project to a software architecture
                 course. In this project, university students have to
                 construct and design a type of software architecture,
                 evaluate the architecture, implement an application
                 based on the architecture, and test this
                 implementation. In previous years, the domain of the
                 software architecture project has been a robot
                 controller for navigating a maze. In 2008, the students
                 on the software architecture course chose between the
                 two domains: Khepera robot simulation in Java and XNA
                 game development in C#. Independent of the domain
                 chosen, the students had to go through the same phases,
                 produce the same documents based on the same templates,
                 and follow exactly the same process.",
  acknowledgement = ack-nhfb,
  articleno =    "5",
  fjournal =     "ACM Transactions on Computing Education",
}

@Article{Wehr:2011:JIT,
  author =       "Stefan Wehr and Peter Thiemann",
  title =        "{JavaGI}: The Interaction of Type Classes with
                 Interfaces and Inheritance",
  journal =      j-TOPLAS,
  volume =       "33",
  number =       "4",
  pages =        "12:1--12:83",
  month =        jul,
  year =         "2011",
  CODEN =        "ATPSDT",
  DOI =          "http://dx.doi.org/10.1145/1985342.1985343",
  ISSN =         "0164-0925",
  bibdate =      "Mon Jul 18 12:33:22 MDT 2011",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  abstract =     "The language JavaGI extends Java 1.5 conservatively by
                 a generalized interface mechanism. The generalization
                 subsumes retroactive and type-conditional interface
                 implementations, binary methods, symmetric multiple
                 dispatch, interfaces over families of types, and static
                 interface methods. These features make certain coding
                 patterns redundant, increase the expressiveness of the
                 type system, and permit solutions to extension and
                 integration problems with components in binary form,
                 for which previously several unrelated extensions had
                 been suggested. This article explains JavaGI and
                 motivates its design. Moreover, it formalizes a core
                 calculus for JavaGI and proves type soundness,
                 decidability of typechecking, and determinacy of
                 evaluation. The article also presents the
                 implementation of a JavaGI compiler and an accompanying
                 run-time system.",
  acknowledgement = ack-nhfb,
  articleno =    "12",
  fjournal =     "ACM Transactions on Programming Languages and
                 Systems",
}

@Article{Wurthinger:2011:AED,
  author =       "Thomas W{\"u}rthinger and Walter Binder and Danilo
                 Ansaloni and Philippe Moret and Hanspeter
                 M{\"o}ssenb{\"o}ck",
  title =        "Applications of enhanced dynamic code evolution for
                 {Java} in {GUI} development and dynamic aspect-oriented
                 programming",
  journal =      j-SIGPLAN,
  volume =       "46",
  number =       "2",
  pages =        "123--126",
  month =        feb,
  year =         "2011",
  CODEN =        "SINODQ",
  DOI =          "http://dx.doi.org/10.1145/1942788.1868312",
  ISSN =         "0362-1340 (print), 1523-2867 (print), 1558-1160 (electronic)",
  ISSN-L =       "0362-1340",
  bibdate =      "Mon Feb 14 16:37:34 MST 2011",
  bibsource =    "http://portal.acm.org/",
  abstract =     "While dynamic code evolution in object-oriented
                 systems is an important feature supported by dynamic
                 languages, there is currently only limited support for
                 dynamic code evolution in high-performance,
                 state-of-the-art runtime systems for statically typed
                 languages, such as the Java Virtual Machine. In this
                 tool demonstration, we present the Dynamic Code
                 Evolution VM, which is based on a recent version of
                 Oracle's state-of-the-art Java HotSpot(TM) VM and
                 allows unlimited changes to loaded classes at runtime.
                 Based on the Dynamic Code Evolution VM, we developed an
                 enhanced version of the Mantisse GUI builder (which is
                 part of the NetBeans IDE) that allows adding GUI
                 components without restarting the application under
                 development.",
  acknowledgement = ack-nhfb,
  fjournal =     "ACM SIGPLAN Notices",
}
