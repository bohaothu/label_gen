% This file was created with JabRef 2.5b.
% Encoding: UTF8

@ARTICLE{Bachman1973,
  author = {Bachman,, Charles W.},
  title = {The programmer as navigator},
  journal = {Commun. ACM},
  year = {1973},
  volume = {16},
  pages = {653--658},
  number = {11},
  abstract = {This year the whole world celebrates the five-hundredth birthday of
	Nicolaus Copernicus, the famous Polish astronomer and mathematician.
	In 1543, Copernicus published his book, Concerning the Revolutions
	of Celestial Spheres, which described a new theory about the relative
	physical movements of the earth, the planets, and the sun. It was
	in direct contradiction with the earth-centered theories which had
	been established by Ptolemy 1400 years earlier.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/355611.362534},
  file = {1973-Bachman1973.pdf:1973-Bachman1973.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1973}
}

@ARTICLE{Backus1978,
  author = {Backus,, John},
  title = {Can programming be liberated from the von Neumann style?: a functional
	style and its algebra of programs},
  journal = {Commun. ACM},
  year = {1978},
  volume = {21},
  pages = {613--641},
  number = {8},
  abstract = {Conventional programming languages are growing ever more enormous,
	but not stronger. Inherent defects at the most basic level cause
	them to be both fat and weak: their primitive word-at-a-time style
	of programming inherited from their common ancestor—the von Neumann
	computer, their close coupling of semantics to state transitions,
	their division of programming into a world of expressions and a world
	of statements, their inability to effectively use powerful combining
	forms for building new programs from existing ones, and their lack
	of useful mathematical properties for reasoning about programs. An
	alternative functional style of programming is founded on the use
	of combining forms for creating programs. Functional programs deal
	with structured data, are often nonrepetitive and nonrecursive, are
	hierarchically constructed, do not name their arguments, and do not
	require the complex machinery of procedure declarations to become
	generally applicable. Combining forms can use high level programs
	to build still higher level ones in a style not possible in conventional
	languages. Associated with the functional style of programming is
	an algebra of programs whose variables range over programs and whose
	operations are combining forms. This algebra can be used to transform
	programs and to solve equations whose “unknowns” are programs in
	much the same way one transforms equations in high school algebra.
	These transformations are given by algebraic laws and are carried
	out in the same language in which programs are written. Combining
	forms are chosen not only for their programming power but also for
	the power of their associated algebraic laws. General theorems of
	the algebra give the detailed behavior and termination conditions
	for large classes of programs.  A new class of computing systems
	uses the functional programming style both in its programming language
	and in its state transition rules. Unlike von Neumann languages,
	these systems have semantics loosely coupled to states—only one state
	transition occurs per major computation.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/359576.359579},
  file = {1977-Backus1978.pdf:1977-Backus1978.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1977}
}

@ARTICLE{Cocke1988,
  author = {Cocke,, John},
  title = {The search for performance in scientific processors: the Turing Award
	lecture},
  journal = {Commun. ACM},
  year = {1988},
  volume = {31},
  pages = {250--253},
  number = {3},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/42392.42394},
  file = {1987-Cocke1988.pdf:1987-Cocke1988.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1987}
}

@ARTICLE{Codd1982,
  author = {Codd,, E. F.},
  title = {Relational database: a practical foundation for productivity},
  journal = {Commun. ACM},
  year = {1982},
  volume = {25},
  pages = {109--117},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358396.358400},
  file = {1981-Codd1982.pdf:1981-Codd1982.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1981}
}

@ARTICLE{Cook1983,
  author = {Cook,, Stephen A.},
  title = {An overview of computational complexity},
  journal = {Commun. ACM},
  year = {1983},
  volume = {26},
  pages = {400--408},
  number = {6},
  abstract = {An historical overview of computational complexity is presented. Emphasis
	is on the fundamental issues of defining the intrinsic computational
	complexity of a problem and proving upper and lower bounds on the
	complexity of problems. Probabilistic and parallel computation are
	discussed.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358141.358144},
  file = {1982-Cook1983.pdf:1982-Cook1983.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1982}
}

@ARTICLE{Corbato1991,
  author = {Corbat\'{o},, Fernando J.},
  title = {On building systems that will fail},
  journal = {Commun. ACM},
  year = {1991},
  volume = {34},
  pages = {72--81},
  number = {9},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/114669.114686},
  file = {1990-Corbato1991.pdf:1990-Corbato1991.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1990}
}

@ARTICLE{Dijkstra1972,
  author = {Dijkstra,, Edsger W.},
  title = {The humble programmer},
  journal = {Commun. ACM},
  year = {1972},
  volume = {15},
  pages = {859--866},
  number = {10},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/355604.361591},
  file = {1972-Dijkstra1972.pdf:1972-Dijkstra1972.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1972}
}

@ARTICLE{Feigenbaum1996,
  author = {Feigenbaum,, Edward A.},
  title = {How the ``what'' becomes the ``how''},
  journal = {Commun. ACM},
  year = {1996},
  volume = {39},
  pages = {97--104},
  number = {5},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/229459.229471},
  file = {1994-Feigenbaum1996.pdf:1994-Feigenbaum1996.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1994}
}

@ARTICLE{Floyd1979,
  author = {Floyd,, Robert W.},
  title = {The paradigms of programming},
  journal = {Commun. ACM},
  year = {1979},
  volume = {22},
  pages = {455--460},
  number = {8},
  abstract = {Today I want to talk about the paradigms of programming, how they
	affect our success as designers of computer programs, how they should
	be taught, and how they should be embodied in our programming languages.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/359138.359140},
  file = {1978-Floyd1979.pdf:1978-Floyd1979.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1978}
}

@ARTICLE{Gray2000,
  author = {Jim Gray},
  title = {What Next? A Few Remaining Problems in Information Technlogy, SIGMOD
	Conference 1999, ACM Turing Award Lecture, Video},
  journal = {ACM SIGMOD Digital Symposium Collection},
  year = {2000},
  volume = {2},
  number = {2},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {db/conf/sigmod/Gray00.html},
  file = {1998-Gray2000.pdf:1998-Gray2000.pdf:PDF},
  owner = {solrex},
  timestamp = {1998}
}

@ARTICLE{Hamming1969,
  author = {Hamming,, R. W.},
  title = {One Man's View of Computer Science},
  journal = {J. ACM},
  year = {1969},
  volume = {16},
  pages = {3--12},
  number = {1},
  abstract = {A number of observations and comments are directed toward suggesting
	that more than the usual engineering flavor be given to computer
	science. The engineering aspect is important because most present
	difficulties in this field do not involve the theoretical question
	of whether certain things can be done, but rather the practical question
	of how can they be accomplished well and simply.
	
	
	The teaching of computer science could be made more effective by various
	alterations, for example, the inclusion of a laboratory course in
	programming, the requirement for a strong minor in something other
	thaa mathematics~ and more practical coding and less abstract theory,
	as well as more seriousness and less game playing.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/321495.321497},
  file = {1968-Hamming1969.pdf:1968-Hamming1969.pdf:PDF},
  issn = {0004-5411},
  keywords = {computer seience, computer engineering, practical programming, mathematical
	game-playing, computer technician, computer professional, true-to-life
	programming,
	
	computer science curriculum, software, basic research, undirected
	research, programmers, ethical standards, programmers' social responsibility},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1968}
}

@ARTICLE{Hartmanis1994,
  author = {Hartmanis,, Juris},
  title = {Turing Award lecture on computational complexity and the nature of
	computer science},
  journal = {Commun. ACM},
  year = {1994},
  volume = {37},
  pages = {37--43},
  number = {10},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/194313.214781},
  file = {1993-Hartmanis1994.pdf:1993-Hartmanis1994.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1993}
}

@ARTICLE{Hoare1981,
  author = {Hoare,, Charles Antony Richard},
  title = {The emperor's old clothes},
  journal = {Commun. ACM},
  year = {1981},
  volume = {24},
  pages = {75--83},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358549.358561},
  file = {1980-Hoare1981.pdf:1980-Hoare1981.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1980}
}

@ARTICLE{Hopcroft1987,
  author = {Hopcroft,, John E.},
  title = {Computer science: the emergence of a discipline},
  journal = {Commun. ACM},
  year = {1987},
  volume = {30},
  pages = {198--202},
  number = {3},
  abstract = {The continued rapid development of computer science will require an
	expansion of the science base and an influx of talented new researchers.
	Computers have already altered the way we think and live; now they
	will begin to elevate our knowledge of the world.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/214748.214750},
  file = {1986-Hopcroft1987.pdf:1986-Hopcroft1987.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1986}
}

@ARTICLE{Iverson1980,
  author = {Iverson,, Kenneth E.},
  title = {Notation as a tool of thought},
  journal = {Commun. ACM},
  year = {1980},
  volume = {23},
  pages = {444--465},
  number = {8},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358896.358899},
  file = {1979-Iverson1980.pdf:1979-Iverson1980.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1979}
}

@ARTICLE{Karp1986,
  author = {Karp,, Richard M.},
  title = {Combinatorics, complexity, and randomness},
  journal = {Commun. ACM},
  year = {1986},
  volume = {29},
  pages = {98--109},
  number = {2},
  abstract = {The 1985 Turing Award winner presents his perspective on the development
	of the field that has come to be called theoretical computer science.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/5657.5658},
  file = {1985-Karp1986.pdf:1985-Karp1986.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1985}
}

@ARTICLE{Knuth1974,
  author = {Knuth,, Donald E.},
  title = {Computer programming as an art},
  journal = {Commun. ACM},
  year = {1974},
  volume = {17},
  pages = {667--673},
  number = {12},
  abstract = {When Communications of the ACM began publication in 1959, the members
	of ACM's Editorial Board made the following remark as they described
	the purposes of ACM's periodicals [2]: “If computer programming is
	to become an important part of computer research and development,
	a transition of programming from an art to a disciplined science
	must be effected.” Such a goal has been a continually recurring theme
	during the ensuing years; for example, we read in 1970 of the “first
	steps toward transforming the art of programming into a science”
	[26]. Meanwhile we have actually succeeded in making our discipline
	a science, and in a remarkably simple way: merely by deciding to
	call it “computer science.”},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/361604.361612},
  file = {1974-Knuth1974.pdf:1974-Knuth1974.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1974}
}

@ARTICLE{McCarthy1987,
  author = {McCarthy,, John},
  title = {Generality in artificial intelligence},
  journal = {Commun. ACM},
  year = {1987},
  volume = {30},
  pages = {1030--1035},
  number = {12},
  abstract = {The Turing Award Lecture given in 1971 by John McCarthy was never
	published. The postscript that follows, written by the author in
	1986, endeavors to reflect the flavor of the original, as well as
	to comment in the light of development over the past 15 years.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/33447.33448},
  file = {1971-McCarthy1987.pdf:1971-McCarthy1987.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1971}
}

@ARTICLE{Milner1993,
  author = {Milner,, Robin},
  title = {Elements of interaction: Turing award lecture},
  journal = {Commun. ACM},
  year = {1993},
  volume = {36},
  pages = {78--89},
  number = {1},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/151233.151240},
  file = {1991-Milner1993.pdf:1991-Milner1993.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1991}
}

@ARTICLE{Minsky1970,
  author = {Minsky,, Marvin},
  title = {Form and Content in Computer Science (1970 ACM turing lecture)},
  journal = {J. ACM},
  year = {1970},
  volume = {17},
  pages = {197--215},
  number = {2},
  abstract = {An excessive preoccupation with formalism is impeding the development
	of computer science. Form-content confusion is discussed relative
	to three areas: theory of computation, programming languages, and
	education.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/321574.321575},
  file = {1969-Minsky1970.pdf:1969-Minsky1970.pdf:PDF},
  issn = {0004-5411},
  keywords = {education, programming languages, compilers, theory of programining,
	heuristics, primary education, computer science curriculum, self-extending
	languages, "new mathematics"},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1969}
}

@ARTICLE{Naur2007,
  author = {Naur,, Peter},
  title = {Computing versus human thinking},
  journal = {Commun. ACM},
  year = {2007},
  volume = {50},
  pages = {85--94},
  number = {1},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1188913.1188922},
  file = {2007-Naur2007.pdf:2007-Naur2007.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {2007}
}

@ARTICLE{Newell1976,
  author = {Newell,, Allen and Simon,, Herbert A.},
  title = {Computer science as empirical inquiry: symbols and search},
  journal = {Commun. ACM},
  year = {1976},
  volume = {19},
  pages = {113--126},
  number = {3},
  abstract = {Computer science is the study of the phenomena surrounding computers.
	The founders of this society understood this very well when they
	called themselves the Association for Computing Machinery. The machine—not
	just the hardware, but the programmed, living machine—is the organism
	we study.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/360018.360022},
  file = {1975-Newell1976.pdf:1975-Newell1976.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1975}
}

@INPROCEEDINGS{Perlis1966,
  author = {Perlis,, A. J.},
  title = {The synthesis of algorithmic systems},
  booktitle = {Proceedings of the 1966 21st national conference},
  year = {1966},
  pages = {1--6},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/800256.810673},
  file = {1966-Perlis1966.pdf:1966-Perlis1966.pdf:PDF},
  owner = {solrex},
  timestamp = {1966}
}

@ARTICLE{Rabin1977,
  author = {Rabin,, Michael O.},
  title = {Complexity of computations},
  journal = {Commun. ACM},
  year = {1977},
  volume = {20},
  pages = {625--633},
  number = {9},
  abstract = {The framework for research in the theory of complexity of computations
	is described, emphasizing the interrelation between seemingly diverse
	problems and methods. Illustrative examples of practical and theoretical
	significance are given. Directions for new research are discussed.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/359810.359816},
  file = {1976-Rabin1977.pdf:1976-Rabin1977.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1976}
}

@ARTICLE{Reddy1996,
  author = {Reddy,, Raj},
  title = {To dream the possible dream},
  journal = {Commun. ACM},
  year = {1996},
  volume = {39},
  pages = {105--112},
  number = {5},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/229459.233436},
  file = {1994-Reddy1996.pdf:1994-Reddy1996.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1994}
}

@ARTICLE{Ritchie1984,
  author = {Ritchie,, Dennis M.},
  title = {Reflections on software research},
  journal = {Commun. ACM},
  year = {1984},
  volume = {27},
  pages = {758--760},
  number = {8},
  abstract = {Can the circumstances that existed in Bell Labs that nurtured the
	UNIX project be produced again?},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358198.358207},
  file = {1983-Ritchie1984.pdf:1983-Ritchie1984.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1983}
}

@ARTICLE{Scott1977,
  author = {Scott,, Dana S.},
  title = {Logic and programming languages},
  journal = {Commun. ACM},
  year = {1977},
  volume = {20},
  pages = {634--641},
  number = {9},
  abstract = {Logic has been long interested in whether answers to certain questions
	are computable in principle, since the outcome puts bounds on the
	possibilities of formalization. More recently, precise comparisons
	in the efficiency of decision methods have become available through
	the developments in complexity theory. These, however, are applications
	to logic, and a big question is whether methods of logic have significance
	in the other direction for the more applied parts of computability
	theory. Programming languages offer an obvious opportunity as their
	syntactic formalization is well advanced; however, the semantical
	theory can hardly be said to be complete. Though we have many examples,
	we have still to give wide-ranging mathematical answers to these
	queries: What is a machine? What is a computable process? How (or
	how well) does a machine simulate a process? Programs naturally enter
	in giving descriptions of processes. The definition of the precise
	meaning of a program then requires us to explain what are the objects
	of computation (in a way, the statics of the problem) and how they
	are to be transformed (the dynamics). So far the theories of automata
	and of nets, though most interesting for dynamics, have formalized
	only a portion of the field, and there has been perhaps too much
	concentration on the finite-state and algebraic aspects. It would
	seem that the understanding of higher-level program features involves
	us with infinite objects and forces us to pass through several levels
	of explanation to go from the conceptual ideas to the final simulation
	on a real machine. These levels can be made mathematically exact
	if we can find the right abstractions to represent the necessary
	structures. The experience of many independent workers with the method
	of data types as lattices (or partial orderings) under an information
	content ordering, and with their continuous mappings, has demonstrated
	the flexibility of this approach in providing definitions and proofs,
	which are clean and without undue dependence on implementations.
	Nevertheless much remains to be done in showing how abstract conceptualizations
	can (or cannot) be actualized before we can say we have a unified
	theory.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/359810.359826},
  file = {1976-Scott1977.pdf:1976-Scott1977.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1976}
}

@ARTICLE{Stearns1994,
  author = {Stearns,, Richard Edwin},
  title = {Turing Award lecture: it's time to reconsider time},
  journal = {Commun. ACM},
  year = {1994},
  volume = {37},
  pages = {95--99},
  number = {11},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/188280.188379},
  file = {1993-Stearns1994.pdf:1993-Stearns1994.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1993}
}

@ARTICLE{Sutherland1989,
  author = {Sutherland,, I. E.},
  title = {Micropipelines},
  journal = {Commun. ACM},
  year = {1989},
  volume = {32},
  pages = {720--738},
  number = {6},
  abstract = {The pipeline processor is a common paradigm for very high speed computing
	machinery. Pipeline processors provide high speed because their separate
	stages can operate concurrently, much as different people on a manufacturing
	assembly line work concurrently on material passing down the line.
	Although the concurrency of pipeline processors makes their design
	a demanding task, they can be found in graphics processors, in signal
	processing devices, in integrated circuit components for doing arithmetic,
	and in the instruction interpretation units and arithmetic operations
	of general purpose computing machinery. Because I plan to describe
	a variety of pipeline processors, I will start by suggesting names
	for their various forms. Pipeline processors, or more simply just
	pipelines, operate on data as it passes along them. The latency of
	a pipeline is a measure of how long it takes a single data value
	to pass through it. The throughput rate of a pipeline is a measure
	of how many data values can pass through it per unit time. Pipelines
	both store and process data; the storage elements and processing
	logic in them alternate along their length. I will describe pipelines
	in their complete form later, but first I will focus on their storage
	elements alone, stripping away all processing logic. Stripped of
	all processing logic, any pipeline acts like a series of storage
	elements through which data can pass. Pipelines can be clocked or
	event-driven, depending on whether their parts act in response to
	some widely-distributed external clock, or act independently whenever
	local events permit. Some pipelines are inelastic; the amount of
	data in them is fixed. The input rate and the output rate of an inelastic
	pipeline must match exactly. Stripped of any processing logic, an
	inelastic pipeline acts like a shift register. Other pipelines are
	elastic; the amount of data in them may vary. The input rate and
	the output rate of an elastic pipeline may differ momentarily because
	of internal buffering. Stripped of all processing logic, an elastic
	pipeline becomes a flow-through first-in-first-out memory, or FIFO.
	FIFOs may be clocked or event-driven; their important property is
	that they are elastic. I assign the name micropipeline to a particularly
	simple form of event-driven elastic pipeline with or without internal
	processing. The micro part of this name seems appropriate to me because
	micropipelines contain very simple circuitry, because micropipelines
	are useful in very short lengths, and because micropipelines are
	suitable for layout in microelectronic form. I have chosen micropipelines
	as the subject of this lecture for three reasons. First, micropipelines
	are simple and easy to understand. I believe that simple ideas are
	best, and I find beauty in the simplicity and symmetry of micropipelines.
	Second, I see confusion surrounding the design of FIFOs. I offer
	this description of micropipelines in the hope of reducing some of
	that confusion. The third reason I have chosen my subject addresses
	the limitations imposed on us by the clocked-logic conceptual framework
	now commonly used in the design of digital systems. I believe that
	this conceptual framework or mind set masks simple and useful structures
	like micropipelines from our thoughts, structures that are easy to
	design and apply given a different conceptual framework. Because
	micropipelines are event-driven, their simplicity is not available
	within the clocked-logic conceptual framework. I offer this description
	of micropipelines in the hope of focusing attention on an alternative
	transition-signalling conceptual framework. We need a new conceptual
	framework because the complexity of VLSI technology has now reached
	the point where design time and design cost often exceed fabrication
	time and fabrication cost. Moreover, most systems designed today
	are monolithic and resist mid-life improvement. The transition-signalling
	conceptual framework offers the opportunity to build up complex systems
	by hierarchical composition from simpler pieces. The resulting systems
	are easily modified. I believe that the transition-signalling conceptual
	framework has much to offer in reducing the design time and cost
	of complex systems and increasing their useful lifetime. I offer
	this description of micropipelines as an example of the transition-signalling
	conceptual framework. Until recently only a hardy few used the transition-signalling
	conceptual framework for design because it was too hard. It was nearly
	impossible to design the small circuits of 10 to 100 transistors
	that form the elemental building blocks from which complex systems
	are composed. Moreover, it was difficult to prove anything about
	the resulting compositions. In the past five years, however, much
	progress has been made on both fronts. Charles Molnar and his colleagues
	at Washington University have developed a simple way to design the
	small basic building blocks [9]. Martin Rem's "VLSI Club" at the
	Technical University of Eindhoven has been working effectively on
	the mathematics of event-driven systems [6, 10, 11, 19]. These emerging
	conceptual tools now make transition signalling a lively candidate
	for widespread use.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/63526.63532},
  file = {1988-Sutherland1989.pdf:1988-Sutherland1989.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1988}
}

@ARTICLE{Tarjan1987,
  author = {Tarjan,, Robert E.},
  title = {Algorithm design},
  journal = {Commun. ACM},
  year = {1987},
  volume = {30},
  pages = {204--212},
  number = {3},
  abstract = {The quest for efficiency in computational methods yields not only
	fast algorithms, but also insights that lead to elegant, simple,
	and general problem-solving methods.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/214748.214752},
  file = {1986-Tarjan1987.pdf:1986-Tarjan1987.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1986}
}

@ARTICLE{Thompson1984,
  author = {Thompson,, Ken},
  title = {Reflections on trusting trust},
  journal = {Commun. ACM},
  year = {1984},
  volume = {27},
  pages = {761--763},
  number = {8},
  abstract = {To what extent should one trust a statement that a program is free
	of Trojan horses? Perhaps it is more important to trust the people
	who wrote the software.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358198.358210},
  file = {1983-Thompson1984.pdf:1983-Thompson1984.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1983}
}

@ARTICLE{Wilkes1968,
  author = {Wilkes,, Maurice V.},
  title = {Computers Then and Now},
  journal = {J. ACM},
  year = {1968},
  volume = {15},
  pages = {1--7},
  number = {1},
  abstract = {Reminiscences on the early developments leading to ]arge scale electronic
	computers show that it took much longer than was expected for the
	first of the more ambitious and fully engineered computers to be
	completed and prove themselves in practical operation. Comments on
	the present computer field assess the needs for future development.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/321439.321440},
  file = {1967-Wilkes1968.pdf:1967-Wilkes1968.pdf:PDF},
  issn = {0004-5411},
  keywords = {Moore School, ENIAC, Mauchly, Eckert, Wilkes, yon Neumann, Turing,
	optimum coding, ultrasonic delay line, Carr, Hopper, automatic programming,
	compilers, interpreters, history, prediction},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1967}
}

@ARTICLE{Wilkinson1971,
  author = {Wilkinson,, J. H.},
  title = {Some Comments from a Numerical Analyst},
  journal = {J. ACM},
  year = {1971},
  volume = {18},
  pages = {137--147},
  number = {2},
  abstract = {A description is given of life with A.M. Turing at the National Physical
	Laboratory in the early days of the development of electronic computers
	(1946-1948). The present mood of pessimism among numerical analysts
	resulting from difficult relationships with computer scientists and
	mathematician,s is discussed. It is suggested that in light of past
	and present performance this pessimism is unjustified and is the
	main enemy of progress in numerical mathematics. Some achievements
	iu the fields of matrix computations and error analysis are discussed
	and likely changes ia the direction of research in numerical analysis
	am sketched.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/321637.321638},
  file = {1970-Wilkinson1971.pdf:1970-Wilkinson1971.pdf:PDF},
  issn = {0004-5411},
  keywords = {Turing, National Physical Laboratory, ACE and PILOT ACE, Woodger,
	Huskey, matrix computations, Faddeeva, error analysis, Turing's contribution,
	mathematical physics, applied mathematics},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1970}
}

@ARTICLE{Wirth1985,
  author = {Wirth,, Niklaus},
  title = {From programming language design to computer construction},
  journal = {Commun. ACM},
  year = {1985},
  volume = {28},
  pages = {160--164},
  number = {2},
  abstract = {From NELIAC (via ALGOL 60) to Euler and ALGOL W, to Pascal and Modula-2,
	and ultimately Lilith, Wirth's search for an appropriate formalism
	for systems programming yields intriguing insights and surprising
	results.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/2786.2789},
  file = {1984-Wirth1985.pdf:1984-Wirth1985.pdf:PDF},
  issn = {0001-0782},
  owner = {solrex},
  publisher = {ACM},
  timestamp = {1984}
}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: fileDirectory:.;}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

