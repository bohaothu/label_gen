@InProceedings{BerdineORT01,
  author =	 {Josh Berdine and Peter W. O'Hearn and Uday S. Reddy and Hayo
                  Thielecke},
  title =	 {Linearly Used Continuations},
  booktitle =	 {Proceedings of the Third {ACM} {SIGPLAN} Workshop on
                  Continuations (CW'01)},
  pages =	 {47--54},
  year =	 {2000},
  editor =	 {Amr Sabry},
  month =	 dec,
  publisher =	 {Technical Report No. 545, Computer Science Department,
                  Indiana University},
  address =	 {London, United Kingdom},
  organization = {ACM SIGPLAN},
  note =	 {Superceded by \cite{BerdineORT02}},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/LinUC.pdf}
}

@article{BerdineORT02,
  author =	 {Josh Berdine and Peter O'Hearn and Uday Reddy and Hayo
                  Thielecke},
  title =	 {Linear Continuation-Passing},
  journal =	 {Higher-Order and Symbolic Computation},
  issn =	 {1388-3690},
  volume =	 {15},
  number =	 {2-3},
  month =	 sep,
  year =	 {2002},
  pages =	 {181-208},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/LinCP.pdf},
  abstract =	 {Continuations can be used to explain a wide variety of
                  control behaviours, including calling/returning
                  (procedures), raising/handling (exceptions), labelled
                  jumping (goto statements), process switching (coroutines),
                  and backtracking. However, continuations are often
                  manipulated in a highly stylised way, and we show that all
                  of these, bar backtracking, in fact use their continuations
                  linearly; this is formalised by taking a target language for
                  CPS transforms that has both intuitionistic and linear
                  function types.}
}

@Unpublished{BerdineOT02,
  author =	 {Josh Berdine and Peter W. O'Hearn and Hayo Thielecke},
  title =	 {Extracting the Range of {CPS} from Affine Typing: Extended
                  Abstract},
  note =	 {Presented at \emph{FLoC'02 Workshop on Linear Logic (LL
                  2002)}},
  month =	 jul,
  year =	 {2002},
  address =	 {Copenhagen, Denmark},
  organization = {LICS and Association for Symbolic Logic},
  documenturl =	 {http://research.microsoft.com/~jjb/drafts/ExtRCAT.pdf},
  abstract =	 {Increasing degrees of reasoning about programs are being
                  mechanized, and hence more formality is needed. Here we
                  present an instance of this formalization in the form of a
                  precise characterization of the range of the CPS
                  transformation using an affine type system. The point is
                  that the range of CPS is defined with a type system, that
                  is, in a way quite accessible to tools.}
}

@PhdThesis{Berdine04,
  author =	 {Joshua James Berdine},
  title =	 {Linear and Affine Typing of Continuation-Passing Style},
  school =	 {Queen Mary, University of London},
  year =	 {2004},
  address =	 {London, United Kingdom},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/thesis.pdf},
  abstract =	 {In this dissertation we show that linear and affine type
                  systems for continuation-passing style support correct and
                  tight refinements of standard continuation semantics. In
                  particular, a wide variety of control constructs admit
                  typing disciplines which ensure linear or affine use of the
                  control context in their continuation semantics.

                  This refinement of standard continuation semantics using
                  restricted types is an exploitation of the stylized use of
                  continuations many control behaviors exhibit. Continuations
                  are the raw material of control and can be used to explain a
                  wide variety of control behaviors, including
                  calling/returning (procedures), raising/handling
                  (exceptions), jumping/labeling (goto and labels), process
                  switching (coroutines), backtracking (amb and fail), and
                  capturing/invoking first-class continuations (call/cc, or
                  callcc and throw). However, in all but the last case,
                  continuations are not themselves intrinsic to the control
                  construct, instead they are “behind the scenes,”
                  implementing the control construct. In other words, except
                  for first-class continuations, each control behavior is
                  simply an idiom of continuation usage, and hence the
                  continuations are used in a stylized fashion. Linear or
                  affine use of control contexts; by which we mean, roughly,
                  that control contexts cannot be duplicated or, in the linear
                  case, discarded; captures this stylized usage in all the
                  above-mentioned cases bar backtracking. We also investigate
                  several cases where even storable labels (plus goto) admit
                  restricted interpretations.}
}

@inproceedings{BerdineCO04,
  author =	 {Josh Berdine and Cristiano Calcagno and Peter W. O'Hearn},
  title =	 {A Decidable Fragment of Separation Logic},
  booktitle =	 {FSTTCS 2004: Foundations of Software Technology and
                  Theoretical Computer Science, 24th International Conference,
                  Chennai, India, December 16-18, 2004, Proceedings},
  year =	 {2004},
  pages =	 {97-109},
  editor =	 {Kamal Lodaya and Meena Mahajan},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {3328},
  month =	 dec,
  isbn =	 {3-540-24058-6},
  ee =           {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=3328{\&}spage=97},
  documenturl =  {http://research.microsoft.com/~jjb/papers/unroll_collapse.pdf},
  abstract =	 {We present a fragment of separation logic oriented to linked
                  lists, and study decision procedures for validity of
                  entailments. The restrictions in the fragment are motivated
                  by the stylized form of reasoning done in example program
                  proofs. The fragment includes a predicate for describing
                  linked list segments (a kind of reachability or transitive
                  closure).  Decidability is first proved by semantic means:
                  by showing a small model property that bounds the size of
                  potential countermodels that must be checked. We then
                  provide a complete proof system for the fragment, the
                  termination of which furnishes a second decision procedure.}
}

@inproceedings{BerdineCO05,
  author =	 {Josh Berdine and Cristiano Calcagno and Peter W. O'Hearn},
  title =	 {Symbolic Execution with Separation Logic},
  booktitle =	 {Programming Languages and Systems, Third Asian Symposium,
                  APLAS 2005, Tsukuba, Japan, November 2-5, 2005, Proceedings},
  year =	 {2005},
  pages =	 {52-68},
  editor =	 {Kwangkeun Yi},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {3780},
  isbn =	 {3-540-29735-9},
  ee =		 {http://dx.doi.org/10.1007/11575467_5},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/execution.pdf},
  abstract =	 {We describe a sound method for automatically proving Hoare
                  triples for loop-free code in Separation Logic, for certain
                  preconditions and postconditions (symbolic heaps). The
                  method uses a form of symbolic execution, a decidable proof
                  theory for symbolic heaps, and extraction of frame axioms
                  from incomplete proofs. This is a precursor to the use of
                  the logic in automatic specification checking, program
                  analysis, and model checking.}
}

@inproceedings{BerdineCO05b,
  author =	 {Josh Berdine and Cristiano Calcagno and Peter W. O'Hearn},
  title =	 {Smallfoot: Modular Automatic Assertion Checking with
                  Separation Logic},
  booktitle =	 {Formal Methods for Components and Objects, 4th International
                  Symposium, FMCO 2005, Amsterdam, The Netherlands, November
                  1-4, 2005, Revised Lectures},
  year =	 {2005},
  pages =	 {115-137},
  editor =	 {Frank S. de Boer and Marcello M. Bonsangue and Susanne Graf
                  and Willem P. de Roever},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4111},
  isbn =	 {3-540-36749-7},
  ee =		 {http://dx.doi.org/10.1007/11804192_6},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/smallfoot.pdf},
  abstract =	 {Separation logic is a program logic for reasoning about
                  programs that manipulate pointer data structures. We
                  describe Smallfoot, a tool for checking certain lightweight
                  separation logic specifications. The assertions describe the
                  shapes of data structures rather than their detailed
                  contents, and this allows reasoning to be fully
                  automatic. The presentation in the paper is tutorial in
                  style. We illustrate what the tool can do via examples which
                  are oriented toward novel aspects of separation logic,
                  namely: avoidance of frame axioms (which say what a
                  procedure does not change); embracement of “dirty” features
                  such as memory disposal and address arithmetic; information
                  hiding in the presence of pointers; and modular reasoning
                  about concurrent programs.}
}

@article{BerdineO06,
  author =	 {Josh Berdine and Peter W. O'Hearn},
  title =	 {Strong Update, Disposal, and Encapsulation in Bunched
                  Typing},
  journal =	 {Electr. Notes Theor. Comput. Sci.},
  volume =	 {158},
  year =	 {2006},
  pages =	 {81-98},
  ee =		 {http://dx.doi.org/10.1016/j.entcs.2006.04.006},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/bil.pdf},
  abstract =	 {We present a bunched intermediate language for strong
                  (type-changing) update and disposal of first-order
                  references. In contrast to other substructural type systems,
                  the additive constructs of bunched types allow the
                  encapsulation of state that is shared by a collection of
                  procedures.}
}

@inproceedings{BerdineCDO06,
  author =	 {Josh Berdine and Byron Cook and Dino Distefano and Peter
                  W. O'Hearn},
  title =	 {Automatic Termination Proofs for Programs with
                  Shape-Shifting Heaps},
  booktitle =	 {Computer Aided Verification, 18th International Conference,
                  CAV 2006, Seattle, WA, USA, August 17-20, 2006, Proceedings},
  year =	 {2006},
  pages =	 {386-400},
  editor =	 {Thomas Ball and Robert B. Jones},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4144},
  isbn =	 {3-540-37406-X},
  ee =		 {http://dx.doi.org/10.1007/11817963_35},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/mutant.pdf},
  abstract =	 {We describe a new program termination analysis designed to
                  handle imperative programs whose termination depends on the
                  mutation of the program’s heap. We first describe how an
                  abstract interpretation can be used to construct a finite
                  number of relations which, if each is well-founded, implies
                  termination. We then give an abstract interpretation based
                  on separation logic formulæ which tracks the depths of
                  pieces of heaps. Finally, we combine these two techniques to
                  produce an automatic termination prover. We show that the
                  analysis is able to prove the termination of loops extracted
                  from Windows device drivers that could not be proved
                  terminating before by other means; we also discuss a
                  previously unknown bug found with the analysis.}
}

@inproceedings{GotsmanBC06,
  author =	 {Alexey Gotsman and Josh Berdine and Byron Cook},
  title =	 {Interprocedural Shape Analysis with Separated Heap
                  Abstractions},
  booktitle =	 {Static Analysis, 13th International Symposium, SAS 2006,
                  Seoul, Korea, August 29-31, 2006, Proceedings},
  year =	 {2006},
  pages =	 {240-260},
  editor =	 {Kwangkeun Yi},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4134},
  isbn =	 {3-540-37756-5},
  ee =		 {http://dx.doi.org/10.1007/11823230_16},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/interproc.pdf},
  abstract =	 {We describe an interprocedural shape analysis that makes use
                  of spatial locality (i.e. the fact that most procedures
                  modify only a small subset of the heap) in its
                  representation of abstract states. Instead of tracking
                  reachability information directly and aliasing information
                  indirectly, our representation tracks reachability
                  indirectly and aliasing directly. Computing the effect of
                  procedure calls and returns on an abstract state is easy
                  because the representation exhibits spatial locality
                  mirroring the locality that is present in the concrete
                  semantics. The benefits of this approach include improved
                  speed, support for programs that deallocate memory, the
                  handling of bounded numbers of heap cutpoints, and support
                  for cyclic and shared data structures.}
}

@inproceedings{BerdineCCDO07,
  author =	 {Josh Berdine and Aziem Chawdhary and Byron Cook and Dino
                  Distefano and Peter O'Hearn},
  title =	 {Variance Analyses from Invariance Analyses},
  booktitle =	 {Proceedings of the 34th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages, POPL 2007, Nice,
                  France, January 17-19, 2007},
  year =	 {2007},
  pages =	 {211-224},
  editor =	 {Martin Hofmann and Matthias Felleisen},
  publisher =	 {ACM},
  isbn =	 {1-59593-575-4},
  ee =		 {http://doi.acm.org/10.1145/1190216.1190249},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/term4free.pdf},
  abstract =	 {An invariance assertion for a program location l is a
                  statement that always holds at l during execution of the
                  program. Program invariance analyses infer invariance
                  assertions that can be useful when trying to prove safety
                  properties. We use the term variance assertion to mean a
                  statement that holds between any state at l and any previous
                  state that was also at l. This paper is concerned with the
                  development of analyses for variance assertions and their
                  application to proving termination and liveness
                  properties. We describe a method of constructing program
                  variance analyses from invariance analyses. If we change the
                  underlying invariance analysis, we get a different variance
                  analysis. We describe several applications of the method,
                  including variance analyses using linear arithmetic and
                  shape analysis. Using experimental results we demonstrate
                  that these variance analyses give rise to a new breed of
                  termination provers which are competitive with and sometimes
                  better than today’s state-of-the-art termination provers.}
}

@inproceedings{ManevichBCRS07,
  author =	 {Roman Manevich and Josh Berdine and Byron Cook and Ganesan
                  Ramalingam and Mooly Sagiv},
  title =	 {Shape Analysis by Graph Decomposition},
  booktitle =	 {Tools and Algorithms for the Construction and Analysis of
                  Systems, 13th International Conference, TACAS 2007, Held as
                  Part of the Joint European Conferences on Theory and
                  Practice of Software, ETAPS 2007 Braga, Portugal, March 24 -
                  April 1, 2007, Proceedings},
  year =	 {2007},
  pages =	 {3-18},
  editor =	 {Orna Grumberg and Michael Huth},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4424},
  isbn =	 {978-3-540-71208-4},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-71209-1_3},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/sagd.pdf},
  abstract =	 {Programs commonly maintain multiple linked data
                  structures. Correlations between multiple data structures
                  may often be nonexistent or irrelevant to verifying that the
                  program satisfies certain safety properties or
                  invariants. In this paper, we show how this independence
                  between different (singly-linked) data structures can be
                  utilized to perform shape analysis and verification more
                  efficiently. We present a new abstraction based on
                  decomposing graphs into sets of subgraphs, and show that, in
                  practice, this new abstraction leads to very little loss of
                  precision, while yielding substantial improvements to
                  efficiency.}
}

@inproceedings{GotsmanBCS07,
  author =	 {Alexey Gotsman and Josh Berdine and Byron Cook and Mooly
                  Sagiv},
  title =	 {Thread-Modular Shape Analysis},
  booktitle =	 {Proceedings of the ACM SIGPLAN 2007 Conference on
                  Programming Language Design and Implementation, San Diego,
                  California, USA, June 10-13, 2007},
  year =	 {2007},
  pages =	 {266-277},
  editor =	 {Jeanne Ferrante and Kathryn S. McKinley},
  publisher =	 {ACM},
  isbn =	 {978-1-59593-633-2},
  ee =		 {http://doi.acm.org/10.1145/1250734.1250765},
  documenturl =  {http://research.microsoft.com/~jjb/papers/thread-modular.pdf},
  abstract =	 {We present the first shape analysis for multithreaded
                  programs that avoids the explicit enumeration of
                  execution-interleavings. Our approach is to automatically
                  infer a resource invariant associated with each lock that
                  describes the part of the heap protected by the lock.  This
                  allows us to use a sequential shape analysis on each thread.
                  We show that resource invariants of a certain class can be
                  characterized as least fixed points and computed via
                  repeated applications of shape analysis only on each
                  individual thread. Based on this approach, we have
                  implemented a thread-modular shape analysis tool and applied
                  it to concurrent heap-manipulating code from Windows device
                  drivers.}
}

@inproceedings{BerdineCCDOWY07,
  author =	 {Josh Berdine and Cristiano Calcagno and Byron Cook and Dino
                  Distefano and Peter W. O'Hearn and Thomas Wies and Hongseok
                  Yang},
  title =	 {Shape Analysis for Composite Data Structures},
  booktitle =	 {Computer Aided Verification, 19th International Conference,
                  CAV 2007, Berlin, Germany, July 3-7, 2007, Proceedings},
  year =	 {2007},
  pages =	 {178-192},
  editor =	 {Werner Damm and Holger Hermanns},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4590},
  isbn =	 {978-3-540-73367-6},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-73368-3_22},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/safcds.pdf},
  abstract =	 {We propose a shape analysis that adapts to some of the
                  complex composite data structures found in industrial
                  systems-level programs.  Examples of such data structures
                  include “cyclic doubly-linked lists of acyclic singly-linked
                  lists”, “singly-linked lists of cyclic doubly-linked lists
                  with back-pointers to head nodes”, etc. The analysis
                  introduces the use of generic higher-order inductive
                  predicates describing spatial relationships together with a
                  method of synthesizing new parameterized spatial predicates
                  which can be used in combination with the higher-order
                  predicates. In order to evaluate the proposed approach for
                  realistic programs we have performed experiments on examples
                  drawn from device drivers: the analysis proved safety of the
                  data structure manipulation of several routines belonging to
                  an IEEE 1394 (firewire) driver, and also found several
                  previously unknown memory safety bugs.}
}

@inproceedings{MagillBCC07,
  author =	 {Stephen Magill and Josh Berdine and Edmund M. Clarke and
                  Byron Cook},
  title =	 {Arithmetic Strengthening for Shape Analysis},
  booktitle =	 {Static Analysis, 14th International Symposium, SAS 2007,
                  Kongens Lyngby, Denmark, August 22-24, 2007, Proceedings},
  year =	 {2007},
  pages =	 {419-436},
  editor =	 {Hanne Riis Nielson and Gilberto Fil{\'e}},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4634},
  isbn =	 {978-3-540-74060-5},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-74061-2_26},
  documenturl =  {http://research.microsoft.com/~jjb/papers/arithmetic_strengthening.pdf},
  abstract =	 {Shape analyses are often imprecise in their numerical
                  reasoning, whereas numerical static analyses are often
                  largely unaware of the shape of a program’s heap. In this
                  paper we propose a lazy method of combining a shape analysis
                  based on separation logic with an arbitrary arithmetic
                  analysis. When potentially spurious counterexamples are
                  reported by our shape analysis, the method constructs a
                  purely arithmetic program whose traces over-approximate the
                  set of counterexample traces.  It then uses this arithmetic
                  program together with the arithmetic analysis to construct a
                  refinement for the shape analysis. Our method is aimed at
                  proving properties that require comprehensive reasoning
                  about heaps together with more targeted arithmetic
                  reasoning. Given a sufficient precondition, our technique
                  can automatically prove memory safety of programs whose
                  error-free operation depends on a combination of shape,
                  size, and integer invariants. We have implemented our
                  algorithm and tested it on a number of common list routines
                  using a variety of arithmetic analysis tools for
                  refinement.}
}

@inproceedings{GotsmanBCRS07,
  author =	 {Alexey Gotsman and Josh Berdine and Byron Cook and Noam
                  Rinetzky and Mooly Sagiv},
  title =	 {Local Reasoning for Storable Locks and Threads},
  booktitle =	 {Programming Languages and Systems, 5th Asian Symposium,
                  APLAS 2007, Singapore, November 29-December 1, 2007,
                  Proceedings},
  year =	 {2007},
  pages =	 {19-37},
  editor =	 {Zhong Shao},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {4807},
  isbn =	 {978-3-540-76636-0},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-76637-7_3},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/lith.pdf},
  abstract =	 {We present a resource oriented program logic that is able to
                  reason about concurrent heap-manipulating programs with
                  unbounded numbers of dynamically-allocated locks and
                  threads. The logic is inspired by concurrent separation
                  logic, but handles these more realistic concurrency
                  primitives. We demonstrate that the proposed logic allows
                  local reasoning about programs for which there exists a
                  notion of dynamic ownership of heap parts by locks and
                  threads.}
}

@TechReport{ManevichLSRB07,
  author =	 {Roman Manevich and Tal Lev-Ami and Mooly Sagiv and Ganesan
                  Ramalingam and Josh Berdine},
  title =	 {Heap Decomposition for Concurrent Shape Analysis},
  institution =	 {Tel Aviv University, School of Computer Science},
  year =	 {2007},
  number =	 {TR-2007-11-85453},
  abstract =	 {We demonstrate shape analyses that can achieve a state space
                  reduction exponential in the number of threads compared to
                  the state-of-the-art analyses, while retaining sufficient
                  precision to verify sophisticated properties such as
                  linearizability. The key idea is to abstract the global heap
                  by decomposing it into (not necessarily disjoint) subheaps,
                  abstracting away some correlations between them. These new
                  shape analyses are instances of an analysis framework based
                  on heap decomposition. This framework allows rapid
                  prototyping of complex static analyses by providing
                  efficient abstract transformers given user-specified
                  decomposition schemes. Initial experiments confirm the value
                  of heap decomposition in scaling concurrent shape analyses.}
}

@inproceedings{ManevichLSRB08,
  author =	 {Roman Manevich and Tal Lev-Ami and Mooly Sagiv and Ganesan
                  Ramalingam and Josh Berdine},
  title =	 {Heap Decomposition for Concurrent Shape Analysis},
  booktitle =	 {Static Analysis, 15th International Symposium, SAS 2008,
                  Valencia, Spain, July 16-18, 2008. Proceedings},
  year =	 {2008},
  pages =	 {363-377},
  editor =	 {Mar\'{\i}a Alpuente and Germ{\'a}n Vidal},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {5079},
  isbn =	 {978-3-540-69163-1},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-69166-2_24},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/hedec.pdf},
  abstract =	 {We demonstrate shape analyses that can achieve a state space
                  reduction exponential in the number of threads compared to
                  the state-of-the-art analyses, while retaining sufficient
                  precision to verify sophisticated properties such as
                  linearizability. The key idea is to abstract the global heap
                  by decomposing it into (not necessarily disjoint) subheaps,
                  abstracting away some correlations between them. These new
                  shape analyses are instances of an analysis framework based
                  on heap decomposition. This framework allows rapid
                  prototyping of complex static analyses by providing
                  efficient abstract transformers given user-specified
                  decomposition schemes. Initial experiments confirm the value
                  of heap decomposition in scaling concurrent shape analyses.}
}

@TechReport{BerdineLMRS08TR,
  author =	 {Josh Berdine and Tal Lev-Ami and Roman Manevich and Ganesan
                  Ramalingam and Mooly Sagiv},
  title =	 {Thread Quantification for Concurrent Shape Analysis},
  institution =	 {Tel Aviv University, School of Computer Science},
  year =	 2008,
  number =	 {TR-2008-01TQ},
  abstract =	 {We present new algorithms for automatically verifying
                  properties of programs with an unbounded number of
                  threads. Our algorithms are based on a new abstract domain
                  whose elements represent thread-quantified invariants: i.e.,
                  invariants satisfied by all threads.We exploit existing
                  abstractions to represent the invariants. Thus, our
                  technique lifts existing abstractions by wrapping universal
                  quantification around elements of the base abstract domain.

                  Such abstractions are effective because they are
                  thread-modular: e.g., they can capture correlations between
                  the local variables of the same thread as well as
                  correlations between the local variables of a thread and
                  global variables, but forget correlations between the states
                  of distinct threads. (The exact nature of the abstraction,
                  of course, depends on the base abstraction lifted in this
                  style.

                  We present techniques for computing sound transformers for
                  the new abstraction by using transformers of the base
                  abstract domain. We illustrate our technique in this paper
                  by instantiating it to the Boolean Heap abstraction,
                  producing a Quantified Boolean Heap abstraction. We have
                  implemented an instantiation of our technique with Canonical
                  Abstraction as the base abstraction and used it to
                  successfully verify linearizability of data-structures in
                  the presence of an unbounded number of threads.}
}

@inproceedings{BerdineLMRS08,
  author =	 {Josh Berdine and Tal Lev-Ami and Roman Manevich and Ganesan
                  Ramalingam and Mooly Sagiv},
  title =	 {Thread Quantification for Concurrent Shape Analysis},
  booktitle =	 {Computer Aided Verification, 20th International Conference,
                  CAV 2008, Princeton, NJ, USA, July 7-14, 2008, Proceedings},
  year =	 {2008},
  pages =	 {399-413},
  editor =	 {Aarti Gupta and Sharad Malik},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {5123},
  isbn =	 {978-3-540-70543-7},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-70545-1_37},
  documenturl =  {http://research.microsoft.com/~jjb/papers/thread_quantification.pdf},
  abstract =	 {In this paper we address the problem of shape analysis for
                  concurrent programs. We present new algorithms, based on
                  abstract interpretation, for automatically verifying
                  properties of programs with an unbounded number of threads
                  manipulating an unbounded shared heap.

                  Our algorithms are based on a new abstract domain whose
                  elements represent thread-quantified invariants: i.e.,
                  invariants satisfied by all threads. We exploit existing
                  abstractions to represent the invariants. Thus, our
                  technique lifts existing abstractions by wrapping universal
                  quantification around elements of the base abstract
                  domain. Such abstractions are effective because they are
                  thread modular: e.g., they can capture correlations between
                  the local variables of the same thread as well as
                  correlations between the local variables of a thread and
                  global variables, but forget correlations between the states
                  of distinct threads. (The exact nature of the abstraction,
                  of course, depends on the base abstraction lifted in this
                  style.)

                  We present techniques for computing sound transformers for
                  the new abstraction by using transformers of the base
                  abstract domain. We illustrate our technique in this paper
                  by instantiating it to the Boolean Heap abstraction,
                  producing a Quantified Boolean Heap abstraction. We have
                  implemented an instantiation of our technique with Canonical
                  Abstraction as the base abstraction and used it to
                  successfully verify linearizability of data-structures in
                  the presence of an unbounded number of threads.}
}

@inproceedings{YangLBCCDO08,
  author =	 {Hongseok Yang and Oukseh Lee and Josh Berdine and Cristiano
                  Calcagno and Byron Cook and Dino Distefano and Peter
                  O'Hearn},
  title =	 {Scalable Shape Analysis for Systems Code},
  booktitle =	 {Computer Aided Verification, 20th International Conference,
                  CAV 2008, Princeton, NJ, USA, July 7-14, 2008, Proceedings},
  year =	 {2008},
  pages =	 {385-398},
  editor =	 {Aarti Gupta and Sharad Malik},
  publisher =	 {Springer},
  series =	 {Lecture Notes in Computer Science},
  volume =	 {5123},
  isbn =	 {978-3-540-70543-7},
  ee =		 {http://dx.doi.org/10.1007/978-3-540-70545-1_36},
  documenturl =	 {http://research.microsoft.com/~jjb/papers/scalable.pdf},
  abstract =	 {Pointer safety faults in device drivers are one of the
                  leading causes of crashes in operating systems code. In
                  principle, shape analysis tools can be used to prove the
                  absence of this type of error. In practice, however, shape
                  analysis is not used due to the unacceptable mixture of
                  scalability and precision provided by existing tools. In
                  this paper we report on a new join operation |†| for the
                  separation domain which aggressively abstracts information
                  for scalability yet does not lead to false error
                  reports. |†| is a critical piece of a new shape analysis
                  tool that provides an acceptable mixture of scalability and
                  precision for industrial application.  Experiments on whole
                  Windows and Linux device drivers (firewire, pcidriver,
                  cdrom, md, etc.) represent the first working application of
                  shape analysis to verification of whole industrial
                  programs.}
}

@InProceedings{NanevskiVB10,
  author = 	 {Aleksandar Nanevski and Viktor Vafeiadis and Josh Berdine},
  title = 	 {Structuring the Verification of Heap-Manipulating Programs},
  OPTcrossref =  {},
  OPTkey = 	 {},
  booktitle =	 {Proceedings of the 37th ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages, POPL 2010, Madrid,
                  Spain, January 17-23, 2010},
  OPTpages = 	 {},
  year =	 {2010},
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 {},
  OPTmonth = 	 {},
  OPTorganization = {},
  publisher =	 {ACM},
  isbn =	 {978-1-60558-479-9},
  OPTnote = 	 {},
  OPTannote = 	 {},
  abstract =     {Most systems based on separation logic consider only
                  restricted forms of implication or non-separating
                  conjunction, as full support for these connectives requires
                  a non-trivial notion of variable context, inherited from the
                  logic of bunched implications (BI). We show that in an
                  expressive type theory such as Coq, one can avoid the
                  intricacies of BI, and support full separation logic very
                  efficiently, using the native structuring primitives of the
                  type theory.

                  Our proposal uses reflection to enable equational reasoning
                  about heaps, and Hoare triples with binary postconditions to
                  further facilitate it. We apply these ideas to Hoare Type
                  Theory, to obtain a new proof technique for verification of
                  higher-order imperative programs that is general,
                  extendable, and supports very short proofs, even without
                  significant use of automation by tactics. We demonstrate the
                  usability of the technique by verifying the fast congruence
                  closure algorithm of Nieuwenhuis and Oliveras, employed in
                  the state-of-the-art Barcelogic SAT solver.}
}
