


%
%
%
% automatically generated
% % BibTeX2HTML D:\Documents\Common\Ptidej (automatically merged, cleaned, and without duplicates).bib -force -nw -sort-criterium year
% Date: Tue Mar 15 14:56:19 2011

% Author: Gueheneuc
%
%
%










@ARTICLE{Guerrouj11-JSME-TIDIER,
   AUTHOR       = {Latifa Guerrouj and Massimiliano Di Penta and 
      Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   JOURNAL      = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
   TITLE        = {TIDIER: An Identifier Splitting Approach using Speech 
      Recognition Techniques},
   YEAR         = {2011},
   OPTMONTH     = {},
   NOTE         = {In press. 31 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Rudolf Ferenc and Juan Carlos Dueñas},
   KEYWORDS     = {Understanding program comprehension, JSME},
   PUBLISHER    = {Wiley},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JSME11.doc.pdf},
   ABSTRACT     = {The software engineering literature reports empirical 
      evidence on the relation between various characteristics of a 
      software system and software quality. Among many factors, recent 
      studies have shown that a proper choice of identifiers influences 
      software understandability and maintainability. Indeed, identifiers 
      are developers' main source of information and guide their cognitive 
      processes during program understanding when high-level documentation 
      is scarce or outdated and when source code is not sufficiently 
      commented. This paper proposes a novel approach to recognize words 
      composing source code identifiers. The approach is based on an 
      adaptation of Dynamic Time Warping used to recognize words in 
      continuous speech. The approach overcomes the limitations of existing 
      identifier splitting approaches when naming conventions (\eg{} Camel 
      Case) are not used or when identifiers contain abbreviations. The 
      proposed approach has been applied on a sample of more than 1,000 
      identifiers extracted from 340 C programs and compared with a simple 
      Camel Case splitter and with an implementation of an alternative 
      identifier splitting approach, Samurai. Results indicate the 
      capability of the novel approach (i) to outperform the alternative 
      ones when a dictionary augmented with domain knowledge or a 
      contextual dictionary are used and (ii) to expand 48\% of a set of 
      selected abbreviations into dictionary words.}
}

@ARTICLE{Khmoh11-EMSE-AntiPatternsImpact,
   AUTHOR       = {Foutse Khomh and Di Penta, Massimiliano and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   JOURNAL      = {Empirical Software Engineering (EMSE)},
   TITLE        = {An Exploratory Study of the Impact of Antipatterns on 
      Class Change- and Fault-Proneness},
   YEAR         = {2011},
   OPTMONTH     = {},
   NOTE         = {Under minor revision. 27 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Victor R. Basili and Lionel C. Briand},
   KEYWORDS     = {Code and design smells, EMSE},
   PUBLISHER    = {Springer},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/EMSE11.doc.pdf},
   ABSTRACT     = {~\\ {\bf Context: } Antipatterns are poor design choices 
      that are conjectured to make object-orien\-ted systems harder to 
      maintain. \noindent {\bf Aim: } We investigate the impact of 
      antipatterns on classes in object-oriented systems by studying the 
      relation between the presence of antipatterns and the change- and 
      fault-proneness of the classes. \noindent {\bf Method: } We detect 
      \numberofap{} antipatterns in \numberofver{} releases of ArgoUML, 
      Eclipse, Mylyn, and Rhino, and analyse (1) to what extent classes 
      participating in antipatterns have higher odds to change or to be 
      subject to fault-fixing than other classes, (2) to what extent these 
      odds (if higher) are due to the sizes of the classes or to the 
      presence of antipatterns, and (3) what kinds of changes affect 
      classes participating in antipatterns. \noindent {\bf Results:} We 
      show that, in almost all releases of the four systems, classes 
      participating in antipatterns are more change- and fault-prone than 
      others. We also show that size alone cannot explain the higher odds 
      of classes with antipatterns to underwent a (fault-fixing) change 
      than other classes. Finally, we show that structural changes affect 
      more classes with antipatterns than others. We provide qualitative 
      explanations of the increase of change- and fault-proneness in 
      classes participating in antipatterns using release notes and bug 
      reports. \noindent {\bf Conclusions: } The obtained results justify 
      \emph{a posteriori} previous work on the specification and detection 
      of antipatterns and could help to better focus quality assurance and 
      testing activities.}
}

@ARTICLE{Khomh11-JSS-GQMBayesianDesignSmells,
   AUTHOR       = {Foutse Khomh and Stéphane Vaucher and 
      Yann-Gaël Guéhéneuc and Houari Sahraoui},
   JOURNAL      = {Journal of Software and Systems (JSS)},
   TITLE        = {A GQM-based Method and a Bayesian Approach for the 
      Detection of Code and Design Smells},
   YEAR         = {2011},
   OPTMONTH     = {},
   NOTE         = {In press. 35 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {van Vliet, Hans},
   KEYWORDS     = {Code and design smells, JSS},
   PUBLISHER    = {Elsevier},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JSS11.doc.pdf},
   ABSTRACT     = {The presence of code and design smells can have a severe 
      impact on the quality of a program. Consequently, their detection and 
      correction have drawn the attention of both researchers and 
      practitioners who have proposed various approaches to detect code and 
      design smells in programs. However, none of these approaches handle 
      the inherent uncertainty of the detection process. We propose a 
      Bayesian approach to manage this uncertainty. First, we present a 
      systematic process to convert existing state-of-the-art detection 
      rules into a probabilistic model. We illustrate this process by 
      generating a model to detect occurrences of the Blob antipattern. 
      Second, we present results of the validation of the model: we built 
      this model on two open-source programs, \product{GanttProject 
      v1.10.2} and \product{Xerces v2.7.0}, and measured its accuracy. 
      Third, we compare our model with another approach to show that it 
      returns the same candidate classes while ordering them to minimise 
      the quality analysts' effort. Finally, we show that when past 
      detection results are available, our model can be calibrated using 
      machine learning techniques to offer an improved, context-specific 
      detection.}
}

@INPROCEEDINGS{Abbes11-CSMR-AntipatternsImpactComprehension,
   AUTHOR       = {Marwen Abbes and Foutse Khomh and Yann-Gaël Guéhéneuc and 
      Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 15<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {An Empirical Study of the Impact of Two Antipatterns, 
      Blob and Spaghetti Code, On Program Comprehension},
   YEAR         = {2011},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Yiannis Kanellopoulos and Tom Mens},
   MONTH        = {March},
   NOTE         = {Best paper. 10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR11a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR11a.ppt.pdf},
   ABSTRACT     = {Antipatterns are ``poor'' solutions to recurring design 
      problems which are conjectured in the literature to make 
      object-oriented systems harder to maintain. However, little 
      quantitative evidence exists to support this conjecture. We performed 
      an empirical study to investigate whether the occurrence of 
      antipatterns does indeed affect the understandability of systems by 
      developers during comprehension and maintenance tasks. We designed 
      and conducted three experiments, with 24 subjects each, to collect 
      data on the performance of developers on basic tasks related to 
      program comprehension and assessed the impact of two antipatterns and 
      of their combinations: Blob and Spaghetti Code. We measured the 
      developers' performance with: (1) the NASA task load index for their 
      effort; (2) the time that they spent performing their tasks; and, (3) 
      their percentages of correct answers. Collected data show that the 
      occurrence of one antipattern does not significantly decrease 
      developers' performance while the combination of two antipatterns 
      impedes significantly developers. We conclude that developers can 
      cope with one antipattern but that combinations of antipatterns 
      should be avoided possibly through detection and refactorings.}
}

@INPROCEEDINGS{Belderrar11-CSMR-SubgraphsEvolution,
   AUTHOR       = {Ahmed Belderrar and Segla Kpodjedo and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol and Philippe Galinier},
   BOOKTITLE    = {Proceedings of the 15<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {Sub-graph Mining: Identifying Micro-architectures in 
      Evolving Object-oriented Software},
   YEAR         = {2011},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Yiannis Kanellopoulos and Tom Mens},
   MONTH        = {March},
   NOTE         = {Best paper. 10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR11b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR11b.ppt.pdf},
   ABSTRACT     = {Developers introduce novel and undocumented 
      micro-architectures when performing evolution tasks on 
      object-oriented applications. We are interested in understanding 
      whether those organizations of classes and relations can bear, much 
      like cataloged design and anti-patterns, potential harm or benefit to 
      an object-oriented application. We present SGFinder, a sub-graph 
      mining approach and tool based on an efficient enumeration technique 
      to identify recurring micro-architectures in object-oriented class 
      diagrams. Once SGFinder has detected instances of 
      micro-architectures, we exploit these instances to identify their 
      desirable properties, such as stability, or unwanted properties, such 
      as change or fault proneness. We perform a feasibility study of our 
      approach by applying SGFinder on the reverse-engineered class 
      diagrams of several releases of two Java applications: ArgoUML and 
      Rhino. We characterize and highlight some of the most interesting 
      micro-architectures, \eg{} the most change and fault prone, and 
      conclude that SGFinder opens the way to further interesting studies.}
}

@INPROCEEDINGS{Bhattacharya11-ICST-P-CSPGAComparisonTestGeneration,
   AUTHOR       = {Neelesh Bhattacharya and Abdelilah Sakti and 
      Giuliano Antoniol and Yann-Gaël Guéhéneuc and Gilles Pesant},
   BOOKTITLE    = {Proceedings of the 4<sup>th</sup> International Conference on Software Testing, Verification, and Validation (ICST)},
   TITLE        = {Performance Analysis of Metaheuristic and Constraint 
      Programming Approaches to Generate Structural Test Cases},
   YEAR         = {2011},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Fevzi Belli and Michael Linschulte},
   MONTH        = {March},
   NOTE         = {Poster. 2 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Test Case Generation, ICST},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICST11.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICST11.ppt.pdf},
   ABSTRACT     = {Structural test case generation has been carried out by 
      various approaches in software testing. Metaheuristics and constraint 
      programming approaches are two of the more important approaches used 
      for generating structural test cases. However, both of these 
      approaches have limitations, which prevent them to be used in various 
      applications, like wireless telecommunication and aeonautical 
      engineering, because the problems in these areas involve variables 
      with large domains and complex constraints.}
}

@INPROCEEDINGS{Eshkevari11-MSR-IdentifierRenamingTaxonomy,
   AUTHOR       = {Laleh Eshkevari and Venera Arnaoudova and 
      Di Penta, Massimiliano and Rocco Oliveto and Yann-Gaël Guéhéneuc and 
      Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 8<sup>th</sup> Working Conference on Mining Software Repositories (MSR)},
   TITLE        = {An Exploratory Study of Identifier Renamings},
   YEAR         = {2011},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Tao Xie and Thomas Zimmermann},
   MONTH        = {May},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, MSR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/MSR11.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/MSR11.ppt.pdf},
   ABSTRACT     = {Identifiers play an important role in source code 
      understandability, maintainability, and fault-proneness. This paper 
      reports a study of identifier renamings in software systems, studying 
      how terms (identifier atomic components) change in source code 
      identifiers. Specifically, the paper (i) proposes a term renaming 
      taxonomy, (ii) presents an approximate lightweight code analysis 
      approach to detect and classify term renamings automatically into the 
      taxonomy dimensions, and (iii) reports an exploratory study of term 
      renamings in two open source projects, Eclipse-JDT and Tomcat. We 
      thus report evidence that not only synonyms are involved in renaming 
      but also (in a small fraction) more unexpected changes occur: 
      surprisingly, we detected hypernym (a more abstract term, \eg{} size 
      vs.\ length) and hyponym (a more concrete term, \eg{} restriction 
      vs.\ rule) renamings, and antonym renamings (a term replaced with one 
      having the opposite meaning, \eg{} closing vs.\ opening). Despite 
      being only a fraction of all renamings, synonym, hyponym, hypernym, 
      and antonym renamings may hint to some program understanding issues 
      and, thus, could be used in a renaming-recommendation system to 
      improve code quality.}
}

@MASTERSTHESIS{Abbes11-MSc,
   AUTHOR       = {Marwen Abbes},
   SCHOOL       = {Université de Montréal},
   TITLE        = {An Empirical Study of the Impact of Two Antipatterns On 
      Program Comprehension},
   YEAR         = {2011},
   OPTADDRESS   = {},
   MONTH        = {January},
   NOTE         = {M.Sc Informatique, Master degree},
   OPTTYPE      = {}
}

@ARTICLE{CepedaPorras10-EMSE-UMLNotations,
   AUTHOR       = {Cepeda Porras, Gerardo and Yann-Gaël Guéhéneuc},
   JOURNAL      = {Empirical Software Engineering (EMSE)},
   TITLE        = {An Empirical Study on the Efficiency of Different Design 
      Pattern Representations in UML Class Diagrams},
   YEAR         = {2010},
   MONTH        = {January},
   NOTE         = {27 pages.},
   NUMBER       = {5},
   OPTPAGES     = {},
   VOLUME       = {15},
   EDITOR       = {Lionel Briand},
   KEYWORDS     = {Understanding program comprehension, EMSE},
   PUBLISHER    = {Springer},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/EMSE10.doc.pdf},
   ABSTRACT     = {Design patterns are recognized in the software 
      engineering community as useful solutions to recurring design 
      problems that improve the quality of programs. They are more and more 
      used by developers in the design and implementation of their 
      programs. Therefore, the visualization of the design patterns used in 
      a program could be useful to efficiently understand how it works. 
      Currently, a common representation to visualize design patterns is 
      the UML collaboration notation. Previous work noticed some 
      limitations in this representation and proposed new representations 
      to tackle these limitations. However, none of these pieces of work 
      conducted empirical studies to compare their new representations with 
      this common representation. We designed and conducted an empirical 
      study to collect data on the performance of developers on basic tasks 
      related to design pattern comprehension to evaluate the impact of 
      three visual representations and to compare them with the common one. 
      We used eye-trackers to measure the developers' effort during the 
      execution of the study. Collected data show that there exists for 
      certain tasks a representation that is more efficient than the common 
      one. We also found tasks for which the common representation works 
      better.}
}

@ARTICLE{Cote09-CIN-VirtualIntervention,
   AUTHOR       = {José Côté and Pilar Ramirez-Garcia and Geneviève Rouleau and 
      Diane Saulnier and Yann-Gaël Guéhéneuc and Annick Hernandez and 
      Gaston Godin},
   JOURNAL      = {Computers, Informatics, Nursing (CIN)},
   TITLE        = {A Nursing Virtual Intervention: Real-Time Support for 
      Managing Antiretroviral Therapy},
   YEAR         = {2010},
   MONTH        = {November},
   NOTE         = {21 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   VOLUME       = {28},
   EDITOR       = {Leslie H. Nicoll},
   KEYWORDS     = {VIHTAVIE, CIN},
   PUBLISHER    = {Lippincott, Williams, and Wilkins},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CIN09.doc.pdf},
   ABSTRACT     = {Based on a philosophy of empowerment, we developed the 
      VIHTAVIE virtual intervention (HIV-Treatment, Virtual Nursing 
      Assistance and Education) to equip persons living with HIV for 
      managing with their daily antiretroviral therapies. In this article 
      we describe the VIHTAVIE project and the process of developing it, 
      which was carried out in three phases: 1) development of the 
      intervention's clinical content, 2) generation of a multimedia 
      presentation and 3) implementation of our web application via 
      computer interface. VIHTAVIE consists of four interactive sessions at 
      the computer, animated by a virtual nurse that takes the individual 
      through the learning process about the capabilities necessary for 
      taking the treatment. This information and strategies provided by the 
      virtual nurse are specifically adapted to the participant, according 
      to the responses he or she supplies. The VIHTAVIE approach, still 
      experimental, is intended to be complementary with the actual 
      clinical follow-up and has been developed in the context of 
      reorganizing services and of the scarcity of resources. While we 
      anticipate direct positive outcomes among the HIV clientele, it is 
      also highly probable that this virtual support application will have 
      ramifications among different clienteles who must also contend with 
      the daily challenges of their health conditions.}
}

@ARTICLE{Gueheneuc10-ESE-DesignPatterns,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   JOURNAL      = {Encyclopedia of Software Engineering (ESE)},
   TITLE        = {Design Patterns: Empirical Studies on the Impact of 
      Design Patterns on Quality},
   YEAR         = {2010},
   MONTH        = {September},
   NOTE         = {Under publication. 16 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Phil Laplante},
   KEYWORDS     = {Design patterns, ESE},
   PUBLISHER    = {Taylor and Francis Group},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ESE10.doc.pdf},
   ABSTRACT     = {Design patterns are a form of documentation that 
      proposes solutions to recurring object-oriented software design 
      problems. Design patterns became popular in software engineering 
      thanks to the book published in 1995 by the Gand of Four: Erich 
      Gamma, Richard Helm, Ralph Johnson and John Vlissides. Since the 
      publication of the book ``Design Patterns: Elements of Reusable 
      Object-Oriented Software'', design patterns have been used to design 
      programs and ease their maintenance, to teach object-oriented 
      concepts and related ``good'' practices in classrooms, to assess 
      quality and help program comprehension in research. However, design 
      patterns may also lead to over-engineered programs and may negatively 
      impact quality. We recall the history of design patterns and present 
      some recent development characterising the advantages and 
      disadvantages of design patterns.}
}

@ARTICLE{Gueheneuc10-SQJ-MetricalPtidejSolver,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Jean-Yves Guyomarc'h and 
      Houari Sahraoui},
   JOURNAL      = {Software Quality Journal (SQJ)},
   TITLE        = {Improving Design Pattern Identification: a New Approach 
      and an Exploratory Study},
   YEAR         = {2010},
   OPTMONTH     = {},
   NOTE         = {21 pages.},
   NUMBER       = {1},
   PAGES        = {145--166},
   VOLUME       = {18},
   KEYWORDS     = {Design patterns, SQJ},
   PUBLISHER    = {Springer},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/SQJ10.doc.pdf},
   ABSTRACT     = {The identification of occurrences of design patterns in 
      programs can help maintainers to understand the program design and 
      implementation. It can also help them to make informed changes. 
      Current identification approaches are limited to complete 
      occurrences, are time- and resource-consuming, and lead to many false 
      positives. We propose to combine a structural and a numerical 
      approach to improve the identification of complete and incomplete 
      occurrences of design patterns. We develop a structural approach 
      using explanation-based constraint programming and we enhance this 
      approach using experimentally-built numerical signatures. We show 
      that the use of numerical signatures improves the identification of 
      complete and incomplete occurrences in terms of performance and 
      precision.}
}

@ARTICLE{Kpodjedo10-JSME-ETGMEvolution,
   AUTHOR       = {Segla Kpodjedo and Filippo Ricca and Philippe Galinier and 
      Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   JOURNAL      = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
   TITLE        = {Studying Software Evolution of Large Object-oriented 
      Software Systems using an ETGM Algorithm},
   YEAR         = {2010},
   MONTH        = {September},
   NOTE         = {In press. 28 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Rudolf Ferenc and Andreas Winter and Jens Knodel},
   KEYWORDS     = {Evolution patterns, JSME},
   PUBLISHER    = {Wiley},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JSME10.doc.pdf},
   ABSTRACT     = {Analyzing and understanding the evolution of large 
      object-oriented software systems is an important but difficult task, 
      in which matching algorithms play a fundamental role. An 
      error-tolerant graph matching (ETGM) algorithm is able to identify 
      evolving classes that maintain a stable structure of relations 
      (associations, inheritances, and aggregations) with other classes and 
      that, thus, likely constitute the backbone of the system. Therefore, 
      we first develop a novel ETGM algorithm to study the evolution of 
      class diagrams. This algorithm improves the performance of our 
      previous algorithm. Second, we describe the process of building an 
      oracle to test and study our algorithm. Third, we report for the new 
      algorithm the impact of the algorithm parameters on the F-measure 
      summarizing precision and recall. Finally, with tuned algorithm 
      parameters, we carry out and report an extensive empirical evaluation 
      of our algorithm. Overall we show that: this novel algorithm is 
      scalable, stable and has better time performance. In our empirical 
      evaluation, we use small, \ie{} Rhino, medium, \ie{} Azureus and 
      ArgoUML, and large systems, \ie{} Mozilla and Eclipse.}
}

@ARTICLE{Kpodjedo10-EMSE-DesignEvolutionMetrics,
   AUTHOR       = {Segla Kpodjedo and Filippo Ricca and Philippe Galinier and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   JOURNAL      = {Empirical Software Engineering (EMSE)},
   TITLE        = {Design Evolution Metrics for Defect Prediction in Object 
      Oriented Systems},
   YEAR         = {2010},
   OPTMONTH     = {},
   NOTE         = {In press. 32 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Simon Poulding and Massimiliano Di Penta},
   KEYWORDS     = {Evolution patterns, EMSE},
   PUBLISHER    = {Springer},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/EMSE10.doc.pdf},
   ABSTRACT     = {Testing is the most widely adopted practice to ensure 
      software quality. However, this activity is often a compromise 
      between the available resources and software quality. In 
      object-oriented development, testing effort should be focused on 
      defective classes. Unfortunately, identifying those classes is a 
      challenging and difficult activity on which many metrics, techniques, 
      and models have been tried. In this paper, we investigate the 
      usefulness of elementary design evolution metrics to identify 
      defective classes. The metrics include the numbers of added, deleted, 
      and modified attributes, methods, and relations. The metrics are used 
      to recommend a ranked list of classes likely to contain defects for a 
      system. They are compared to Chidamber and Kemerer's metrics on 
      several versions of Rhino and of ArgoUML. Further comparison is 
      conducted with the complexity metrics computed by Zimmermann 
      \textit{et al.} on several releases of Eclipse. The comparisons are 
      made according to three criteria: presence of defects, number of 
      defects, and defect density in the top-ranked classes. They show that 
      the design evolution metrics, when used in conjunction with known 
      metrics, improve the identification of defective classes. In 
      addition, they show that the design evolution metrics make 
      significantly better predictions of defect density than other metrics 
      and, thus, can help in reducing the testing effort by focusing test 
      activity on a reduced volume of code.}
}

@ARTICLE{Mens10-IEEESoftwareGuestIntroduction,
   AUTHOR       = {Tom Mens and Yann-Gaël Guéhéneuc and 
      Juan Fernandez-Ramil and Maja D'Hondt},
   JOURNAL      = {IEEE Software},
   TITLE        = {Guest Editor's Introduction: Software Evolution},
   YEAR         = {2010},
   MONTH        = {July--August},
   NOTE         = {4 pages.},
   NUMBER       = {4},
   PAGES        = {22--25},
   VOLUME       = {27},
   KEYWORDS     = {Evolution patterns, IEEE Software},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IEEESoftware10.doc.pdf}
}

@ARTICLE{Moha09-TSE-DECOR,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc and Laurence Duchien and 
      Le Meur, Anne-Françoise},
   JOURNAL      = {Transactions on Software Engineering (TSE)},
   TITLE        = {DECOR: A Method for the Specification and Detection of 
      Code and Design Smells},
   YEAR         = {2010},
   MONTH        = {January--February},
   NOTE         = {16 pages.},
   NUMBER       = {1},
   OPTPAGES     = {},
   VOLUME       = {36},
   EDITOR       = {Mark Harman},
   KEYWORDS     = {Code and design smells, TSE},
   PUBLISHER    = {IEEE Computer Society Press},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TSE09.doc.pdf},
   ABSTRACT     = {Code and design smells are poor solutions to recurring 
      implementation and design problems. They may hinder the evolution of 
      a system by making it hard for software engineers to carry out 
      changes. We propose three contributions to the research field related 
      to code and design smells: (1) DECOR, a method that embodies and 
      defines all the steps necessary for the specification and detection 
      of code and design smells; (2) \DEX{} a detection technique that 
      instantiates this method; and (3) an empirical validation in terms of 
      precision and recall of \DEX. The originality of \DEX{} stems from 
      the ability for software engineers to specify smells at a high-level 
      of abstraction using a consistent vocabulary and domain-specific 
      language for automatically generating detection algorithms. Using 
      \DEX{}, we specify four well-known design smells: the antipatterns 
      Blob, Functional Decomposition, Spaghetti Code, and Swiss Army Knife, 
      and their 15 underlying code smells, and we automatically generate 
      their detection algorithms. We apply and validate the detection 
      algorithms in terms of precision and recall on \product{Xerces} 
      v2.7.0, and discuss the precision of these algorithms on 11 
      open-source systems.}
}

@ARTICLE{Moha09-FACS-DDDomainAnalysis,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc and 
      Le Meur, Anne-Françoise and Laurence Duchien and Alban Tiberghien},
   JOURNAL      = {Formal Aspects of Computing (FAC)},
   TITLE        = {From a Domain Analysis to the Specification and 
      Detection of Code and Design Smells},
   YEAR         = {2010},
   MONTH        = {May},
   NOTE         = {23 pages.},
   NUMBER       = {3},
   PAGES        = {345--368},
   VOLUME       = {22},
   EDITOR       = {José Luiz Fiadeiro},
   KEYWORDS     = {Code and design smells, FACS},
   PUBLISHER    = {Springer},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/FACS09.doc.pdf},
   ABSTRACT     = {Code and design smells are recurring design problems in 
      software systems that need to be identified to avoid their possible 
      negative consequences in development and maintenance. Consequently, 
      several smell detection approaches and tools have been proposed in 
      the literature. However, so far, they allow the detection of 
      predefined smells but the detection of new smells or smells adapted 
      to the context of the analysed systems is possible only by 
      implementing new detection algorithms manually. Moreover, previous 
      approaches do not explain the transition from specifications of 
      smells to their detection. Finally, the validation of the existing 
      detection approaches and tools has been limited on few proprietary 
      systems and on a reduced number of smells. In this paper, we 
      introduce an approach to automate the generation of detection 
      algorithms from specifications written using a domain-specific 
      language. This language is defined from a thorough domain analysis. 
      It allows the specification of smells using high-level domain-related 
      abstractions. It allows the adaptation of the specifications of 
      smells to the context of the analysed systems. We specify 10 smells, 
      generate automatically their detection algorithms using templates, 
      and validate the algorithms in terms of precision and recall on 
      \ygg@product{Xerces} v2.7.0 and \ygg@product{GanttProject} v1.10.2, 
      two open-source object-oriented systems.}
}

@ARTICLE{Sahraoui10-S-IST-ImpactMeasurementProgram,
   AUTHOR       = {Houari Sahraoui and Lionel C. Briand and 
      Yann-Gaël Guéhéneuc and Olivier Beaurepaire},
   JOURNAL      = {Information and Software Technology (IST)},
   TITLE        = {Investigating the Impact of a Measurement Program on 
      Software Quality},
   YEAR         = {2010},
   OPTMONTH     = {},
   NOTE         = {In press. 33 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Claes Wohlin},
   KEYWORDS     = {Quality models, IST},
   PUBLISHER    = {Elsevier},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IST10.doc.pdf},
   ABSTRACT     = {Measurement programs have been around for several 
      decades but have been often misused or misunderstood by managers and 
      developers. This misunderstanding prevented their adoption despite 
      their many advantages. In this paper, we present the results of an 
      empirical study on the impact of a measurement program, MQL, in an 
      industrial context. We analyzed data collected on 44 systems of 
      different sizes: 22 systems were developed using MQL while the other 
      22 did not use a specific measurement program (control group). We 
      studied the impact of MQL on a set of quality indicators. Our results 
      show that MQL had a clearly positive impact on all the studied 
      indicators. This impact is statistically significant for all the 
      indicators but corrective maintenance effort. We therefore bring 
      concrete evidence that a measurement program can have a significant, 
      positive impact on the quality of software systems if combined with 
      appropriate decision making procedures and corrective actions.}
}

@INPROCEEDINGS{Arnaoudova10-ICSM-ERA-IdentifierEntropy,
   AUTHOR       = {Venera Arnaoudova and Laleh Eshkevari and Rocco Oliveto and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 26<sup>th</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {Physical and Conceptual Identifier Dispersion: Measures 
      and Relation to Fault Proneness},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Denys Poshyvanyk},
   MONTH        = {September},
   NOTE         = {Early Research Achievements Track. Best paper. 5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM10a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM10a.ppt.pdf},
   ABSTRACT     = {Poorly-chosen identifiers have been reported in the 
      literature as misleading and increasing the program comprehension 
      effort. Identifiers are composed of terms, which can be dictionary 
      words, acronyms, contractions, or simple strings. We conjecture that 
      the use of identical terms in different contexts may increase the 
      risk of faults. We investigate our conjecture using a measure 
      combining term entropy and term context coverage to study whether 
      certain terms increase the odds ratios of methods to be fault-prone. 
      Entropy measures the \emph{physical dispersion} of terms in a 
      program: the higher the entropy, the more scattered across the 
      program the terms. Context coverage measures the \emph{conceptual 
      dispersion} of terms: the higher their context coverage, the more 
      unrelated the methods using them. We compute term entropy and context 
      coverage of terms extracted from identifiers in Rhino 1.4R3 and 
      ArgoUML 0.16. We show statistically that methods containing terms 
      with high entropy and context coverage are more fault-prone than 
      others.}
}

@INPROCEEDINGS{Asadi10-SSBSE-ComparisonDistributedArchitectures,
   AUTHOR       = {Fatemeh Asadi and Giuliano Antoniol and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 2<sup>nd</sup> International Symposium on Search Based Software Engineering (SSBSE)},
   TITLE        = {Concept Location with Genetic Algorithms: A Comparison 
      of Four Distributed Architectures},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Lionel Briand},
   MONTH        = {September},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, SSBSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/SSBSE10.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/SSBSE10.ppt.pdf},
   ABSTRACT     = {Genetic algorithms are attractive to solve many 
      search-based software engineering problems because they allow the 
      easy parallelization of computations, which improves scalability and 
      reduces computation time. In this paper, we present our experience in 
      applying different distributed architectures to parallelize a genetic 
      algorithm used to solve the concept identification problem. We 
      developed an approach to identify concepts in execution traces by 
      finding cohesive and decoupled fragments of the traces. The approach 
      relies on a genetic algorithm, on a textual analysis of source code 
      using latent semantic indexing, and on trace compression techniques. 
      The fitness function in our approach has a polynomial evaluation cost 
      and is highly computationally intensive. A run of our approach on a 
      trace of thousand methods may require several hours of computation on 
      a standard PC. Consequently, we reduced computation time by 
      parallelizing the genetic algorithm at the core of our approach over 
      a standard TCP/IP network. We developed four distributed 
      architectures and compared their performances: we observed a decrease 
      of computation time up to 140 times. Although presented in the 
      context of concept location, our findings could be applied to many 
      other search-based software engineering problems.}
}

@INPROCEEDINGS{Asadi10-CSMR-IdentifyConceptsTraces,
   AUTHOR       = {Fatemeh Asadi and Di Penta, Massimiliano and 
      Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {A Heuristic-based Approach to Identify Concepts in 
      Execution Traces},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Juan Carlos Dueñas},
   MONTH        = {March},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10a.ppt.pdf},
   ABSTRACT     = {Concept or feature identification, \ie{} the 
      identification of the source code fragments implementing a particular 
      feature, is a crucial task during software understanding and 
      maintenance. This paper proposes an approach to identify concepts in 
      execution traces by finding cohesive and decoupled fragments of the 
      traces. The approach relies on search-based optimization techniques, 
      textual analysis of the system source code using latent semantic 
      indexing, and trace compression techniques. It is evaluated to 
      identify features from execution traces of two open source systems 
      from different domains, JHotDraw and ArgoUML. Results show that the 
      approach is always able to identify trace segments implementing 
      concepts with a high precision and, for highly cohesive concepts, 
      with a high overlap with the manually-built oracle.}
}

@INPROCEEDINGS{Bavota10-ICSM-ERA-RefactoringGameTheory,
   AUTHOR       = {Gabriele Bavota and Rocco Oliveto and Andrea De Lucia and 
      Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 26<sup>th</sup> 26th IEEE International Conference on Software Maintenance (ICSM)},
   TITLE        = {Playing with Refactoring: Identifying Extract Class 
      Opportunities through Game Theory},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Denys Poshyvanyk},
   MONTH        = {September},
   NOTE         = {Early Research Achievements Track. 5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM10b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM10b.ppt.pdf},
   ABSTRACT     = {In software engineering, developers must often find 
      solutions to problems balancing competing goals, e.g., quality versus 
      cost, time to market versus resources, or cohesion versus coupling. 
      Finding a suitable balance between contrasting goals is often complex 
      and recommendation systems are useful to support developers and 
      managers in performing such a complex task. We believe that 
      contrasting goals can be often dealt with game theory techniques. 
      Indeed, game theory is successfully used in other fields, especially 
      in economics, to mathematically propose solutions to strategic 
      situation, in which an individual's success in making choices depends 
      on the choices of others. To demonstrate the applicability of game 
      theory to software engineering and to understand its pros and cons, 
      we propose an approach based on game theory that recommend 
      extract-class refactoring opportunities. A preliminary evaluation 
      inspired by mutation testing demonstrates the applicability and the 
      benefits of the proposed approach.}
}

@INPROCEEDINGS{Cote10-ACFAS-ModeVirtuel,
   AUTHOR       = {José Côté and Geneviève Rouleau and Diane Saulnier and 
      Cécile Tremblay and Hélène Morin and Pilar Ramirez-Garcia and 
      Yann-Gaël Guéhéneuc and Gaston Godin and Joanne Otis},
   BOOKTITLE    = {actes du 78<sup>e</sup> congrès de l'ACFAS},
   TITLE        = {Découvrir aujourd'hui, réinventer demain ! Le mode 
      virtuel : une voie prometteuse pour le soutien des clientèles dans 
      l'autogestion de leur condition de santé},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Christine Thoer and Joseph Levy},
   MONTH        = {mai},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACFAS},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {VIHTAVIE, ACFAS},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ACFAS10.doc.pdf},
   ABSTRACT     = {Bas\'ee sur une philosophie d'empowerment, VIH-TAVIE 
      (VIH - Traitement, Assistance Virtuelle Infirmi\`ere et Enseignement) 
      vise \`a outiller la personne vivant avec le VIH (PVVIH) dans la 
      gestion quotidienne de ses antir\'etroviraux. Le but de cette 
      communication est de faire une d\'emonstration de VIH-TAVIE et de 
      pr\'esenter les r\'esultats pr\'eliminaires sur l'acceptabilit\'e et 
      la faisabilit\'e de VIH-TAVIE.}
}

@INPROCEEDINGS{DiPenta10-ICSE-SoftwareLicensingEvolution,
   AUTHOR       = {Di Penta, Massimiliano and Daniel M. German and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 32<sup>nd</sup> International Conference on Software Engineering (ICSE)},
   TITLE        = {An Exploratory Study of the Evolution of Software 
      Licensing},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Prem Devanbu and Sebastian Uchitel},
   MONTH        = {May},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, ICSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSE10a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSE10a.ppt.pdf},
   ABSTRACT     = {ree and open source software systems (FOSS) are 
      distributed and made available to users under different software 
      licenses, mentioned in FOSS code by means of licensing statements. 
      Various factors, such as changes in the legal landscape, commercial 
      code licensed as FOSS, or code reused from other FOSS systems, lead 
      to evolution of licensing, which may affect the way a system or part 
      thereof can be subsequently used. Therefore, it is crucial to monitor 
      licensing evolution. However, manually tracking the licensing 
      evolution of thousands of files is a daunting task. After presenting 
      several cases of the effects of licensing evolution, we argue that 
      developers and system integrators must monitor licensing evolution 
      and they need an automatic approach due to the sheer size of FOSS 
      systems. We propose an approach to automatically track changes 
      occurring in the licensing terms of a system and report an empirical 
      study of the licensing evolution of six different FOSS systems. 
      Results show that licensing underwent frequent and substantial 
      changes.}
}

@INPROCEEDINGS{Hassaine10-QUATIC-IDS,
   AUTHOR       = {Salima Hassaine and Foutse Khomh and Yann-Gaël Guéhéneuc and 
      Sylvie Hamel},
   BOOKTITLE    = {Proceedings of the 7<sup>th</sup> International Conference on the Quality of Information and Communications Technology (QUATIC)},
   TITLE        = {IDS: An Immune-inspired Approach for the Detection of 
      Software Design Smells},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mel Ó Cinnéide},
   MONTH        = {September--October},
   NOTE         = {Quality in ICT Reengineering and Refactoring Track. 6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, QUATIC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/QUATIC10.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/QUATIC10.ppt.pdf},
   ABSTRACT     = {We propose a parallel between object-oriented system 
      designs and living creatures. We suggest that, like any living 
      creature, system designs are subject to diseases, which are design 
      smells (code smells and antipatterns). Design smells are conjectured 
      in the literature to impact the quality and life of systems and, 
      therefore, their detection has drawn the attention of both 
      researchers and practitioners with various approaches. With our 
      parallel, we propose a novel approach built on models of the immune 
      system responses to pathogenic material. We show that our approach 
      can detect more than one smell at a time. We build and test our 
      approach on GanttProject v1.10.2 and Xerces v2.7.0, for which 
      manually-validated and publicly-available smells exist. The results 
      show a significant improvement in detection time, precision, and 
      recall, in comparison to the state--of--the--art approaches.}
}

@INPROCEEDINGS{Kniesel10-CSMR-DPDX,
   AUTHOR       = {Günter Kniesel and Alexander Binun and Péter Hegedus and 
      Lajos Jeno Fülöp and Alexander Chatzigeorgiou and Yann-Gaël Guéhéneuc and 
      Nikolaos Tsantalis},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {DPDX -- A Common Exchange Format for Design Pattern 
      Detection Tools},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Juan Carlos Dueñas},
   MONTH        = {March},
   NOTE         = {Short paper. 5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10b.ppt.pdf},
   ABSTRACT     = {Tools for design pattern detection (DPD) can 
      significantly ease program comprehension, helping programmers 
      understand the design and intention of certain parts of a system's 
      implementation. Many tools have been proposed in the past. However, 
      the many different output formats used by the tools make it difficult 
      to compare their results and to improve their accuracy and 
      performance through data fusion. In addition, all the output formats 
      have been shown to have several limitations in both their forms and 
      contents. Consequently, we develop DPDX, a rich common exchange 
      format for DPD tools, to overcome previous limitations. DPDX provides 
      the basis for an open federation of tools that perform comparison, 
      fusion, visualisation, and--or validation of DPD results. In the 
      process of building the format, we also clarify some central notions 
      of design patterns that lacked a common, generally accepted 
      definitions, and thus provide a sound common foundation and 
      terminology for DPD.}
}

@INPROCEEDINGS{Madani10-CSMR-IdentifiersSpeechRecognition,
   AUTHOR       = {Nioosha Madani and Latifa Guerrouj and 
      Di Penta, Massimiliano and Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {Recognizing Words from Source Code Identifiers using 
      Speech Recognition Techniques},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Juan Carlos Dueñas},
   MONTH        = {March},
   NOTE         = {Best paper. 10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Understanding program comprehension, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10c.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10c.ppt.pdf},
   ABSTRACT     = {The existing software engineering literature has 
      empirically shown that a proper choice of identifiers influences 
      software understandability and maintainability. Researchers have 
      noticed that identifiers are one of the most important source of 
      information about program entities and that the semantic of 
      identifiers guide the cognitive process. Recognizing the words 
      forming identifiers is not an easy task when naming conventions 
      (\eg{} Camel Case) are not used or strictly followed and--or when 
      these words have been abbreviated or otherwise transformed. This 
      paper proposes a technique inspired from speech recognition, \ie{} 
      dynamic time warping, to split identifiers into component words. The 
      proposed technique has been applied to identifiers extracted from two 
      different applications: JHotDraw and Lynx. Results compared to 
      manually-built oracles and with Camel Case algorithm are encouraging. 
      In fact, they show that the technique successfully recognize words 
      composing identifiers (even when abbreviated) in about 90\% of cases 
      and that it performs better than Camel Case. Furthermore, it was able 
      to spot mistakes in the manually-built oracle.}
}

@INPROCEEDINGS{Oliveto10-CSMR-BSplineSmellDetection,
   AUTHOR       = {Rocco Oliveto and Foutse Khomh and Giuliano Antoniol and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> European Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {Numerical Signatures of Antipatterns: An Approach based 
      on B-Splines},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rudolf Ferenc and Juan Carlos Dueñas},
   MONTH        = {March},
   NOTE         = {Short paper. 5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10d.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR10d.ppt.pdf},
   ABSTRACT     = {Antipatterns are poor object-oriented solutions to 
      recurring design problems. The identification of occurrences of 
      antipatterns in systems has received recently some attention but 
      current approaches have two main limitations: either (1) they 
      classify classes strictly as being or not antipatterns, and thus 
      cannot report accurate information for borderline classes, or (2) 
      they return the probabilities of classes to be antipatterns but they 
      require an expensive tuning by experts to have acceptable accuracy. 
      To mitigate such limitations, we introduce a new identification 
      approach, ABS (Antipattern identification using B-Splines), based on 
      a numerical analysis technique. The results of a preliminary study 
      show that ABS generally outperforms previous approaches in terms of 
      accuracy when used to identify Blobs.}
}

@INPROCEEDINGS{Wu10-ICSE-AURA,
   AUTHOR       = {Wei Wu and Yann-Gaël Guéhéneuc and Giuliano Antoniol and 
      Miryung Kim},
   BOOKTITLE    = {Proceedings of the 32<sup>nd</sup> International Conference on Software Engineering (ICSE)},
   TITLE        = {AURA: A Hybrid Approach to Identify Framework Evolution},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Prem Devanbu and Sebastian Uchitel},
   MONTH        = {May},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, ICSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSE10b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSE10b.ppt.pdf},
   ABSTRACT     = {Software frameworks and libraries are indispensable to 
      today's software systems. As they evolve, it is often time-consuming 
      for developers to keep their code up-to-date, so approaches have been 
      proposed to facilitate this. Usually, these approaches cannot 
      automatically identify change rules for one-replaced-by-many and 
      many-replaced-by-one methods, and they trade off recall for higher 
      precision using one or more experimentally-evaluated thresholds. We 
      introduce AURA, a novel hybrid approach that combines call dependency 
      and text similarity analyses to overcome these limitations. We 
      implement it in a Java system and compare it on five frameworks with 
      three previous approaches by Dagenais and Robillard, M.\ Kim 
      \ygg@latin{et al.}, and Sch\"afer \ygg@latin{et al.} The comparison 
      shows that, on average, the recall of AURA is 53.07\% higher while 
      its precision is similar, \ygg@latin{e.g.}, 0.10\% lower.}
}

@INBOOK{Charest09-PatternsHardware,
   PUBLISHER    = {CRC Press},
   TITLE        = {Translating Design Pattern Concepts to Hardware Concepts},
   YEAR         = {2009},
   AUTHOR       = {Luc Charest and Yann-Gaël Guéhéneuc and Yousra Tagmouti},
   CHAPTER      = {4},
   EDITOR       = {El Mostapha Aboulhamid and Frédéric Rousseau},
   PAGES        = {93--118},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   MONTH        = {September},
   NOTE         = {25 pages.},
   OPTNUMBER    = {},
   OPTSERIES    = {},
   OPTTYPE      = {},
   OPTVOLUME    = {},
   BOOKTITLE    = {System Level Design with .Net Technology},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/NET09.doc.pdf},
   ABSTRACT     = {For half a century, hardware systems have become 
      increasingly complex and pervasive. They are not only found in 
      satellite navigation systems or automated factory machinery but also 
      in everyday cell-phone, parc-o-meter, and car control-and-command 
      systems. This increase in the use of hardware systems led to a 
      revolution in their design and implementation: the chips are becoming 
      more and more powerful, their logics is implemented as software 
      systems executed by the chips, thus helping system designers to cope 
      with their complexity. These \emph{mixed hardware--software systems} 
      raise the level of generality of the ``hardware part'' and the level 
      of abstraction of the ``software part'' of the systems. Thus, they 
      suggest that mainstream software engineering techniques and good 
      practices, such as design patterns, could be used by system designers 
      to design and implement their mixed hardware--software systems. This 
      chapter presents a proof of concept on ``translating'' the solutions 
      of design patterns into hardware concepts to alleviate the system 
      designers' work and, thus, to accelerate the design of mixed 
      hardware--software systems. This chapter opens the path towards a new 
      kind of hardware synthesis.}
}

@ARTICLE{Gueheneuc08-JSSCI-VisionTheory,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   JOURNAL      = {International Journal of Software Science and Computational Intelligence (IJSSCI)},
   TITLE        = {A Theory of Program Comprehension---Joining Vision 
      Science and Program Comprehension},
   YEAR         = {2009},
   MONTH        = {April-June},
   NOTE         = {47 pages.},
   NUMBER       = {2},
   OPTPAGES     = {},
   VOLUME       = {1},
   EDITOR       = {Yingxu Wang},
   KEYWORDS     = {Understanding program comprehension, JSSCI},
   PUBLISHER    = {IGI Global},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JSSCI09.doc.pdf},
   ABSTRACT     = {There exists an extensive literature on vision science, 
      on the one hand, and on program comprehension, on the other hand. 
      However, these two domains of research have been so far rather 
      disjoint. Indeed, several cog- nitive theories have been proposed to 
      explain program comprehension. These theories explain the processes 
      taking place in the software engi- neers' minds when they understand 
      programs. They explain how software engineers process available 
      information to perform their tasks but not how software engineers 
      acquire this information. Vision science provides ex- planations on 
      the processes used by people to acquire visual information from their 
      environment. Joining vision science and program comprehen- sion 
      provides a more comprehensive theoretical framework to explain facts 
      on program comprehension, to predict new facts, and to frame experi- 
      ments. We join theories in vision science and in program 
      comprehension; the resulting theory is consistent with facts on 
      program comprehension and helps in predicting new facts, in devising 
      experiments, and in putting certain program comprehension concepts in 
      perspective.}
}

@ARTICLE{Kaczor09-IST-EfficientDPIdentification,
   AUTHOR       = {Olivier Kaczor and Yann-Gaël Guéhéneuc and Sylvie Hamel},
   JOURNAL      = {Information and Software Technology (IST)},
   TITLE        = {Identification of Design Motifs with Pattern Matching 
      Algorithms},
   YEAR         = {2009},
   MONTH        = {August},
   NOTE         = {46 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Claes Wohlin},
   KEYWORDS     = {Design patterns, IST},
   PUBLISHER    = {Elsevier},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IST09.doc.pdf},
   ABSTRACT     = {Design patterns are important in software maintenance 
      because they help in understanding and re-engineering systems. They 
      propose design motifs, solutions to recurring design problems. The 
      identification of occurrences of design motifs in large systems 
      consists of identifying classes whose structure and organization 
      match exactly or approximately the structure and organization of 
      classes as suggested by the motif. We adapt two classical approximate 
      string matching algorithms based on automata simulation and 
      bit-vector processing to efficiently identify exact and approximate 
      occurrences of motifs. We then carry out two case studies to show the 
      performance, precision, and recall of our algorithms. In the first 
      case study, we assess the performance of our algorithms on seven 
      medium-to-large systems. In the second case study, we compare our 
      approach with three existing approaches (an explanation-based 
      constraint approach, a metric-enhanced explanation-based constraint 
      approach, and a similarity scoring approach) by applying the 
      algorithms on three small-to-medium size systems, \JHotDraw{}, 
      \ygg@product{Juzzle}, and \ygg@product{QuickUML}. Our studies show 
      that approximate string matching based on bit-vector processing 
      provides efficient algorithms to identify design motifs.}
}

@ARTICLE{KaYeeNg09-JSME-BehaviouralCreationalIdentification,
   AUTHOR       = {Janice Ka-Yee Ng and Yann-Gaël Guéhéneuc and 
      Giuliano Antoniol},
   JOURNAL      = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
   TITLE        = {Identification of Behavioral and Creational Design 
      Motifs through Dynamic Analysis},
   YEAR         = {2009},
   MONTH        = {November},
   NOTE         = {30 pages.},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   EDITOR       = {Maria Tortorella and Aniello Cimitile},
   KEYWORDS     = {Design patterns, JSME},
   PUBLISHER    = {Wiley},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JSME09.doc.pdf},
   ABSTRACT     = {Design patterns offer design motifs, solutions to 
      object-oriented design problems. Design motifs lead to 
      well-structured designs and thus are believed to ease software 
      maintenance. However, after use, they are often ``lost" and are 
      consequently of little help during program comprehension and other 
      maintenance activities. Therefore, several works proposed design 
      pattern identification approaches to recover occurrences of the 
      motifs. These approaches mainly used the structure and organisation 
      of classes as input. Consequently, they have a low precision when 
      considering behavioural and creational motifs, which pertain to the 
      assignment of responsibilities and the collaborations among objects 
      at runtime. We propose MoDeC, an approach to describe behavioral and 
      creational motifs as collaborations among objects in the form of 
      scenario diagrams. We identify these motifs using dynamic analysis 
      and constraint programming. Using a proof-of-concept implementation 
      of MoDeC and different scenarios for five other Java{} programs and 
      \textsf{Builder}, \textsf{Command}, and \textsf{Visitor}, we show 
      that MoDeC has a better precision than a state-of-the-art static 
      approaches.}
}

@INPROCEEDINGS{German09-MSR-CodeSiblings,
   AUTHOR       = {Daniel M. German and Di Penta, Massimiliano and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 6<sup>th</sup> Working Conference on Mining Software Repositories (MSR)},
   TITLE        = {Code Siblings: Technical and Legal Implications of 
      Copying Code between Systems},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Michael W. Godfrey and Jim Whitehead},
   MONTH        = {May},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, MSR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/MSR09.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/MSR09.ppt.pdf},
   ABSTRACT     = {Source code cloning does not happen within a single 
      system only. It can also occur between one system and another. We use 
      the term code sibling to refer to a code clone that evolves in a 
      different system than the code from which it originates. Code 
      siblings can only occur when the source code copyright owner allows 
      it and when the conditions imposed by such license are not 
      incompatible with the license of the destination system. In some 
      situations copying of source code fragments are 
      allowed---legally---in one direction, but not in the other. In this 
      paper, we use clone detection, license mining and classification, and 
      change history techniques to understand how code siblings---under 
      different licenses---flow in one direction or the other between Linux 
      and two BSD Unixes, FreeBSD and OpenBSD. Our results show that, in 
      most cases, this migration appears to happen according to the terms 
      of the license of the original code being copied, favoring always 
      copying from less restrictive licenses towards more restrictive ones. 
      We also discovered that sometimes code is inserted to the kernels 
      from an outside source.}
}

@INPROCEEDINGS{Jeanmart09-ESEM-VisitorImpact,
   AUTHOR       = {Sébastien Jeanmart and Yann-Gaël Guéhéneuc and 
      Houari Sahraoui and Naji Habra},
   BOOKTITLE    = {Proceedings of the 3<sup>rd</sup> International Symposium on Empirical Software Engineering and Measurement (ESEM)},
   TITLE        = {Impact of the Visitor Pattern on Program Comprehension 
      and Maintenance},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {James Miller and Rick Selby},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Understanding program comprehension, ESEM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ESEM09.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ESEM09.ppt.pdf},
   ABSTRACT     = {In the software engineering literature, many works claim 
      that the use of design patterns improves the comprehensibility of 
      programs and, more generally, their maintainability. Yet, little work 
      attempted to study the impact of design patterns on the developers' 
      tasks of program comprehension and modification. We design and 
      perform an experiment to collect data on the impact of the Visitor 
      pattern on comprehension and modification tasks with class diagrams. 
      We use an eye-tracker to register saccades and fixations, the latter 
      representing the focus of the developers' attention. Collected data 
      show that the Visitor pattern plays a role in maintenance tasks: 
      class diagrams with its canonical representation requires less 
      efforts from developers.}
}

@INPROCEEDINGS{Khomh09-WCRE-CodeSmellsChanges,
   AUTHOR       = {Foutse Khomh and Di Penta, Massimiliano and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> Working Conference on Reverse Engineering (WCRE)},
   TITLE        = {An Exploratory Study of the Impact of Code Smells on 
      Software Change-proneness},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Giuliano Antoniol and Andy Zaidman},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, WCRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE09a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE09a.ppt.pdf},
   ABSTRACT     = {Code smells are poor implementation choices, thought to 
      make object-orien\-ted systems hard to maintain. In this study, we 
      investigate if classes with code smells are more change-prone than 
      classes without smells. Specifically, we test the general hypothesis: 
      classes with code smells are not more change prone than other 
      classes. We detect \numberofsmells{} code smells in 9 releases of 
      Azureus and in 13 releases of Eclipse, and study the relation between 
      classes with these code smells and class change-proneness. We show 
      that, in almost all releases of Azureus and Eclipse, classes with 
      code smells are more change-prone than others, and that specific 
      smells are more correlated than others to change-proneness. These 
      results justify \emph{a posteriori} previous work on the 
      specification and detection of code smells and could help focusing 
      quality assurance and testing activities.}
}

@INPROCEEDINGS{Khomh09-ICSM-DPRoles,
   AUTHOR       = {Foutse Khomh and Yann-Gaël Guéhéneuc and 
      Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 25<sup>th</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {Playing Roles in Design Patterns: An Empirical 
      Descriptive and Analytic Study},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Kostas Kontogiannis and Tao Xie},
   MONTH        = {September},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM09.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM09.ppt.pdf},
   ABSTRACT     = {This work presents a descriptive and analytic study of 
      classes playing zero, one, or two roles in six different design 
      patterns (and combinations thereof). First, we answer three research 
      questions showing that (1) playing roles in design patterns is not a 
      all-or-nothing characteristic of classes and that there are 
      significant differences among the (2) internal and (3) external 
      characteristics of classes playing zero, one, or two roles. Second, 
      we revisit a previous work on design patterns and changeability and 
      show that its results were, in a great part, due to classes playing 
      two roles. Third, we exemplify the use of the study results to 
      provide a ranking of the occurrences of the design patterns 
      identified in a program. The ranking allows developers to balance 
      precision and recall as they see fit.}
}

@INPROCEEDINGS{Khomh09-QSIC-BayesianDD,
   AUTHOR       = {Foutse Khomh and Stéphane Vaucher and 
      Yann-Gaël Guéhéneuc and Houari Sahraoui},
   BOOKTITLE    = {Proceedings of the 9<sup>th</sup> International Conference on Quality Software (QSIC)},
   TITLE        = {A Bayesian Approach for the Detection of Code and Design 
      Smells},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Choi Byoung-ju},
   MONTH        = {August},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, QSIC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/QSIC09.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/QSIC09.ppt.pdf},
   ABSTRACT     = {The presence of code and design smells can have a severe 
      impact on the quality of a program. Consequently, their detection and 
      correction have drawn the attention of both researchers and 
      practitioners who have proposed various approaches to detect code and 
      design smells in programs. However, none of these approaches handle 
      the inherent uncertainty of the detection process. We propose a 
      Bayesian approach to manage this uncertainty. First, we present a 
      systematic process to convert existing state-of-the-art detection 
      rules into a probabilistic model. We illustrate this process by 
      generating a model to detect occurrences of the Blob antipattern. 
      Second, we present results of the validation of the model: we built 
      this model on two open-source programs, \product{GanttProject 
      v1.10.2} and \product{Xerces v2.7.0}, and measured its accuracy. 
      Third, we compare our model with another approach to show that it 
      returns the same candidate classes while ordering them to minimise 
      the quality analysts' effort. Finally, we show that when past 
      detection results are available, our model can be calibrated using 
      machine learning techniques to offer an improved, context-specific 
      detection.}
}

@INPROCEEDINGS{Vaucher09-WCRE-CurePreventionSmells,
   AUTHOR       = {Stéphane Vaucher and Foutse Khomh and Naouel Moha and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> Working Conference on Reverse Engineering (WCRE)},
   TITLE        = {Prevention and Cure of Software Defects: Lessons from 
      the Study of God Classes},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Giuliano Antoniol and Andy Zaidman},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, Quality models, WCRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE09b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE09b.ppt.pdf},
   ABSTRACT     = {``God class'' is a term used to describe certain types 
      of large classes which ``know too much or do too much". Often a God 
      class(\GC{}) is created by accident as incremental functionality is 
      added to a central class over the course of several versions. \GC{}s 
      are generally thought to be examples of bad code that should be 
      detected and removed to ensure software quality. However, in some 
      cases, a \GC{} is created by design as the best solution to a 
      particular problem because, \eg{} the problem is not easily 
      decomposable or strong requirements on efficiency are imposed. In 
      this paper we study, in two open-source systems, the ``life cycle" of 
      \GC{}s: how they arise, how prevalent are they, and whether they 
      remain or are they removed as the systems evolve over time through a 
      number of versions. We show how to detect the degree of ``godliness" 
      in classes automatically. Then we show that by identifying the 
      evolution of ``godliness" we can distinguish between those that are 
      so by design (good code) from those that occurred by accident (bad 
      code). This methodology will allow software quality teams to 
      implement prevention and correction mechanisms.}
}

@TECHREPORT{Khomh09-TR-AntipatternsChangeability,
   AUTHOR       = {Foutse Khomh and Di Penta, Massimiliano and 
      Yann-Gaël Guéhéneuc and Guiliano Antoniol},
   INSTITUTION  = {École Polytechnique de Montréal},
   TITLE        = {An Exploratory Study of the Impact of Antipatterns on 
      Software Changeability},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   NOTE         = {15 pages.},
   NUMBER       = {EPM-RT-2009-02},
   OPTTYPE      = {},
   KEYWORDS     = {Code and design smells, Evolution patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Antipatterns+Changeability+April09.doc.pdf},
   ABSTRACT     = {Antipatterns are poor design choices that make 
      object-orien\-ted systems hard to maintain by developers. In this 
      study, we investigate if classes that participate in antipatterns are 
      more change-prone than classes that do not. Specifically, we test the 
      general hypothesis: classes belonging to antipatterns are not more 
      likely than other classes to undergo chan\-ges, to be impacted when 
      fixing issues posted in issue-tracking systems, and in particular to 
      unhandled excep\-tions-related issues---a crucial problem for any 
      software system. We detect 11 antipatterns in 13 releases of Eclipse 
      and study the relations between classes involved in these 
      antipatterns and classes change-, issue-, and unhandled 
      ex\-ception-proneness. We show that, in almost all releases of 
      Eclipse, classes with antipatterns are more change-, issue-, and 
      un\-handled-exception-prone than others. These results justify 
      previous work on the specification and detection of antipatterns and 
      could help focusing quality assurance and testing activities.}
}

@TECHREPORT{Khomh09-TR-DesignPatternsRoles,
   AUTHOR       = {Foutse Khomh and Yann-Gaël Guéhéneuc and 
      Guiliano Antoniol},
   INSTITUTION  = {École Polytechnique de Montréal},
   TITLE        = {An Empirical Descriptive and Analytic Study of Playing 
      Roles in Design Patterns},
   YEAR         = {2009},
   OPTADDRESS   = {},
   MONTH        = {April},
   NOTE         = {15 pages.},
   NUMBER       = {EPM-RT-2009-03},
   OPTTYPE      = {},
   KEYWORDS     = {Design patterns, Evolution patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Design+Patterns+Roles+April09.doc.pdf},
   ABSTRACT     = {This work presents a descriptive and analytic study of 
      classes playing zero, one, or two roles in six different design 
      patterns (and combinations thereof). First, we answer three research 
      questions showing that (1) playing roles in design patterns is not a 
      all-or-nothing characteristic of classes and that there are 
      significant differences among the (2) internal and (3) external 
      characteristics of classes playing zero, one, or two roles. Second, 
      we revisit a previous work on design patterns and changeability and 
      show that its results were, in a great part, due to classes playing 
      two roles. Third, we exemplify the use of the study results to 
      provide a ranking of the occurrences of the design patterns 
      identified in a program. The ranking allows developers to balance 
      precision and recall as they see fit.}
}

@TECHREPORT{Khomh09-TR-DEQUALITE,
   AUTHOR       = {Foutse Khomh and Naouel Moha and Yann-Gaël Guéhéneuc},
   INSTITUTION  = {École Polytechnique de Montréal},
   TITLE        = {DEQUALITE : méthode de construction de modèles de 
      qualité prenant en compte la conception des systèmes},
   YEAR         = {2009},
   OPTADDRESS   = {},
   MONTH        = {avril},
   NOTE         = {31 pages.},
   NUMBER       = {EPM-RT-2009-04},
   OPTTYPE      = {},
   KEYWORDS     = {Quality models},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+DEQUALITE+April09.doc.pdf},
   ABSTRACT     = {La plupart des mod\`eles de qualit\'e pr\'esent\'es dans 
      la litt\'erature ou utilis\'es dans lindustrie pour \'evaluer les 
      syst\`emes par objets utilisent des m\'etriques de classes (nombre de 
      m\'ethodes dune classe par exemple) ou des m\'etriques de relations 
      entre classes (couplage entre deux classes par exemple) pour mesurer 
      les attributs internes des syst\`emes. Cependant, la qualit\'e des 
      syst\`emes par objets ne d\'epend pas uniquement de la structure de 
      leurs classes mais aussi de la fa\c con dont celles-ci sont 
      organis\'ees, cest-\`a-dire de leur conception. Nous proposons 
      DEQUALITE, une m\'ethode de construction de mod\`eles de qualit\'e 
      permettant de mesurer la qualit\'e des syst\`emes par objets en 
      prenant en compte non seulement les attributs internes du syst\`eme 
      mais aussi sa conception. Notre m\'ethode utilise une approche par 
      apprentissage. Elle sappuie sur une \'etude des patrons de 
      conception pour prendre en compte la conception des syst\`emes. Notre 
      m\'ethode permet aussi de combiner des mod\`eles de qualit\'e afin 
      daugmenter la capacit\'e de pr\'ediction. Nous illustrons notre 
      m\'ethode sur un ensemble de syst\`emes implantant des patrons de 
      conception et sur le mod\`ele de qualit\'e QMOOD de Bansiya. Nous 
      discutons les avantages et les inconv\'enients de cette m\'ethode et 
      proc\'edons \`a la validation dun mod\`ele de qualit\'e r\'esultant 
      sur un ensemble de syst\`emes. Nous terminons par une discussion sur 
      les avantages et limitations de lutilisation des patrons de 
      conception pour la construction de mod\`eles de qualit\'e.}
}

@PHDTHESIS{Moha08-PhD,
   AUTHOR       = {Naouel Moha},
   SCHOOL       = {Université de Montréal et Université de Lille},
   TITLE        = {DECOR : détection et correction des défauts dans les 
      systèmes orientés objet},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Naouel+Moha.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Naouel+Moha.ppt.pdf},
   ABSTRACT     = {Les d\'efauts de code et de conception sont des 
      probl\`emes d'impl\'ementation et de conception qui proviennent de 
      ``mauvais'' choix conceptuels r\'ecurrents. Ces d\'efauts ont pour 
      cons\'e\-quence de freiner le d\'eveloppement et la maintenance des 
      syst\`emes en les rendant plus difficiles \`a maintenir et \'evoluer. 
      Une d\'etection et une correction semi-automati\-ques sont donc des 
      facteurs clefs pour faciliter les phases de maintenance et 
      d'\'evolution. Des techniques et outils ont \'et\'e propos\'es dans 
      la litt\'erature \`a la fois pour la d\'etection et la correction des 
      d\'efauts. Les techniques de d\'etection propos\'ees consistent 
      principalement \`a d\'efinir des r\`egles pour d\'etecter les 
      d\'efauts et \`a les appliquer sur le code source d'un syst\`eme. 
      Quant aux techniques de correction, elles consistent \`a appliquer de 
      fa\c con automatique des refactorisations dans le code source du 
      syst\`eme analys\'e afin de le restructurer de mani\`ere \`a corriger 
      les d\'efauts. Cependant, la phase qui consiste \`a identifier les 
      restructurations est r\'ealis\'ee manuellement par les ing\'enieurs 
      logiciels. Ainsi, il n'est pas possible de corriger directement et 
      automatiquement les d\'efauts d\'etect\'es. Ce probl\`eme est d\^u au 
      fait que la d\'etection et la correction des d\'efauts sont 
      trait\'ees de fa\c con isol\'ee. Ainsi, nous proposons DECOR{}, une 
      m\'ethode qui englobe et d\'efinit toutes les \'etapes n\'ecessaires 
      pour la d\'etection et la correction des d\'efauts de code et de 
      conception. Cette m\'ethode permet de sp\'ecifier des r\`egles de 
      d\'etection \`a un haut niveau d'abstraction et de sugg\'erer des 
      restructurations de code afin d'automatiser la correction des 
      d\'efauts. Nous appliquons et validons notre m\'ethode sur des 
      syst\`emes libres orient\'es objet afin de montrer que notre 
      m\'ethode permet une d\'etection pr\'ecise et une correction 
      adapt\'ee des d\'efauts.}
}

@INBOOK{Khosravi08-SQM-IssuesQualityModels,
   PUBLISHER    = {ICFAI University Press},
   TITLE        = {On Issues with Software Quality Models},
   YEAR         = {2008},
   AUTHOR       = {Khashayar Khosravi and Yann-Gaël Guéhéneuc},
   CHAPTER      = {11},
   ALTEDITOR    = {},
   PAGES        = {218--235},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   MONTH        = {January},
   NOTE         = {28 pages.},
   OPTNUMBER    = {},
   OPTSERIES    = {},
   OPTTYPE      = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, Design patterns, SQM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/SQM08.doc.pdf},
   ABSTRACT     = {Software metrics and quality models play a pivotal role 
      in measurement of software quality. A number of well-known quality 
      models and software metrics are used to build quality software both 
      in industry and in academia. However, during our research on 
      measuring software quality using design patterns, we faced many 
      issues related to existing software metrics and quality models. In 
      this position paper, we discuss some of these issues and present our 
      approach to software quality assessment.}
}

@ARTICLE{Gueheneuc07-TSE-MultiLayeredFramework,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   JOURNAL      = {Transactions on Software Engineering (TSE)},
   TITLE        = {DeMIMA: A Multi-layered Framework for Design Pattern 
      Identification},
   YEAR         = {2008},
   MONTH        = {September},
   NOTE         = {18 pages.},
   NUMBER       = {5},
   PAGES        = {667--684},
   VOLUME       = {34},
   EDITOR       = {Sebastian Elbaum and David S. Rosenblum},
   KEYWORDS     = {Design patterns, TSE},
   PUBLISHER    = {IEEE Computer Society Press},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TSE08.doc.pdf},
   ABSTRACT     = {Design patterns are important in object-oriented 
      programming because they offer design motifs, elegant solutions to 
      recurrent design problems, which improve the quality of software 
      systems. Design motifs facilitate system maintenance by helping to 
      understand design and implementation. However, after implementation, 
      design motifs are spread throughout the source code and are thus not 
      directly available to maintainers. We present DeMIMA, an approach to 
      identify semi-automatically micro-architectures that are similar to 
      design motifs in source code and to ensure the traceability of these 
      micro-architectures between implementation and design. DeMIMA 
      consists of three layers: two layers to recover an abstract model of 
      the source code, including binary class relationships, and a third 
      layer to identify design patterns in the abstract model. We apply 
      DeMIMA to five open-source systems and, on average, we observe 34\% 
      precision for the considered 12 design motifs. Through the use of 
      explanation-based constraint programming, DeMIMA ensures 100\% recall 
      on the five systems. We also apply DeMIMA on 33 industrial 
      components.}
}

@INPROCEEDINGS{Antoniol08-CASCON-ClassificationofChangeReq,
   AUTHOR       = {Giuliano Antoniol and Kamel Ayari and 
      Di Penta, Massimiliano and Foutse Khomh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 18<sup>th</sup> IBM Centers for Advanced Studies Conference (CASCON)},
   TITLE        = {Is It a Bug or an Enhancement? A Text-based Approach to 
      Classify Change Requests},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mark Vigder and Marsha Chechik},
   MONTH        = {October},
   NOTE         = {15 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, CASCON},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON08.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON08.ppt.pdf},
   ABSTRACT     = {Bug tracking systems are valuable assets for managing 
      maintenance activities. They are widely used in open-source projects 
      as well as in the software industry. They collect many different 
      kinds of issues: requests for defect fixing, enhancements, 
      refactoring/restructuring activities and organizational issues. These 
      different kinds of issues are simply labeled as ``bug" for lack of a 
      better classification support or of knowledge about the possible 
      kinds. This paper investigates whether the text of the issues posted 
      in bug tracking systems is enough to classify them into corrective 
      maintenance and other kinds of activities. We show that alternating 
      decision trees, naive Bayes classifiers, and logistic regression can 
      be used to accurately distinguish bugs from other kinds of issues. 
      Results from empirical studies performed on issues for Mozilla, 
      Eclipse, and JBoss indicate that issues can be classified with 
      between 77\% and 82\% of correct decisions.}
}

@INPROCEEDINGS{Antoniol08-ICSM-ReORe,
   AUTHOR       = {Giuliano Antoniol and Jane Huffman Hayes and 
      Yann-Gaël Guéhéneuc and Di Penta, Massimiliano},
   BOOKTITLE    = {Proceedings of the 24<sup>th</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {Reuse or Rewrite: Combining Textual, Static, and Dynamic 
      Analyses to Assess the Cost of Keeping a System Up-to-date},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Hong Mei and Kenny Wong},
   MONTH        = {September--October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM08a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM08a.ppt.pdf},
   ABSTRACT     = {Undocumented software systems are a common challenge for 
      developers performing maintenance and/or reuse. The challenge is 
      two-fold: (1) when no comments or documentation exist, it is 
      difficult for developers to understand how a system works; (2) when 
      no requirements exist, it is difficult to know what the system 
      actually does. We present a method, named ReORe (Reuse or Rewrite) 
      that assists developers in recovering requirements for a competitor 
      system and in deciding if they should reuse parts of their existing 
      system or rewrite it from scratch. Our method requires source code 
      and executable for the system and assumes that requirements are 
      preliminarily recovered. We apply ReORe to Lynx, a Web browser 
      written in C. We provide evidence of ReORe accuracy: 56\% for 
      validation based on textual and static analysis and 94\% for the 
      final validation using dynamic analysis.}
}

@INPROCEEDINGS{Denier08-ICPC-Mendel,
   AUTHOR       = {Simon Denier and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> International Conference on Program Comprehension (ICPC)},
   TITLE        = {Mendel: A Model, Metrics, and Rules to Understand Class 
      Hierarchies},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {René Krikhaar and Ralf Lämmel},
   MONTH        = {June},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Understanding program comprehension, ICPC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC08a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC08a.ppt.pdf},
   ABSTRACT     = {Inheritance is an important mechanism when developing 
      object-oriented programs with class-based programming languages: it 
      enables subtyping, polymorphism, and code reuse. Inheritance is also 
      known as a difficult feature to grasp and to use correctly because of 
      its many purposes. We propose a model of inheritance to help 
      understand class hierarchies of class-based object-oriented programs. 
      We define metrics and rules to highlight interesting classes and 
      behaviours with respect to inheritance. Thus, we provide the 
      programmer with insight on how inheritance is used in a program. We 
      illustrate our approach on \JHotDraw{} and validate it further on 
      three other programs: ArgoUML, Azureus, and Log4J. We also show that 
      our model can describe existing rules, such as micro patterns.}
}

@INPROCEEDINGS{DiPenta08-ICSM-DPRoles,
   AUTHOR       = {Di Penta, Massimiliano and Luigi Cerulo and 
      Yann-Gaël Guéhéneuc and Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 24<sup>th</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {An Empirical Study of the Relationships between Design 
      Pattern Roles and Class Change Proneness},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Hong Mei and Kenny Wong},
   MONTH        = {September--October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM08b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM08b.ppt.pdf},
   ABSTRACT     = {Analyzing the change-proneness of design patterns and 
      the kinds of changes occurring to classes playing role(s) in some 
      design pattern(s) during software evolution poses the basis for 
      guidelines to help developers who have to choose, apply or maintain 
      design patterns. Building on previous work, this paper shifts the 
      focus from design patterns as wholes to the finer-grain level of 
      design pattern roles. It presents an empirical study to understand 
      whether there are roles that are more change-prone than others and 
      whether there are changes that are more likely to occur to certain 
      roles. It relies on data extracted from the source code repositories 
      of three different systems (JHotDraw, Xerces, and Eclipse-JDT) and 
      from 12 design patterns.}
}

@INPROCEEDINGS{Eaddy08-ICPC-Cerberus,
   AUTHOR       = {Marc Eaddy and Alfred V. Aho and Giuliano Antoniol and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> International Conference on Program Comprehension (ICPC)},
   TITLE        = {Cerberus: Tracing Requirements to Source Code Using 
      Information Retrieval, Dynamic Analysis, and Program Analysis},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {René Krikhaar and Ralf Lämmel},
   MONTH        = {June},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, ICPC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC08b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC08b.ppt.pdf},
   ABSTRACT     = {The concern location problem is to identify the source 
      code within a program related to the features, requirements, or other 
      concerns of the program. This problem is central to program 
      development and maintenance. We present a new technique called prune 
      dependency analysis that can be combined with existing techniques to 
      dramatically improve the accuracy of concern location. We developed 
      Cerberus, a potent hybrid technique for concern location that 
      combines information retrieval, execution tracing, and prune 
      dependency analysis. We used Cerberus to trace the 360 requirements 
      of RHINO, a 32,134 line Java program that implements the ECMAScript 
      international standard. In our experiment, prune dependency analysis 
      boosted the recall of information retrieval by 155\% and execution 
      tracing by 104\%. Moreover, we show that our combined technique 
      outperformed the other techniques when run individually or in pairs.}
}

@INPROCEEDINGS{Ghannem08-LMO-AnalyseLogiciels,
   AUTHOR       = {Adnane Ghannem and Salima Hassaine and 
      Yann-Gaël Guéhéneuc and Sylvie Hamel},
   BOOKTITLE    = {Actes du 14<sup>e</sup> colloque Langages et Modèles à Objets (LMO)},
   TITLE        = {L'analyse de logiciels, phylogénie et histoire},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mireille Blay-Fornarino},
   MONTH        = {mars},
   NOTE         = {Poster. 2 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Éditions Cépaduès},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, LMO},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO08b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO08b.ppt.pdf},
   ABSTRACT     = {La maintenance des logiciels de grande taille est une 
      activit\'e co\^uteuse, car leur \'evolution incontr\^ol\'ee compromet 
      leur compr\'ehension et modification. Une \'etude de leur \'evolution 
      pourrait r\'eduire les co\^uts. Notre travail a pour objectif de 
      proposer des techniques d'analyse de l'\'evolution (historique et 
      phylog\'enie), en adaptant des algorithmes de bioinformatique.}
}

@INPROCEEDINGS{Hayes08-WCRE-PREREQIR,
   AUTHOR       = {Jane Huffman Hayes and Giuliano Antoniol and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 15<sup>th</sup> Working Conference on Reverse Engineering (WCRE)},
   TITLE        = {Prereqir: Recovering Pre-Requirements via Cluster 
      Analysis},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Andy Zaidman and Di Penta, Massimilano and Ahmed Hassan},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {165--174},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, WCRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE08.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE08.ppt.pdf},
   ABSTRACT     = {High-level software artifacts, such as requirements, 
      domain-specific requirements, and so on, are an important source of 
      information that is often neglected during the reverse- and 
      re-engineering processes. We posit that domain specific 
      pre-requirements information (PRI) can be obtained by eliciting the 
      stakeholders' understanding of generic systems or domains. We discuss 
      the semi-automatic recovery of domain-specific PRI that can then be 
      used during reverse- and re-engineering, for example, to recover 
      traceability links or to assess the degree of obsolescence of a 
      system with respect to competing systems and the clients' 
      expectations. We present a method using partition around medoids and 
      agglomerative clustering for obtaining, structuring, analyzing, and 
      labeling textual PRI from a group of diverse stakeholders. We 
      validate our method using PRI for the development of a generic Web 
      browser provided by 22 different stakeholders. We show that, for a 
      similarity threshold of about 0.36, about 55\% of the PRI were common 
      to two or more stakeholders and 42\% were outliers. We automatically 
      label the common and outlier PRI (82\% correctly labeled), and obtain 
      74\% accuracy for the similarity threshold of 0.36 (78\% for a 
      threshold of 0.5). We assess the recall and precision of the method, 
      and compare the labeled PRI to a generic Web browser requirements 
      specification.}
}

@INPROCEEDINGS{Khomh08-CSMR-DPQuality,
   AUTHOR       = {Foutse Khomh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 12<sup>th</sup> Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {Do Design Patterns Impact Software Quality Positively?},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Christos Tjortjis and Andreas Winter},
   MONTH        = {April},
   NOTE         = {Short Paper. 5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR08.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR08.ppt.pdf},
   ABSTRACT     = {We present an empirical study of the impact of design 
      patterns on quality attributes in the context of software maintenance 
      and evolution. Our first hypothesis verifies software engineering 
      lore: design patterns impact software quality positively. We show 
      that, contrary to popular beliefs, design patterns \emph{in practice} 
      impact negatively several quality attributes, thus providing concrete 
      evidence against common lore. We then study design patterns and 
      object-oriented best practices by formulating a second hypothesis on 
      the impact of these principles on quality. We show that results for 
      some design patterns cannot be explained and conclude on the need for 
      further studies on the relation between design patterns and 
      object-oriented best practices. Thus, we bring further evidence that 
      design patterns should be used with caution during development 
      because they may actually impede maintenance and evolution.}
}

@INPROCEEDINGS{Moha08-FASE-Language,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc and 
      Anne-Francoise Le Meur and Laurence Duchien},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> International Conference on Fundamental Approaches to Software Engineering},
   TITLE        = {A Domain Analysis to Specify Design Defects and Generate 
      Detection Algorithms},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {José Fiadeiro and Paola Inverardi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {276--291},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Quality experts often need to identify in software 
      systems design defects, which are recurring design problems, that 
      hinder development and maintenance. Consequently, several defect 
      detection approaches and tools have been proposed in the literature. 
      However, we are not aware of any approach that defines and reifies 
      the process of generating detection algorithms from the existing 
      textual descriptions of defects. In this paper, we introduce an 
      approach to automate the generation of detection algorithms from 
      specifications written using a domain-specific language. The 
      domain-specific is defined from a thorough domain analysis. We 
      specify several design defects, generate automatically detection 
      algorithms using templates, and validate the generated detection 
      algorithms in terms of precision and recall on Xerces v2.7.0, an 
      open-source object-oriented system.}
}

@INPROCEEDINGS{Moha08-ICFCA-RefactoringsDesignDefects,
   AUTHOR       = {Naouel Moha and Amine Mohamed Rouane Hacene and 
      Petko Valtchev and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 4<sup>th</sup> International Conference on Formal Concept Analysis (ICFCA)},
   TITLE        = {Refactorings of Design Defects using Relational Concept 
      Analysis},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Raoul Medina and Sergei Obiedkov},
   MONTH        = {February},
   NOTE         = {18 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, ICFCA},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICFCA08.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICFCA08.ppt.pdf},
   ABSTRACT     = {Software engineers often need to identify and correct 
      design defects, \ie{} recurring design problems that hinder 
      development and maintenance by making programs harder to comprehend 
      and--or evolve. While detection of design defects is an actively 
      researched area, their correction---mainly a manual and 
      time-consuming activity --- is yet to be extensively investigated for 
      automation. In this paper, we propose an automated approach for 
      suggesting defect-correcting refactorings using relational concept 
      analysis (RCA). The added value of RCA consists in exploiting the 
      links between formal objects which abound in a software 
      re-engineering context. We validated our approach on instances of the 
      \textit{Blob} design defect taken from four different open-source 
      programs.}
}

@INPROCEEDINGS{Moha08-LMO-DefautConception,
   AUTHOR       = {Naouel Moha and Foutse Khomh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Actes du 14<sup>e</sup> colloque Langages et Modèles à Objets (LMO)},
   TITLE        = {Génération automatique d'algorithmes de détection des 
      défauts de conception},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mireille Blay-Fornarino},
   MONTH        = {mars},
   NOTE         = {13 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Éditions Cépaduès},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, LMO},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO08a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO08a.ppt.pdf},
   ABSTRACT     = {Les d\'efauts de conception sont des probl\`emes 
      r\'ecurrents de conception qui diminuent la qualit\'e des programmes 
      et donc freinent leur d\'eveloppement et maintenance. Plusieurs 
      approches outill\'ees de d\'etection des d\'efauts ont \'et\'e 
      propos\'ees dans la litt\'erature mais, \`a notre connaissance, elles 
      utilisent toutes des algorithmes de d\'etection ad hoc, ce qui rend 
      difficile leur g\'en\'eralisation \`a d'autres d\'efauts, et elles 
      sont bas\'ees principalement sur des m\'etriques, qui ne rendent pas 
      compte de certaines caract\'eristiques importantes des syst\`emes 
      analys\'es, telle leur architecture. Dans cet article, nous 
      d\'eveloppons notre approche bas\'ee sur un m\'eta-mod\`ele des 
      d\'efauts de conception en pr\'esentant une g\'en\'eration 
      automatique des algorithmes de d\'etection \`a partir de gabarits. 
      Nous pr\'esentons aussi les performances de la g\'en\'eration et 
      \'evaluons les algorithmes g\'en\'er\'es en terme de pr\'ecision et 
      de rappel. Nous fournissons ainsi des moyens concrets pour 
      automatiser la g\'en\'eration des algorithmes de d\'etection et donc 
      de d\'etecter de nouveaux d\'efauts tout en prenant en compte toutes 
      les caract\'eristiques des syst\`emes.}
}

@TECHREPORT{Denier08-TR-DPStateOfTheArt,
   AUTHOR       = {Simon Denier and Foutse Khomh and Yann-Gaël Guéhéneuc},
   INSTITUTION  = {DGIGL, École Polytechnique Montréal},
   TITLE        = {Reverse-Engineering the Literature on Design Patterns 
      and Reverse-Engineering},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {October},
   NOTE         = {18 pages.},
   NUMBER       = {EPM-RT-2008-09},
   OPTTYPE      = {},
   KEYWORDS     = {Understanding program comprehension},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+DP+SotA+October09.doc.pdf},
   ABSTRACT     = {Since their inception in 1994, design patterns have been 
      the subject of many papers. In the reverse-engineering community, 
      several authors have proposed approaches to consider design patterns 
      during reverse- and re-engineering. However, it has been recently put 
      forward in the community that it is difficult to compare previous 
      approaches due to the diversity of vocabulary and the lack of a 
      general framework to map and relate these approaches. Consequently, 
      we study 59 papers related to design patterns in the software 
      engineering community at large (1) to identify and define common 
      terms related to design patterns, (2) to identify recurring themes in 
      the papers, and (3) to further characterise approaches for design 
      pattern detection along several categories. Recurring themes allow us 
      to provide the portrait of the ``typical" paper on design patterns 
      while catagories draw the portrait of the ``typical" approach in 
      design pattern detection. We propose to the community to use a fix 
      vocabulary, to diversify the approaches, and to build a common 
      benchmark to assess the reverse engineering of design patterns.}
}

@TECHREPORT{Khomh08-TR-EmpStudyDPQuality,
   AUTHOR       = {Foutse Khomh and Yann-Gael Guéhéneuc},
   INSTITUTION  = {University of Montreal},
   TITLE        = {An Empirical Study of Design Patterns and Software 
      Quality},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {january},
   NOTE         = {44 pages.},
   NUMBER       = {1315},
   OPTTYPE      = {},
   EDITOR       = {of Montréal, University},
   KEYWORDS     = {Quality models, Design patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+DP+Quality+January08.doc.pdf},
   ABSTRACT     = {We present an empirical study of the impact of design 
      patterns on quality attributes in the context of software maintenance 
      and evolution. Our first hypothesis verifies software engineering 
      lore: design patterns impact software quality positively. We show 
      that, contrary to popular beliefs, design patterns in practice impact 
      negatively several quality attributes, thus providing concrete 
      evidence against common lore. We then study design patterns and 
      object-oriented best practices by formulating a second hypothesis on 
      the impact of these principles on quality. We show that results for 
      some design patterns cannot be explained and conclude on the need for 
      further studies on the relation between design patterns and 
      object-oriented best practices. Thus, we bring further evidence that 
      design patterns should be used with caution during development 
      because they may actually impede maintenance and evolution.}
}

@MASTERSTHESIS{Bertrand08-MSc,
   AUTHOR       = {Paul Bertrand},
   SCHOOL       = {Université de Montréal},
   TITLE        = {A versatile location-based service Java control for 
      Pocket-pc},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Thesis+of+Paul+Bertrand.doc.pdf},
   ABSTRACT     = {With the democratization of Pocket-pc devices and their 
      constant improvement in terms of performances, more and more 
      companies equip their field technicians with such devices. A concrete 
      application involves technicians who can use Pocket-pc to consult and 
      organize their daily tasks synchronized with a central system. Along 
      with its backend system (Netweaver), SAP also provides Pocket-pc 
      software written in Java. As most of these technicians need to meet 
      customers and go on sites, these systems need to be shipped with an 
      embedded mapping control that must support any kind of mapping 
      service independently from the technology used by this latter. The 
      aim of this work is to propose a versatile location-based service 
      Java control relying on a unique abstract interface that gives the 
      possibility to adapt any kind of mapping service and to satisfy SAP 
      mobile software development constraints. The proof of concept has 
      been validated by implementing two services using different 
      technologies (Google maps using AJAX and Microsoft Mappoint using Web 
      services) and tested on two different devices: a Compaq Ipaq and a 
      Fujitsu Siemens Pocket LOOX. The results obtained were very 
      encouraging and conclusive enough to ship this control with SAP 
      Pocket-pc systems. In conclusion, this project brings a concrete and 
      flexible solution to mapping controls that can be integrated within 
      any Java application running on Pocket-pc devices.}
}

@MASTERSTHESIS{Cepeda08-MSc,
   AUTHOR       = {Cepeda Porras, Gerardo},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Analyse, à l'aide d'oculomètres, de techniques de 
      visualisation UML de patrons de conception pour la compréhension de 
      programmes},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {Septembre},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Thesis+of+Gerardo+Cepeda.doc.pdf},
   ABSTRACT     = {Les patrons de conception sont reconnus dans la 
      communaut\'e du g\'enie logiciel comme des solutions utiles pour 
      am\'eliorer la qualit\'e des programme. Une bonne visualisation des 
      patrons de conception est donc utile pour comprendre de fa\c con 
      efficace le fonctionnement d'un syst\`eme. Actuellement la 
      repr\'esentation standard pour visualiser les patrons de conception 
      est celle de la notation de collaboration UML. Plusieurs auteurs ont 
      remarqu\'e des lacunes dans cette repr\'esentation et ont propos\'e 
      de nouvelles repr\'esentations pour remplacer le standard. Aucun de 
      ces auteurs n'a fait d'\'etudes empiriques pour comparer ces 
      repr\'esentations \`a la repr\'esentation standard. Dans le cadre de 
      cette ma\^{\i}trise, nous avons r\'ealis\'e une \'etude empirique 
      pour collecter des donn\'ees sur les performances des ing\'enieurs 
      logiciels dans le but d'\'evaluer l'impact de trois repr\'esentations 
      visuelles sur la compr\'ehension de patrons de conception et les 
      comparer avec la repr\'esentation standard. Nous avons utilis\'e des 
      oculom\`etres pour mesurer la charge cognitive des sujets pendant 
      l'ex\'ecution de l'exp\'erience. L'analyse des donn\'ees collect\'ees 
      montre qu'effectivement pour certaines t\^aches il existe une 
      repr\'esentation qui est plus efficace que la repr\'esentation 
      standard.}
}

@MASTERSTHESIS{Ng08-MSc,
   AUTHOR       = {Janice Ka-Yee Ng},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Identification of Behavioral and Creational Design 
      Patterns through Dynamic Analysis},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Janice+Ka-Yee+Ng.doc.pdf},
   ABSTRACT     = {The use of design patterns is a simple and elegant way 
      to solve problems when designing object-oriented software systems 
      because it leads to well-structured designs. However, after 
      application, design patterns are lost in the source code, and are 
      thus of little help during program comprehension and subsequent 
      maintenance. In previous work, the structure and organization among 
      classes were the predominant source of data used for the 
      identification of occurrences of design patterns. Yet, the 
      responsibility of each participating object at runtime should not be 
      neglected, as two types of design patterns, behavioral and 
      creational, are mainly concerned with the assignment of 
      responsibilities and the collaborations among objects at runtime. 
      This thesis proposes a metamodel and algorithms to identify 
      automatically behavioral and creational design patterns in the source 
      code. We use metamodelling to describe design patterns and software 
      systems in Java{}, and dynamic analysis to capture the behavior of 
      the systems at the moment of execution. The proposed metamodel allows 
      the representation of collaborations among the participants that take 
      part in the execution of a system (messages) and their properties 
      (conditions under which a message is executed, repetition of a 
      message). Using this metamodel, the problem of behavioral and 
      creational pattern identification can be translated into an 
      explanation-based constraint satisfaction problem. Solving such kind 
      of problem leads to exact and approximate occurrences of a design 
      pattern.}
}

@MASTERSTHESIS{Tagmouti08-MSc,
   AUTHOR       = {Yousra Tagmouti},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Modélisation et implémentation des patrons de conception},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {Août},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Thesis+of+Yousra+Tagmouti.doc.pdf},
   ABSTRACT     = {Les patrons de conception sont des solutions communes 
      {\`a} des probl{\`e}mes de conception r{\'e}current. Ils 
      repr{\'e}sentent un vocabulaire commun {\`a} lexpertise des 
      concepteurs et favorisent le transfert de connaissances entre les 
      concepteurs experts et novices. {\`A} ce jour, plusieurs travaux ont 
      {\'e}t{\'e} r{\'e}alis{\'e}s afin dexplorer le potentiel des patrons 
      de conception pour am{\'e}liorer la conception des syst{\`e}mes. 
      Cependant, la plupart de ces travaux se limitent aux syst{\`e}mes 
      purement logiciels. Tr{\`e}s peu de travaux ont tent{\'e} 
      dint{\'e}grer les patrons de conception dans dautres types de 
      syst{\`e}mes et plus g{\'e}n{\'e}ralement dans dautres domaines de 
      linformatique, pour exploiter leurs avantages. Nous contribuons 
      {\`a} combler cette lacune en un travail de mise en correspondance 
      entre des architectures mat{\'e}rielle et des patrons de conception 
      orient{\'e}s objet. Le travail de correspondance 
      mat{\'e}rielle/logicielle se fait dans le cadre du projet Esys.net, 
      qui a pour objectif la cr{\'e}ation dun environement de 
      mod{\'e}lisation et simulation de syst{\`e}mes mat{\'e}riels, 
      Esys.net. Dans le cadre de cette collaboration, lobjectif de notre 
      travail consiste {\`a} offrir {\`a} cette mise en correspondance 
      mat{\'e}rielle/logicielle un environnement de mod{\'e}lisation afin 
      de prendre en charge, dune part, la mod{\'e}lisation des patrons et 
      dautre part, leurs impl{\'e}mentations en g{\'e}n{\'e}rant 
      automatiquement du code Esys.net {\`a} partir des mod{\`e}les de ces 
      patrons. Ainsi, nous avons (1) {\'e}tendu le m{\'e}ta-mod{\`e}le 
      PADL, d{\'e}di{\'e} {\`a} la mod{\'e}lisation des patrons de 
      conception orient{\'e}s objet, en un m{\'e}ta-mod{\`e}le plus riche 
      que nous avons nomm{\'e} MIP et ce dans le but de pouvoir 
      mod{\'e}liser les diff{\'e}rents aspects reli{\'e}s aux patrons de 
      conception orient{\'e}s objet ; (2) {\'e}tendu le m{\'e}ta-mod{\`e}le 
      MIP en un m{\'e}ta-mod{\`e}le MIPC] incluant les constituants du 
      langage C] qui diff{\'e}rent de Java ; (3) mod{\'e}lis{\'e} douze 
      patrons de conception avec le m{\'e}ta-mod{\`e}le MIP et MIPC] ; (4) 
      construit les g{\'e}n{\'e}rateurs de code, SimpleJavaGenerator, 
      CSharpGenerator et JavatoCSharpGenerator, permettant de 
      g{\'e}n{\'e}rer du code Java et C] {\`a} iv partir des mod{\`e}les de 
      patrons d{\'e}finis dans l{\'e}tape pr{\'e}c{\'e}dente ; (5) 
      construit un m{\'e}ta-mod{\`e}le Esys.net afin de structurer ses 
      diff{\'e}rentes composantes ; (6) {\'e}tablit une correspondance 
      entre les constituants du m{\'e}ta-mod{\`e}le MIP et ceux du 
      m{\'e}tamod` ele Esys.net afin de faciliter la g{\'e}n{\'e}ration de 
      code Esys.net {\`a} partir des mod{\`e}les de patrons ; (7) construit 
      le g{\'e}n{\'e}rateur de code Esys.net et son application {\`a} un 
      syst{\`e}me de r{\'e}gulateur de vitesse impl{\'e}ment{\'e} en 
      Esys.net que nous avons mod{\'e}lis{\'e} avec le m{\'e}ta-mod{\`e}le 
      Esys.net et g{\'e}n{\'e}r{\'e} le code Esys.net lui correspondant.}
}

@ARTICLE{Poshyvanyk07-TSE-Promesir,
   AUTHOR       = {Denys Poshyvanyk and Yann-Gaël Guéhéneuc and 
      Andrian Marcus and Giuliano Antoniol and Václav Rajlich},
   JOURNAL      = {Transactions on Software Engineering (TSE)},
   TITLE        = {Feature Location using Probabilistic Ranking of Methods 
      based on Execution Scenarios and Information Retrieval},
   YEAR         = {2007},
   MONTH        = {June},
   NOTE         = {14 pages.},
   NUMBER       = {6},
   PAGES        = {420--432},
   VOLUME       = {33},
   KEYWORDS     = {Features and requirements, TSE},
   PUBLISHER    = {IEEE Computer Society Press},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TSE07.doc.pdf},
   ABSTRACT     = {This paper recasts the problem of feature location in 
      source code as a decision-making problem in the presence of 
      uncertainty. The solution to the problem is formulated as a 
      combination of expert opinions. The experts in this case are 
      represented by two existing techniques for feature location: 
      Scenario-based Probabilistic Ranking of events and an Information 
      Retrieval-based technique that uses Latent Semantic Indexing. The 
      combination of these two methods is empirically evaluated through 
      several case studies. The case studies use the source code of the 
      Mozilla web browser and the Eclipse integrated development 
      environment. The results show that the combined technique 
      significantly improves the effectiveness of feature location when 
      compared to each of the techniques used independently.}
}

@INPROCEEDINGS{Antoniol07-ICSM-LexiconEvolution,
   AUTHOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc and 
      Ettore Merlo and Paolo Tonella},
   BOOKTITLE    = {Proceedings of the 23<sup>rd</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {Mining the Lexicon Used by Programmers during Software 
      Evolution},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Ladan Tahvildari and Gerardo Canfora},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM07.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM07.ppt.pdf},
   ABSTRACT     = {Identifiers represent an important source of information 
      for programmers understanding and maintaining a system. 
      Self-documenting identifiers reduce the time and effort necessary to 
      obtain the level of understanding appropriate for the task at hand. 
      While the role of the lexicon in program comprehension has long been 
      recognized, only a few works have studied the quality and enhancement 
      of the identifiers and no works have studied the evolution of the 
      lexicon. In this paper, we characterize the evolution of program 
      identifiers in terms of stability metrics and occurrences of 
      renaming. We assess whether an evolution process similar to the one 
      occurring for the program structure exists for identifiers. We report 
      data and results about the evolution of three large systems, for 
      which several releases are available. We have found evidence that the 
      evolution of the lexicon is more limited and constrained than the 
      evolution of the structure. We argue that the different evolution 
      results from several factors including the lack of advanced tool 
      support for lexicon construction, documentation, and evolution. 
      Finally, we suggest the existence of rules on the co-evolution of 
      structure and lexicon of software systems.}
}

@INPROCEEDINGS{Cote07-CICM-GereMedicationAntiretrovirale,
   AUTHOR       = {José Côté and Pilar Ramirez Garcia and Gaston Godin and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Actes du 2<sup>e</sup> Congrès international sur la chaîne des médicaments},
   TITLE        = {Gérer sa médication antirétrovirale avec une assistance 
      en ligne... une approche en cours d'évaluation},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Bernard Bégaud and Pavel Hamet and André Jacques and 
      Vittorio A. Sironi},
   MONTH        = {Octobre},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Groupe d'étude sur l'interdisciplinarité et les représentations sociales},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {VIHTAVIE, CICM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CICM07.doc.pdf}
}

@INPROCEEDINGS{Gueheneuc07-EPFPR-PMARt,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> EuroPLoP Focus Group on Pattern Repositories},
   TITLE        = {PMARt: Pattern-like Micro Architecture Repository},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Michael Weiss and Aliaksandr Birukou and Paolo Giorgini},
   MONTH        = {July},
   NOTE         = {3 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, EPFPR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/EuroPLoP07PRa.doc.pdf},
   ABSTRACT     = {We introduce PMARt{}, a repository of pattern-like 
      micro-architetcures. The purpose of PMARt{} is to serve as baseline 
      to assess the precision and recall of pattern identification tools. 
      Indeed, several approaches have been proposed to identify occurrences 
      of design patterns, yet few have been independently validated for 
      precision and recall for lack of known occurrences. We hope that 
      PMARt{} can be shared and enriched by researchers interested in 
      design pattern identification.}
}

@INPROCEEDINGS{Gueheneuc07-EPFPR-Recommander,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Rabih Mustapha},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> EuroPLoP Focus Group on Pattern Repositories},
   TITLE        = {A Simple Recommender System for Design Patterns},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Michael Weiss and Aliaksandr Birukou and Paolo Giorgini},
   MONTH        = {July},
   NOTE         = {2 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, EPFPR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/EuroPLoP07PRb.doc.pdf},
   ABSTRACT     = {Since its introduction in computer science, the concept 
      of pattern has flourished. Several conferences and workshops focus on 
      writing and disseminating patterns. Consequently, a large number of 
      patterns exist and it is sometimes difficult to find the right 
      patterns and to choose among many candidate, when solving a given 
      problem. In this paper, we introduce a simple recommender system to 
      help user in choosing among the 23 design patterns from the GoF. We 
      detail its implementation and discuss its application to other 
      patterns.}
}

@INPROCEEDINGS{Khomh07-QAOOSE-DPQuality,
   AUTHOR       = {Foutse Khomh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> ECOOP workshop on Quantitative Approaches in Object-Oriented Software Engineering (QAOOSE)},
   TITLE        = {Perception and Reality: What are Design Patterns Good 
      For?},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {e Abreu, Fernando Brito and Coral Calero and 
      Yann-Gaël Guéhéneuc and Christian Lange and Michele Lanza and 
      Houari A. Sahraoui},
   MONTH        = {July--August},
   NOTE         = {7 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, Design patterns, QAOOSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP07QAOOSE.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP07QAOOSE.ppt.pdf},
   ABSTRACT     = {We present a study of the impact of design patterns on 
      quality attributes. An empirical study is performed by asking 
      respondents their evaluations of the impact of all design patterns on 
      several quality attributes. We present detailed results for three 
      design patterns (Abstract Factory, Composite, and Flyweight) and 
      three quality attributes (reusability, understandability, and 
      expendability). We perform a Null hypothesis test and we conclude 
      that, contrary to popular beliefs, design patterns do not always 
      improve reusability and understandability, but that they do improve 
      expandability.}
}

@INPROCEEDINGS{Moha07-WOOR-DesignDefects,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc and Laurence Duchien and 
      Le Meur, Anne-Françoise},
   BOOKTITLE    = {Proceedings of the 8<sup>th</sup> ECOOP workshop on Object-Oriented Reengineering (WOOR)},
   TITLE        = {Discussion on the Results of the Detection of Design 
      Defects},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Serge Demeyer and Yann-Gaël Guéhéneuc and 
      Christian Lange and Kim Mens and Roel Wuyts and Stéphane Ducasse},
   MONTH        = {July--August},
   NOTE         = {6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, WOOR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP07WOOR.doc.pdf},
   ABSTRACT     = {Software engineers often need to identify in their 
      systems ``poor" design choices---design defects---that hinder the 
      development and maintenance, as opportunities of improvements and as 
      a measure of the quality of their systems. However, the detection of 
      design defects is difficult because of the lack of specifications and 
      tools. We propose DECOR, a method to specify design defects 
      systematically and to generate automatically detection algorithms. 
      With this method, software engineers analyse and specify design 
      defects at a high-level of abstraction using a unified vocabulary and 
      a dedicated language for generating detection algorithms. To 
      illustrate our method, in this paper, we specify 4 well-known design 
      defects, the antipatterns Blob, Functional Decomposition, Spaghetti 
      Code, and Swiss Army Knife and their 15 underlying code smells and we 
      generate automatically their detection algorithms. We apply and 
      validate the detection algorithms in terms of precision and recall 
      and discuss the precision of these algorithms on 11 open-source 
      object-oriented systems.}
}

@TECHREPORT{Tiberghien07-TR-DefectsRepository,
   AUTHOR       = {Alban Tiberghien and Naouel Moha and Tom Mens and 
      Kim Mens},
   INSTITUTION  = {University of Montreal},
   TITLE        = {Répertoire des défauts de conception},
   YEAR         = {2007},
   OPTADDRESS   = {},
   MONTH        = {November},
   OPTNOTE      = {},
   NUMBER       = {1303},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Research+report+Defect+RepositoryNovember07.doc.pdf},
   ABSTRACT     = {Afin de classer un certain nombre de d\´efauts de 
      conception, nous avons utilis\´e la classification propos\´ee par 
      M\¨antyl\¨a [2] qui permet de mieux comprendre les diff\´erents 
      d\´efauts et les relations qui les lient. Nous avons d\´ecrit chaque 
      d\´efaut en suivant le patron suivant : le (ou les) nom(s) connu(s) 
      de ce d\´efaut, un identificateur (ID), une description, et dans 
      certains cas des exemples.}
}

@MASTERSTHESIS{Bouden07-MSc,
   AUTHOR       = {Saliha Bouden},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Étude de la traçabilité entre refactorisations du modèle 
      de classes et refactorisations du code},
   YEAR         = {2007},
   OPTADDRESS   = {},
   MONTH        = {Février},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Thesis+of+Saliha+Bouden.doc.pdf},
   ABSTRACT     = {La refactorisation est une technique qui consiste \`a 
      changer la structure interne d'un programme pour faciliter sa 
      compr\'ehension et sa maintenance sans en changer le comportement 
      externe. Certains outils de refactorisation ne permettent pas de 
      reporter les changements effectu\'es sur le code vers les mod\`eles 
      (comme UML) et inversement des mod\`eles vers le code. D'autres 
      outils permettent de g\'en\'erer les diagrammes UML \`a partir du 
      code refactoris\'e et inversement de g\'en\'erer le code \`a partir 
      des mod\`eles refactoris\'es. Cependant, ils n'assurent pas la tra\c 
      cabilit\'e entre la conception d'un programme et son code source, 
      lors de refactorisation. Le but de notre travail est d'assurer la 
      tra\c cabilit\'e entre le mod\`ele et le code source d'un programme. 
      Nous proposons un catalogue de 55 refactorisations primitives et 
      composites au niveau du mod\`ele de classes et nous d\'efinissons 
      pour chaque refactorisation des pr\'e-conditions, des post-conditions 
      et des actions, exprim\'ees dans un pseudo code et n\'ecessaires pour 
      assurer la pr\'eservation de ``comportement du mod\`ele''. Nous 
      distinguons ces refactorisations en refactorisations primitives et 
      composites et nous les classifions afin de mettre en valeur la 
      similarit\'e des op\'erations associ\'ees aux refactorisations. Par 
      ailleurs, nous \'etablissons une correspondance entre les 
      refactorisations du mod\`ele et les refactorisations du code. Enfin, 
      nous avons implant\'e un sous-ensemble des refactorisations du 
      mod\`ele afin de valider notre \'etude de la tra\c cabilit\'e entre 
      refactorisations des mod\`eles de classes et refactorisations du 
      code.}
}

@MISC{Gueheneuc07-Demo-GRASCOMP,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {March},
   NOTE         = {Tool demo at GRASCOMP Graduate School in Computing Science 2007 (COMP013).},
   TITLE        = {Design Pattern Identification in Ptidej},
   YEAR         = {2007},
   KEYWORDS     = {Design patterns, GRASCOMP},
   URL          = {http://www.grascomp.be/inauguration-en.php},
   ABSTRACT     = {The Ptidej (Pattern Trace Identification, Detection, and 
      Enhancement in Java) project aims at developing a tool suite to 
      evaluate and to enhance the quality of object-oriented programs, 
      promoting the use of patterns, at language-, design-, or 
      architectural-level.}
}

@MISC{Gueheneuc07-Demo-ICSM,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {October},
   NOTE         = {Tool demo at the 23<sup>rd</sup> International Conference on Software Maintenance.},
   TITLE        = {Ptidej: A Flexible Reverse Engineering Tool Suite},
   YEAR         = {2007},
   KEYWORDS     = {Design patterns, ICSM},
   ABSTRACT     = {The Ptidej{} project started in 2001 to study the 
      automated identification of design patterns. Since then, it has 
      evolved into a complete reverse-engineering tool suite that includes 
      several identification algorithms for idioms, micro-patterns, design 
      patterns, and design defects (code smells and antipatterns). It is a 
      flexible tool suite that attempts to ease as much as possible the 
      development of new identification algorithms. In this demonstration, 
      we first present the key features of the tool suite user interface 
      and the various identification algorithms. We then discuss the 
      architecture and design choices of the tool suite and lesson learned 
      in developing a reverse-engineering environment.}
}

@MISC{Moha07-Demo-OOPSLA,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {October},
   NOTE         = {Tool demo at the 21<sup>st</sup> International Conference on Object-Oriented Programming, Systems, Languages and Applications.},
   TITLE        = {Ptidej and DECOR: Identification of Design Patterns and 
      Design Defects},
   YEAR         = {2007},
   KEYWORDS     = {Code and design smells, OOPSLA},
   ABSTRACT     = {The Ptidej{} project started in 2001 to study code 
      generation from and identification of patterns. Since then, it has 
      evolved into a complete reverse-engineering tool suite that includes 
      several identification algorithms. It is a flexible tool suite that 
      attempts to ease as much as possible the development of new 
      identification and analysis algorithms. Recently, the module DECOR{} 
      has been added to Ptidej{} and allows the detection of design 
      defects, which are recurring design problems. In this demonstration, 
      we particularly focus on the creation and use of identification 
      algorithms for design patterns and defects.}
}

@INBOOK{Gueheneuc05-OODK-DesignPatternLaws,
   PUBLISHER    = {Idea Group},
   TITLE        = {Design Patterns as Laws of Quality},
   YEAR         = {2006},
   AUTHOR       = {Yann-Gaël Guéhéneuc and Jean-Yves Guyomarc'h and 
      Khashayar Khosravi and Houari Sahraoui},
   CHAPTER      = {5},
   ALTEDITOR    = {},
   PAGES        = {105--142},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   MONTH        = {January},
   NOTE         = {35 pages.},
   OPTNUMBER    = {},
   OPTSERIES    = {},
   OPTTYPE      = {},
   OPTVOLUME    = {},
   BOOKTITLE    = {Object-oriented Design Knowledge: Principles, Heuristics, Best Practices},
   KEYWORDS     = {Quality models, Design patterns, OODK},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OODK05.doc.pdf},
   ABSTRACT     = {This chapter is a complete coverage of our current work 
      on software quality models and on design pattern identification. In 
      this chapter, we explore the idea of facts in science in relation 
      with software quality models. We show how design patterns can be used 
      as facts to devise a quality model and we describe the processes of 
      building and of applying such a quality model.}
}

@ARTICLE{Antoniol06-TSE-FeatureIdentification,
   AUTHOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   JOURNAL      = {Transactions on Software Engineering (TSE)},
   TITLE        = {Feature Identification: An Epidemiological Metaphor},
   YEAR         = {2006},
   MONTH        = {September},
   NOTE         = {15 pages.},
   NUMBER       = {9},
   PAGES        = {627--641},
   VOLUME       = {32},
   EDITOR       = {Tibor Gyimóthy and Vaclav Rajlich},
   KEYWORDS     = {Features and requirements, TSE},
   PUBLISHER    = {IEEE Computer Society Press},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TSE06.doc.pdf},
   ABSTRACT     = {Feature identification is a technique to identify the 
      source code constructs activated when exercising one of the features 
      of a program. We propose new statistical analyses of static and 
      dynamic data to accurately identify features in large multi-threaded 
      object-oriented programs. We draw an inspiration from epidemiology to 
      improve previous approaches to feature identification and develop an 
      epidemiological metaphor. We build our metaphor on our previous 
      approach to feature identification, in which we use processor 
      emulation, knowledge-based filtering, probabilistic ranking, and 
      meta-modelling. We carry out three case studies to assess the 
      usefulness of our metaphor, using the ``save a bookmark" feature of 
      Web browsers as illustration. In the first case study, we compare our 
      approach with three previous approaches (a naive approach, a concept 
      analysis-based approach, and our previous probabilistic approach) in 
      identifying the feature in \ygg@product{Mozilla}, a large, real-life, 
      multi-threaded object-oriented program. In the second case study, we 
      compare the implementation of the feature in the 
      \ygg@product{Firefox} and \ygg@product{Mozilla} Web browsers. In the 
      third case study, we identify the same feature in two more Web 
      browsers, Chimera (in \C) and ICEBrowser (in Java), and another 
      feature in \ygg@product{JHotDraw} and \ygg@product{Xfig}, to 
      highlight the generalisability of our metaphor.}
}

@INPROCEEDINGS{Bouktif06-WCRE-MiningCVS,
   AUTHOR       = {Salah Bouktif and Yann-Gaël Guéhéneuc and 
      Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 13<sup>th</sup> Working Conference on Reverse Engineering (WCRE)},
   TITLE        = {Extracting Change-patterns from CVS Repositories},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Susan Elliott Sim and Di Penta, Massimiliano},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {221--230},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, WCRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE06.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE06.ppt.pdf},
   ABSTRACT     = {Often, the only sources of information about the 
      evolution of software systems are the systems themselves and their 
      histories. Version control repositories contain information on 
      several thousand of files and on millions of changes. We propose an 
      approach based on dynamic time warping to discover change-patterns, 
      which, for example, describe files that change together almost all 
      the time. We define the Synchrony change-pattern to answer the 
      question: given a software system and one file under modification, 
      what others files must be changed? We have applied our approach on 
      PADL{}, a software system developed in Java, and on Mozilla. 
      Interesting results are achieved even when the discovered groups of 
      co-changing files are compared with these provided by experts.}
}

@INPROCEEDINGS{Cote06-WebSupportVIH,
   AUTHOR       = {José Côté and Pilar Ramirez Garcia and 
      Yann-Gaël Guéhéneuc and Xintao Wang and Gaston Godin},
   BOOKTITLE    = {Proceedings of the 15<sup>th</sup> annual Canadian Conference on HIV/Aids Research},
   TITLE        = {Web support for person living with HIV for the immediate 
      management of the treatment},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Gaston Godin and Jean Guy Baril and Jean Pierre Routy},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Pulsus Group},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {VIHTAVIE, CAHR},
   URL          = {http://www.cahr-acrv.ca/english/resources/archive.html},
   ABSTRACT     = {Objective: Demonstration of a Web application designed 
      to equip and support persons living with HIV for the immediate and 
      direct management of their daily antiretorviral treatment.\newline 
      Method: This Web application is based on a comprehensive analysis of 
      the predictors of adherence identified in a longitudinal study, on 
      information collected in the field, and on explanatory and predictive 
      models of health behaviour.\newline Results: The program consists of 
      interactive sessions which enable the individual to develop and 
      consolidate skills necessary for handling taking their medication. 
      These skills include self-motivation and self-observation (basic 
      skills), identification and management of secondary effects (specific 
      skills) and problem-solving, control of emotions and social skills 
      (transferable skills). The sessions help the user gain a sense of 
      self-sufficiency by integrating verbal encouragement and 
      physiological response and generating a sense of being in control. 
      Based on the 'tailoring' approach, these interventions are customized 
      to the users, according to the characteristics of their therapy, 
      secondary effects they feel, and the difficulties or obstacles they 
      experience. The interactive system has been conceived in such a way 
      that repeat applications and re-visits are possible, to suit the 
      needs of the user. In effect, this Web application is like having a 
      vocal 'virtual health professional', who behaves like a peer and acts 
      as a model in providing support to the user for managing taking their 
      medication.\newline Conclusion: This Web application is a interactive 
      tool with a triple interface. It is responsive and flexible and is 
      designed to adapt to needs of the individual user. We will carry out 
      a randomized, controlled trial to evaluate its efficacy in optimizing 
      adherence and influencing virological and immunological markers.}
}

@INPROCEEDINGS{Gueheneuc06-CASCON-Taupe,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> IBM Centers for Advanced Studies Conference (CASCON)},
   TITLE        = {Taupe: Towards Understanding Program Comprehension},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Hakan Erdogmus and Eleni Stroulia},
   MONTH        = {October},
   NOTE         = {13 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {1--13},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Understanding program comprehension, CASCON},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON06.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON06.ppt.pdf},
   ABSTRACT     = {Program comprehension is a very important activity 
      during the development and the maintenance of programs. This activity 
      has been actively studied in the past decades to present software 
      engineers with the most accurate and---hopefully---most useful pieces 
      of information on the organisation, algorithms, executions, 
      evolution, and documentation of a program. Yet, only few work tried 
      \emph{to understand concretely how software engineers obtain and use 
      this information}. Software engineers mainly use \emph{sight} to 
      obtain information about a program, usually from source code or class 
      diagrams. Therefore, we use eye-tracking to collect data about the 
      use of class diagrams by software engineers during program 
      comprehension. We introduce a new visualisation technique to 
      aggregate and to present the collected data. We also report the 
      results and surprising insights gained from two case studies.}
}

@INPROCEEDINGS{Gueheneuc06-CSMR-REToolsTaxonomy,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Kim Mens and Roel Wuyts},
   BOOKTITLE    = {Proceedings of the 10<sup>th</sup> Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {A Comparative Framework for Design Recovery Tools},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {di Lucca, Giuseppe Antonio and Nicolas Gold},
   MONTH        = {March},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {121--130},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR06b.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR06b.ppt.pdf},
   ABSTRACT     = {While many commercial and academic design recovery tools 
      have been proposed over the years, assessing their relevance and 
      comparing them is difficult due to the lack of a well-defined, 
      comprehensive, and common framework. In this paper, we introduce such 
      a common comparative framework. The framework builds upon our own 
      experience and extends existing comparative frameworks. We illustrate 
      the comparative framework on two specific design recovery tools.}
}

@INPROCEEDINGS{Kaczor06-CSMR-EfficientIdentification,
   AUTHOR       = {Olivier Kaczor and Yann-Gaël Guéhéneuc and Sylvie Hamel},
   BOOKTITLE    = {Proceedings of the 10<sup>th</sup> Conference on Software Maintenance and Reengineering (CSMR)},
   TITLE        = {Efficient Identification of Design Patterns with 
      Bit-vector Algorithm},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {di Lucca, Giuseppe Antonio and Nicolas Gold},
   MONTH        = {March},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {173--182},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, CSMR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR06a.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CSMR06a.ppt.pdf},
   ABSTRACT     = {Design patterns are important in software maintenance 
      because they help in designing, in understanding, and in 
      re-engineering programs. The identification of occurrences of a 
      design pattern consists in identifying, in a program, classes which 
      structure and organisation match---strictly or approximately---the 
      structure and organisation of classes as suggested by the design 
      pattern. We express the problem of design pattern identification with 
      operations on finite sets of bit-vectors. We use the inherent 
      parallelism of bit-wise operations to derive an efficient bit-vector 
      algorithm that finds exact and approximate occurrences of design 
      patterns in a program. We apply our algorithm on three 
      small-to-medium size programs, \JHotDraw{}, \ygg@product{Juzzle}, and 
      \ygg@product{QuickUML}, with the \ygg@pattern{Abstract Factory} and 
      \ygg@pattern{Composite} design patterns and compare its performance 
      and results with two existing constraint-based approaches.}
}

@INPROCEEDINGS{Moha06-WOOR-Correction,
   AUTHOR       = {Naouel Moha and Saliha Bouden and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 7<sup>th</sup> ECOOP workshop on Object-Oriented Reengineering (WOOR)},
   TITLE        = {Correction of High-Level Design Defects with 
      Refactorings},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Serge Demeyer and Stéphane Ducasse and 
      Yann-Gaël Guéhéneuc and Kim Mens and Roel Wuyts},
   MONTH        = {July},
   NOTE         = {4 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, WOOR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WOOR06.doc.pdf},
   ABSTRACT     = {We define design defects as ``poor" design solutions 
      that hinder the maintenance of programs. Thus, their detection and 
      correction are important to improve the maintainability and reduce 
      the cost of maintenance. The detection of design defects has been 
      actively investigated by the community. However, their correction 
      still remains a problem to solve. We propose a first method to 
      correct these defects systematically using refactorings. Then, we 
      introduce some challenges that our community must meet.}
}

@INPROCEEDINGS{Moha06-ASE-GenerationDetectionAlgorithms,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc and Pierre Leduc},
   BOOKTITLE    = {Proceedings of the 21<sup>st</sup> Conference on Automated Software Engineering},
   TITLE        = {Automatic Generation of Detection Algorithms for Design 
      Defects},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Sebastian Uchitel and Steve Easterbrook},
   MONTH        = {September},
   NOTE         = {Short paper.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE06.doc.pdf}
}

@INPROCEEDINGS{Moha06-LMO-TaxonomieMetamodele,
   AUTHOR       = {Naouel Moha and Duc-Loc Huynh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {actes du 12<sup>e</sup> colloque Langages et Modèles à Objets},
   TITLE        = {Une taxonomie et un métamodèle pour la détection des 
      défauts de conception},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Roger Rousseau},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {201--216},
   PUBLISHER    = {Hermès Science Publications},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Design defects are similar to design patterns, which are 
      today largely used: design patterns propose ``good'' solutions to 
      recurring design problems in object-oriented architectures, whereas 
      design defects are ``bad'' solutions. However, unlike design 
      patterns, design defects have not yet been widely studied and are 
      based essentially on textual descriptions prone to interpretation. 
      The lack of precise and structured representation of design defects 
      hinders the efficient detection and correction of these defects. We 
      propose a methodology to represent design defects based on a 
      meta-model using a taxonomy of defects. We apply and validate this 
      methodology on a set of design defects such as the Blob and the Swiss 
      Army Knife.}
}

@INPROCEEDINGS{Moha06-CLA-RefactoringSuggestion,
   AUTHOR       = {Naouel Moha and Jihene Rezgui and Yann-Gaël Guéhéneuc and 
      Petko Valtchev and Ghizlane El Boussaidi},
   BOOKTITLE    = {Proceedings of the 4<sup>th</sup> International Conference on Concept Lattices and their Applications},
   TITLE        = {Using FCA to Suggest Refactorings to Correct Design 
      Defects},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Sadok Ben Yahia and Engelbert Mephu Nguifo},
   MONTH        = {September},
   NOTE         = {Short paper. 6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {297--302},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, CLA},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CLA06.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CLA06.ppt.pdf},
   ABSTRACT     = {Design defects are poor design choices resulting in a 
      hard-to- maintain software, hence their detection and correction are 
      key steps of a disciplined software process aimed at yielding 
      high-quality software artifacts. While modern structure- and 
      metric-based techniques enable precise detection of design defects, 
      the correction of the discovered defects, e.g., by means of 
      refactorings, remains a manual, hence error-prone, activity. As many 
      of the refactorings amount to re-distributing class members over a 
      (possibly extended) set of classes, formal concept analysis (FCA) has 
      been successfully applied in the past as a formal framework for 
      refactoring exploration. Here we propose a novel approach for defect 
      removal in object-oriented programs that combines the effectiveness 
      of metrics with the theoretical strength of FCA. A case study of a 
      specific defect, the \textit{Blob}, drawn from the Azureus project 
      illustrates our approach.}
}

@INPROCEEDINGS{Poshyvanyk06-ICPC-LSIFeature,
   AUTHOR       = {Denys Poshyvanyk and Yann-Gaël Guéhéneuc and 
      Andrian Marcus and Giuliano Antoniol and Václav Rajlich},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> International Conference on Program Comprehension (ICPC)},
   TITLE        = {Combining Probabilistic Ranking and Latent Semantic 
      Indexing for Feature Identification},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Jurgen Ebert and Panos Linos},
   MONTH        = {June},
   NOTE         = {Best paper. 10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {137--148},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, ICPC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC06.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICPC06.ppt.pdf},
   ABSTRACT     = {The paper recasts the problem of feature location in 
      source code as a decision-making problem in the presence of 
      uncertainty. The main contribution consists in the combination of two 
      existing techniques for feature location in source code. Both 
      techniques provide a set of ranked facts from the software, as result 
      to the feature identification problem. One of the techniques is based 
      on a Scenario Based Probabilistic ranking of events observed while 
      executing a program under given scenarios. The other technique is 
      defined as an information retrieval task, based on the Latent 
      Semantic Indexing of the source code. We show the viability and 
      effectiveness of the combined technique with two case studies. A 
      first case study is a replication of feature identification in 
      Mozilla, which allows us to directly compare the results with 
      previously published data. The other case study is a bug location 
      problem in Mozilla. The results show that the combined technique 
      improves feature identification significantly with respect to each 
      technique used independently.}
}

@MASTERSTHESIS{Guyomarch06-M.Sc.,
   AUTHOR       = {Jean-Yves Guyomarc'h},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Une architecture pour l'évaluation qualitative de 
      l'impact de la programmation orientée aspect},
   YEAR         = {2006},
   OPTADDRESS   = {},
   MONTH        = {Mai},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/Publications/Documents/Thesis+of+Jean-Yves+Guyomarch.doc.pdf},
   ABSTRACT     = {Les limitations de la programmation orient\'ee objet ont 
      pouss\'e les chercheurs en g\'enie logiciel \`a pr\'econiser une 
      r\'eelle \og s\'eparation des pr\'eoccupations \fg qui permette, 
      entre autres, une meilleure modularit\'e et r\'eutilisabilit\'e du 
      code source. Ce souci a donn\'e naissance \`a la programmation 
      orient\'ee aspect, qui propose d'encapsuler dans des aspects les 
      pr\'eoccupations incompatibles avec la logique m\'etier des objets. 
      Les aspects sont capables d'injecter ensuite le code n\'ecessaire \`a 
      ces pr\'eoccupations en utilisant leurs propres m\'ecanismes (points 
      de coupure, greffons et introductions). La naissance d'un nouveau 
      paradigme implique son \'etude en termes de qualit\'e. Dans le cas de 
      la programmation orient\'ee aspect, il faut aussi tenir compte de son 
      impact sur les programmes orient\'es objet. Nous proposons de 
      quantifier cet impact par l'utilisation des m\'etriques de classe. Le 
      calcul de ces m\'etriques est modifi\'e pour refl\'eter les 
      r\'epercussions des diff\'erents m\'ecanismes de la programmation 
      orient\'ee aspect. Ceci nous permet d'implanter une architecture 
      pouvant produire des jeux de m\'etriques avant et apr\`es 
      introduction des aspects. Gr\^ace \`a ces r\'esultats, nous sommes en 
      mesure de mener une exp\'erience en utilisant la visualisation. Cette 
      exp\'erience prouve que des ing\'enieurs en g\'enie logiciel peuvent 
      \'evaluer l'impact de la programmation orient\'ee aspect en termes de 
      qualit\'e et que la restructuration d'un programme orient\'e objet 
      par les aspects peut am\'eliorer sa qualit\'e.}
}

@MISC{Moha06-Demo-CASCON,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {October},
   NOTE         = {Tool demo at the 16<sup>th</sup> IBM Centers for Advanced Studies Conference.},
   TITLE        = {DECOR and Ptidej},
   YEAR         = {2006},
   KEYWORDS     = {Code and design smells, Design patterns, CASCON},
   URL          = {https://www-927.ibm.com/ibm/cas/archives/2006/demos/mdlware.shtml},
   ABSTRACT     = {We demonstrate the use of the Decor method and Ptidej 
      tool suite on real case studies to specify, detect, and correct 
      design defects. Design defects are problems that slow down and 
      increase the cost of programs, because they make program 
      understanding and change difficult. Targeted audience includes 
      academics and industrial software developers, managers, and 
      quality-insurance people.}
}

@PROCEEDINGS{WOOR05,
   TITLE        = {Report of the 6<sup>th</sup> international Workshop on 
      Object-Oriented Reengineering (WOOR)},
   YEAR         = {2005},
   OPTADDRESS   = {},
   EDITOR       = {Serge Demeyer and Kim Mens and Roel Wuyts and 
      Yann-Gaël Guéhéneuc and Andy Zaidman and Neil Walkinshaw and 
      Ademar Aguiar and Stéphane Ducasse},
   MONTH        = {July},
   NOTE         = {12 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05WOORReader.doc.pdf}
}

@INPROCEEDINGS{Antoniol05-ICSM-FeatureIdentification,
   AUTHOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 21<sup>st</sup> International Conference on Software Maintenance (ICSM)},
   TITLE        = {Feature Identification: A Novel Approach and a Case 
      Study},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Tibor Gyimóthy and Vaclav Rajlich},
   MONTH        = {September},
   NOTE         = {Best paper. 10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {357--366},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM05.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM05.ppt.pdf},
   ABSTRACT     = {Feature identification is a well-known technique to 
      identify subsets of a program source code activated when exercising a 
      functionality. Several approaches have been proposed to identify 
      features. We present an approach to feature identification and 
      comparison for large object-oriented multi-threaded programs using 
      both static and dynamic data. We use processor emulation, knowledge 
      filtering, and probabilistic ranking to overcome the difficulties of 
      collecting dynamic data, i.e., imprecision and noise. We use model 
      transformations to compare and to visualise identified features. We 
      compare our approach with a naive approach and a concept 
      analysis-based approach using a case study on a real-life large 
      object-oriented multi-threaded program, \ygg@product{Mozilla}, to 
      show the advantages of our approach. We also use the case study to 
      compare processor emulation with statistical profiling.}
}

@INPROCEEDINGS{Antoniol05-WESRE-NeedEmpiricalEvidence,
   AUTHOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc and 
      Ettore Merlo and Houari Sahraoui},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> ICSM workshop on Empirical Studies in Reverse Engineering (WESRE)},
   TITLE        = {Software Evolution: The Need for Empirical Evidence},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Paolo Tonella},
   MONTH        = {September},
   NOTE         = {2 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Evolution patterns, WESRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WESRE05.doc.pdf},
   ABSTRACT     = {An intrinsic property of software is its malleability, 
      the fact that it may change and evolve. Software evolution is costly, 
      because software systems tend to be highly complex and large. They 
      are highly humanintens ive and risky, because unplanned and 
      undisciplined changes in any software system of realistic size risk 
      degrading software quality and may produce unwanted and unexpected 
      side effects. As a software system is enhanced, modified, and adapted 
      to new requirements, its code becomes increasingly complex, often 
      drifting away from its original design. The current state-of-the-art 
      in software evolution offers only short-term solutions to software 
      change and evolution focused on software maintenance and defect 
      repair, in which only the source code evolves, while the 
      architecture, design, and---more generally---the documentation are 
      not updated.}
}

@INPROCEEDINGS{Antoniol05-TEFSE-FeatureTraceability,
   AUTHOR       = {Giuliano Antoniol and Ettore Merlo and 
      Yann-Gaël Guéhéneuc and Houari Sahraoui},
   BOOKTITLE    = {Proceedings of the 3<sup>rd</sup> ASE workshop on Traceability in Emerging Forms of Software Engineering (TEFSE)},
   TITLE        = {Feature Traceability in Object Oriented Software},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Jonathan I. Maletic and Giuliano Antonio and 
      Jane Cleland-Huang and Jane Huffman Hayes},
   MONTH        = {November},
   NOTE         = {6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {73--78},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Features and requirements, TEFSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TEFSE05.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TEFSE05.ppt.pdf},
   ABSTRACT     = {Open source and industrial software very often lack 
      up-to- date documentation on where and how user observable 
      functionalities are implemented. This lack of documentation is 
      particularly hindering for large software. Moreover, as with any 
      software artifacts, user observable functionalities evolve and are 
      modified through software evolution activities. Modifications of one 
      functionality sometimes has unwanted and unexpected side effects on 
      other functionalities, causing these functionalities to fail or to 
      malfunction. In this position paper, we support the idea that a 
      traceability mapping between user observable functionalities and 
      source code constituents (such as classes, methods\ldots) 
      implementing the functionalities is essential to reduce software 
      evolution effort. We outline an approach to recover and to study the 
      evolution of features---subset of a software 
      constituents---responsible to implement a functionality.}
}

@INPROCEEDINGS{Gaffar05-IWDPTP-SemanticsDesignPattern,
   AUTHOR       = {Ashraf Gaffar and Naouel Moha},
   BOOKTITLE    = {Proceedings of the STEP International Workshop on Design Pattern Theory and Practice (IWDPTP05)},
   TITLE        = {Semantics of a Pattern System},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {The wide acceptance of the Design Patterns has 
      encouraged experts in other software domains to formulate their 
      experience into pattern format hoping to make it readily reused by 
      developers. We now have numerous pattern collections covering all 
      aspects of software development from analysis to deployment and 
      refactoring. But developers can be overwhelmed by this large number 
      and the lack of coordination and in consistencies among them. These 
      patterns have many similarities and redundancies which may contribute 
      to misunderstanding and wrong reuse. Some research has proposed 
      standards to writing patterns but they were rarely used because each 
      pattern author prefers to use their own creativity which is often a 
      good thing. We propose another approach to address this problem. In 
      each specific software domain, we collect and pre-process existing 
      patterns by defining, detecting and removing some kinds of 
      redundancies between them. The result is a smaller collection of 
      patterns from different sources that have fewer redundancies which 
      reduces confusion and promotes the proper reuse.}
}

@INPROCEEDINGS{Guyomarch05-QAOOSE-AspectQuality,
   AUTHOR       = {Jean-Yves Guyomarc'h and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 9<sup>th</sup> ECOOP workshop on Quantitative Approaches in Object-Oriented Software Engineering (QAOOSE)},
   TITLE        = {On the Impact of Aspect-Oriented Programming on 
      Object-Oriented Metrics},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {e Abreu, Fernando Brito and Coral Calero and 
      Michele Lanza and Geert Poels and Houari A. Sahraoui},
   MONTH        = {July},
   NOTE         = {6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {42--47},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, QAOOSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05QAOOSEa.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05QAOOSEa.ppt.pdf},
   ABSTRACT     = {Aspect-oriented programming is a new paradigm designed 
      to fulfill the limitations of object-oriented programming regarding 
      separation of concerns. The advent of a new paradigm requires 
      software engineers to define new metrics and quality models to 
      measure the quality of programs in this paradigm. The close 
      relationship of aspect-oriented programming and object-oriented 
      languages drives us to wonder about the impact of this new paradigm 
      over object-oriented languages, and especially over object metrics. 
      In this position paper, we attempt to present an approach to study 
      and to understand the impact of aspect-oriented programming on 
      object-oriented metrics.}
}

@INPROCEEDINGS{Gueheneuc05-BSUP-Ptidej,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> ECOOP workshop on Building a System using Patterns},
   TITLE        = {Ptidej: Promoting Patterns with Patterns},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mohamed E. Fayad},
   MONTH        = {July},
   NOTE         = {9 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, BSUP},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05BSUP.doc.pdf},
   ABSTRACT     = {We introduce the Ptidej{} project and its tool suite to 
      evaluate and to enhance software quality by promoting patterns. 
      First, we summarise the components of the tool suite and describe its 
      implementation in Java, which uses several architectural, design, and 
      language patterns. Then, we take position on issues related to 
      pattern claims, choices, uses, and limits from our experience with 
      pattern definition, formalisation, use for reverse-engineering and 
      for implementation.}
}

@INPROCEEDINGS{Gueheneuc05-IWDPTP-ExperimentalSetting,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Stefan Monnier and 
      Giuliano Antoniol},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> ICSM workshop in Design Pattern Theory and Practice (IWDPTP)},
   TITLE        = {Evaluating the Use of Design Patterns during Program 
      Comprehension -- Experimental Setting},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   MONTH        = {September},
   NOTE         = {In the pre-proceedings. 6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Understanding program comprehension, IWDPTP},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IWDPTP05.doc.pdf},
   ABSTRACT     = {Many claims exist in the literature on the usefulness of 
      design patterns for program comprehension. However, no experimental 
      studies exist to confirm or to infirm these claims, partially due to 
      the lack of appropriate techniques to define and to assess the 
      benefits of design patterns. We present an experimental setting, 
      based on eye-tracking techniques, to assess the benefits of design 
      patterns during program comprehension and a first illustrative 
      experiment. This experimental setting and experiment are but a first 
      step towards a comprehensive understanding of the use of design 
      patterns during program comprehension.}
}

@INPROCEEDINGS{Gueheneuc05-LMO-SignaturesNumeriques,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Houari Sahraoui},
   BOOKTITLE    = {Actes du 11<sup>e</sup> colloque Langages et Modèles à Objets (LMO)},
   TITLE        = {Des signatures numériques pour améliorer la recherche 
      structurelle de patrons},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Marianne Huchard and Stéphane Ducasse and 
      Oscar Nierstrasz},
   MONTH        = {mars},
   NOTE         = {16 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {97--112},
   PUBLISHER    = {Hermès Science Publications},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, LMO},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO05.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO05.ppt.pdf},
   ABSTRACT     = {Les patrons de conception orient\'es-objets d\'ecrivent 
      de bonnes solutions \`a des probl\`emes r\'ecurrents de conception 
      des programmes. Les solutions propos\'ees sont des motifs de 
      conception que les concepteurs introduisent dans l'architecture de 
      leurs programmes. Il est important d'identifier, pendant la 
      maintenance, les motifs de conception utilis\'es dans l'architecture 
      d'un programme pour comprendre les probl\`emes de conception 
      r\'esolus et faire des modifications pertinentes au programme. 
      L'identification de micro-architectures similaires \`a des motifs de 
      conception est difficile \`a cause du large espace de recherche, 
      \ie{} les nombreuses combinaisons de classes possibles. Nous 
      proposons une \'etude exp\'erimentale des classes jouant un r\^ole 
      dans des motifs de conception avec des m\'etriques et un algorithme 
      d'apprentissage pour associer des signatures num\'eriques aux r\^oles 
      dans les motifs de conception. Une signature num\'erique est un 
      ensemble de valeurs de m\'etriques qui caract\'erise les classes 
      jouant un r\^ole dans un motif de conception. Nous montrons que les 
      signatures num\'eriques permettent de r\'eduire efficacement l'espace 
      de recherche des micro-architectures similaires \`a des motifs de 
      conception sur l'exemple du patron de conception Composite et du 
      programme \JHotDraw.}
}

@INPROCEEDINGS{Gueheneuc05-WOOR-SequenceDiagrams,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Tewfik Ziadi},
   BOOKTITLE    = {Proceedings of the 6<sup>th</sup> ECOOP workshop on Object-Oriented Reengineering (WOOR)},
   TITLE        = {Automated Reverse-Engineering of UML v2.0 Dynamic Models},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Serge Demeyer and Stéphane Ducasse and Kim Mens and 
      Roel Wuyts},
   MONTH        = {July},
   NOTE         = {5 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, WOOR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05WOORb.doc.pdf},
   ABSTRACT     = {In this position paper, we advocate the automated 
      reverse-engineering of UML{} v2.0 dynamic models, \ie{} sequence 
      diagrams and statecharts, to perform high-level analyses, such as 
      conformance checking and pattern identification. Several approaches 
      exist to reverse-engineer UML dynamic models; However, to our best 
      knowledge, none of these approaches consider reverse-engineering UML 
      v2.0 dynamic models and performing high-level analyses with these 
      models. We present our approach to UML v2.0 dynamic models 
      reverse-engineering and sketch some use of these models. We conclude 
      by a discussion on some issues related to the models, their 
      reverse-engineering, and their use.}
}

@INPROCEEDINGS{Khosravi05-QAOOSE-QualityIssues,
   AUTHOR       = {Khashayar Khosravi and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 9<sup>th</sup> ECOOP workshop on Quantitative Approaches in Object-Oriented Software Engineering (QAOOSE)},
   TITLE        = {Open Issues with Quality Models},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {e Abreu, Fernando Brito and Coral Calero and 
      Michele Lanza and Geert Poels and Houari A. Sahraoui},
   MONTH        = {July},
   NOTE         = {14 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Quality models, Design patterns, QAOOSE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05QAOOSEb.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05QAOOSEb.ppt.pdf},
   ABSTRACT     = {Software metrics and quality models play a pivotal role 
      in measurement of software quality. A number of well-known quality 
      models and software metrics are used to build quality software both 
      in industry and in academia. However, during our research on 
      measuring software quality using design patterns, we faced many 
      issues related to existing software metrics and quality models. In 
      this position paper, we discuss some of these issues and present our 
      approach to software quality assessment.}
}

@INPROCEEDINGS{Moha05-WOOR-DesignDefects,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 6<sup>th</sup> ECOOP workshop on Object-Oriented Reengineering (WOOR)},
   TITLE        = {On the Automatic Detection and Correction of Design 
      Defects},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Serge Demeyer and Kim Mens and Roel Wuyts and 
      Stéphane Ducasse},
   MONTH        = {July},
   NOTE         = {7 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, WOOR},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05WOORa.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP05WOORa.ppt.pdf},
   ABSTRACT     = {Design defects, antipatterns, code smells are software 
      defects at the architectural level that must be detected and 
      corrected to improve software quality. Automatic detection and 
      correction of these software architectural defects, which suffer of a 
      lack of tools, are important to ease the maintenance of 
      objectoriented architectures and thus to reduce the cost of 
      maintenance. A clear understanding of the different types of software 
      architectural defects defects and a classification of these defects 
      is necessary before proposing any techniques related to their 
      detection or correction. We introduce a first classification and 
      summarise existing techniques. Then, we introduce some challenges 
      that our community must meet.}
}

@INPROCEEDINGS{Moha05-WOOR-SAD,
   AUTHOR       = {Naouel Moha and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 6<sup>th</sup> ECOOP Workshop on Object-Oriented Reengineering},
   TITLE        = {On the Automatic Detection and Correction of Software 
      Architectural Defects in Object-Oriented Designs},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Serge Demeyer and Kim Mens and Roel Wuyts and 
      Stéphane Ducasse},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Design defects, antipatterns, code smells are software 
      defects at the architectural level that must be detected and 
      corrected to improve software quality. Automatic detection and 
      correction of these software architectural defects, which suffer of a 
      lack of tools, are important to ease the maintenance of 
      object-oriented architectures and thus to reduce the cost of 
      maintenance. A clear understanding of the different types of software 
      architectural defects and a classification of these defects is 
      necessary before proposing any techniques related to their detection 
      or correction. We introduce a first classification and summarise 
      existing techniques. Then, we introduce some challenges that our 
      community must meet.}
}

@INPROCEEDINGS{Moha05-IWDPTP-Taxonomy,
   AUTHOR       = {Naouel Moha and Duc-Loc Huynh and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the STEP International Workshop on Design Pattern Theory and Practice (IWDPTP05)},
   TITLE        = {A Taxonomy and a First Study of Design Pattern Defects},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Giuliano Antoniol and Yann-Gaël Guéhéneuc},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Design patterns propose good solutions to recurring 
      design problems in object-oriented architectures. Design patterns 
      have been quickly adopted by the Software Engineering community and 
      are now widely spread. We define design pattern defects as occurring 
      errors in the design of a software that come from the absence or the 
      bad use of design patterns. Design pattern defects are software 
      defects at the architectural level that must be detected and 
      corrected to improve software quality. Automatic detection and 
      correction of these software architectural defects, which suffer of a 
      lack of tools, are important to improve object-oriented architectures 
      and, thus, to ease maintenance. We propose a first taxonomy of design 
      pattern defects and presents techniques and tools to detect these 
      defects in source code.}
}

@TECHREPORT{Gueheneuc05-TR-VisionComprehension,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   INSTITUTION  = {University of Montreal},
   TITLE        = {A Theory of Program Comprehension -- Joining Vision 
      Science and Program Comprehension},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {December},
   NOTE         = {26 pages.},
   NUMBER       = {1267},
   OPTTYPE      = {},
   KEYWORDS     = {Understanding program comprehension},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Vision+Comprehension+December05.doc.pdf},
   ABSTRACT     = {There exists an extensive literature on vision science, 
      on the one hand, and on program comprehension, on the other hand. 
      However, these two domains of research have been so far rather 
      disjoint. Indeed, several cognitive theories have been proposed to 
      explain program comprehension. These theories explain the processes 
      taking place in the software engineers' minds when they understand 
      programs. They explain how software engineers \emph{process} 
      available information to perform their tasks but not how software 
      engineers \emph{acquire} this information. Vision science provides 
      explanations on the processes used by people to acquire visual 
      information from their environment. Joining vision science and 
      program comprehension provides a more comprehensive theoretical 
      framework to explain facts on program comprehension, to predict new 
      facts, and to frame experiments. We join theories in vision science 
      and in program comprehension; the resulting theory is consistent with 
      facts on program comprehension and helps in predicting new facts, in 
      devising experiments, and in putting certain program comprehension 
      concepts in perspective.}
}

@TECHREPORT{Moha05-TR-CatalogDesignDefects,
   AUTHOR       = {Naouel Moha},
   INSTITUTION  = {Department of Computer Science and Operations Research, University of Montréal},
   TITLE        = {catalogue of Design Defects},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTTYPE      = {},
   PAGES        = {20},
   URL          = {http://www.ptidej.net/Members/mohanaou/technicalreport/CatalogDesignDefects.pdf}
}

@MASTERSTHESIS{Kaczor05-MSc,
   AUTHOR       = {Olivier Kaczor},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Application d'algorithmes de bio-informatique à la 
      recherche de patrons de conception},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {Août},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Olivier+Kaczor.doc.pdf},
   ABSTRACT     = {La maintenance de programmes orient\'es objets est une 
      activit\'e tr\`es co\^uteuse et la compr\'ehension des programmes est 
      essentielle pour les mainteneurs. L'identification de 
      micro-architectures similaires aux motifs de conception dans un 
      programme aide \`a comprendre les probl\`emes rencontr\'es lors de sa 
      conception ainsi que les solutions apport\'ees. Les techniques 
      existantes utilis\'ees pour la recherche de motifs de conception 
      pr\'esentent toutes, cependant, un probl\`eme de performance. Ce 
      travail de recherche propose une solution \`a ce probl\`eme en 
      adaptant des algorithmes efficaces de comparaisons et d'alignements 
      de cha\^{\i}nes de caract\`eres de bio-informatique. Des cha\^{\i}nes 
      de caract\`eres repr\'esentant les programmes et les patrons de 
      conception sont d'abord construites et ensuite compar\'ees \`a l'aide 
      d'algorithmes de programmation dynamique, de simulation d'automates 
      ou de vecteurs de bits. Nous appliquons notre approche \`a plusieurs 
      programmes de tailles diff\'erentes et comparons nos r\'esultats avec 
      ceux de deux outils utilisant la programmation par contraintes avec 
      explications. Contrairement aux deux outils compar\'es, notre 
      approche s'av\`ere tr\`es efficace et permet une analyse relativement 
      rapide de programmes de grandes tailles.}
}

@MASTERSTHESIS{Khosravi05-MSc,
   AUTHOR       = {Khashayar Khosravi},
   SCHOOL       = {Université de Montréal},
   TITLE        = {A Quality Model considering Program Architecture},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Khashayar+Khosravi.doc.pdf},
   ABSTRACT     = {Maintenance cost of object-oriented programs during the 
      past decades increased to more than 70\% of the overall cost of 
      programs 
      \cite{SahraouiBoukadoumLounis01-Quality,Pressman92-SoftwareEngineering}. 
      Maintenance is expensive and tedious because of the difficulty to 
      predict maintenance effort. Quality is the more important part of 
      software development, because high quality in software development 
      could reduce the software development cost dramatically. Software 
      quality models link internal attributes of programs with external 
      quality characteristics. They help in understanding relationships 
      among internal attributes and between internal attributes and quality 
      characteristics. Object-oriented software quality models usually use 
      metrics on classes (such as number of methods) or on relationships 
      between classes (for example coupling) to measure internal attributes 
      of programs. However, the quality of object-oriented programs does 
      not depend on classes solely: It depends on the organisation of 
      classes---the program architectures---also. We propose an approach to 
      build quality models using design patterns to consider program 
      architectures. Design patterns are simple and elegant solution to 
      reusing object oriented software designs. We study the gain and loss 
      in software quality when using design patterns, which claim to bring 
      flexibility, elegancy and reusability to software design 
      \cite{GoF94-Patterns}. First, we evaluate the concrete quality 
      characteristics of design patterns by evaluating programs implemented 
      with and without design patterns manually and using metrics. Then, we 
      study the flexibility, elegancy, and reusability of programs, to 
      assess their coverage of software quality, other quality 
      characteristics and the interrelationships among quality 
      characteristics. We detail the building of a software quality model 
      using design patterns. Finally, we introduce a first case study in 
      building and in applying a quality model using design patterns on the 
      \JHotDraw{}, \JUnit{}, and \Lexi{} programs. This dissertation 
      intends to assist object-oriented software quality measurement, 
      improving software evaluation by building a quality model using 
      design patterns and considering program architectures.}
}

@MASTERSTHESIS{Rached05-MSc,
   AUTHOR       = {Samah Rached},
   SCHOOL       = {Université de Montréal},
   TITLE        = {Analyse du comportement des programmes à l'aide des 
      matrices d'adjacence},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {Août},
   OPTNOTE      = {},
   OPTTYPE      = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Thesis+of+Samah+Rached.doc.pdf},
   ABSTRACT     = {La maintenance des programmes orient\'es objets est 
      difficile car elle d\'epend de la compr\'e\-hension du programme par 
      les mainteneurs. Nous cherchons \`a faciliter la compr\'ehension des 
      programmes par la visualisation des donn\'ees statiques et 
      dynamiques. Nous utilisons une repr\'esentation graphique sous forme 
      de matrices d'adjacence qui permet de visualiser les relations 
      statiques et dynamiques entre les classes de grands programmes. Nous 
      lions les donn\'ees dynamiques avec des donn\'ees statiques pour 
      aider les mainteneurs \`a comprendre les relations entre les classes, 
      \`a avoir une vue architecturale du syst\`eme tout au long des 
      investigations des mainteneurs, \`a identifier les fonctionnalit\'es 
      des programmes et \`a d\'etecter les traitements r\'ep\'etitifs en 
      vue d'avoir des abstractions de plus haut niveau. Nous avons con\c cu 
      un syst\`eme, DRAM (Dynamic Relational Adjacency Matrix), qui utilise 
      l'analyse dynamique pour g\'en\'erer des traces des programmes, nous 
      l'enrichissons avec l'analyse statique puis d\'eveloppons 
      diff\'erents algorithmes de conversion des donn\'ees sous forme de 
      matrices d'adjacence : groupement par classes et/ou m\'ethodes, 
      recherche de fonctionnalit\'es du programme. Enfin, nous 
      exp\'erimentons notre approche sur JUnit, JHotdraw pour montrer 
      l'int\'er\^et et les limites de notre approche.}
}

@MISC{Gueheneuc05-Demo-CASCON,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Jean-Yves Guyomarc'h and 
      Duc-Loc Huynh and Olivier Kaczor and Naouel Moha and Samah Rached},
   OPTHOWPUBLISHED = {},
   MONTH        = {October},
   NOTE         = {Tool demo at the 15<sup>th</sup> IBM Centers for Advanced Studies Conference.},
   TITLE        = {Ptidej - A Tool Suite},
   YEAR         = {2005},
   KEYWORDS     = {Design patterns, CASCON},
   URL          = {https://www-927.ibm.com/ibm/cas/archives/2005/demos/},
   ABSTRACT     = {The Ptidej (Pattern Trace Identification, Detection, and 
      Enhancement in Java) project aims at developing a tool suite to 
      evaluate and to enhance the quality of object-oriented programs, 
      promoting the use of patterns, at language-, design-, or 
      architectural-level.}
}

@INPROCEEDINGS{Gueheneuc04-CASCON-PreciseClassDiagrams,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 14<sup>th</sup> IBM Centers for Advanced Studies Conference (CASCON)},
   TITLE        = {A Reverse Engineering Tool for Precise Class Diagrams},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Janice Singer and Hanan Lutfiyya},
   MONTH        = {October},
   NOTE         = {14 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {28--41},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Binary class relations, CASCON},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON04.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/CASCON04.ppt.pdf},
   ABSTRACT     = {Developers use class diagrams to des\-cribe the 
      architecture of their programs intensively. Class diagrams represent 
      the structure and global behaviour of programs. They show the 
      programs classes and interfaces and their relationships of 
      inheritance, instantiation, use, association, aggregation and 
      composition. Class diagrams could provide useful data during programs 
      maintenance. However, they often are obsolete and imprecise: They do 
      not reflect the \emph{real} implementation and behaviour of programs. 
      We propose a reverse-engineering tool suite, Ptidej{}, to build 
      precise class diagrams from Java{} programs, with respect to their 
      implementation and behaviour. We describe static and dynamic models 
      of Java{} programs and algorithms to analyse these models and to 
      build class diagrams. In particular, we detail algorithms to infer 
      use, association, aggregation, and composition relationships, because 
      these relationships do not have precise definitions. We show that 
      class diagrams obtained semi-automatically are similar to those 
      obtained manually and more precise than those provided usually.}
}

@INPROCEEDINGS{Gueheneuc04-APSEC-SystematicUML,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> Asia-Pacific Software Engineering Conference (APSEC)},
   TITLE        = {A Systematic Study of UML Class Diagram Constituents for 
      their Abstract and Precise Recovery},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Doo-Hwan Bae and William C. Chu},
   MONTH        = {November-December},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {265--274},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Binary class relations, APSEC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/APSEC04.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/APSEC04.ppt.pdf},
   ABSTRACT     = {Existing reverse-engineering tools use algorithms based 
      on vague and verbose definitions of UML{} constituents to recover 
      class diagrams from source code. Thus, reverse-engineered class 
      diagrams are neither abstract nor precise representations of source 
      code and are of little interest for software engineers. We propose a 
      exhaustive study of class diagram constituents with respect to their 
      recovery from \Cpp{}, Java{}, and \Smalltalk{} source code. Finally, 
      we suggest a road-map to abstract and precise reverse-engineering. We 
      exemplify our study by developing a tool to reverse-engineer Java{} 
      programs in UML{} class diagrams abstractly and precisely. Such a 
      reverse-engineering tool produces class diagrams that help software 
      engineers in better understanding programs.}
}

@INPROCEEDINGS{Gueheneuc04-ICSM-P-UMLRecovery,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 20<sup>th</sup> International Conference and Software Maintenance (ICSM)},
   TITLE        = {Abstract and Precise Recovery of UML Class Diagram 
      Constituents},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Mark Harman and Bogdan Korel},
   MONTH        = {September},
   NOTE         = {Poster. 1 page.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {523},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Binary class relations, ICSM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ICSM04.doc.pdf},
   ABSTRACT     = {Existing reverse-engineering tools use algorithms based 
      on vague and verbose definitions of UML{} constituents to recover 
      class diagrams from source code. Thus, reverse-engineered class 
      diagrams are neither abstract nor precise representations of source 
      code and are of little interest for software engineers. We propose a 
      exhaustive study of class diagrams constituents with respect to their 
      recovery from \Cpp{}, Java{}, and \Smalltalk{} source code. Finally, 
      we suggest a road-map to abstract and precise reverse-engineering.}
}

@INPROCEEDINGS{Gueheneuc04-OOPSLA-RecoveringBCR,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Hervé Albin-Amiot},
   BOOKTITLE    = {Proceedings of the 19<sup>th</sup> Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)},
   TITLE        = {Recovering Binary Class Relationships: Putting Icing on 
      the UML Cake},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Doug C. Schmidt},
   MONTH        = {October},
   NOTE         = {14 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {301--314},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Binary class relations, OOPSLA},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OOPSLA04.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OOPSLA04.ppt.pdf},
   ABSTRACT     = {A discontinuity exists between object-oriented modeling 
      and programming languages. This discontinuity arises from ambiguous 
      concepts in modeling languages and a lack of corresponding concepts 
      in programming languages. It is particularly acute for binary class 
      relation\-ships---association, aggregation, and composition. It 
      hinders the traceability between software implementation and design, 
      thus hampering software analysis. We propose consensual definitions 
      of the binary class relationships with four minimal 
      properties---exclusivity, invocation site, lifetime, multiplicity. We 
      describe algorithms to detect automatically the properties in source 
      code and apply these on several frameworks. Thus, we bridge the gap 
      between implementation and design for the binary class relationships, 
      easing software analysis.}
}

@INPROCEEDINGS{Gueheneuc04-WCRE-ClassFingerprinting,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Houari Sahraoui and Farouk Zaidi},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> Working Conference on Reverse Engineering (WCRE)},
   TITLE        = {Fingerprinting Design Patterns},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Eleni Stroulia and de Lucia, Andrea},
   MONTH        = {November},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {172--181},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, WCRE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE04.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/WCRE04.ppt.pdf},
   ABSTRACT     = {Design patterns describe \emph{good} solutions to common 
      and recurring problems in program design. The solutions are 
      \emph{design motifs} which software engineers imitate and introduce 
      in the architecture of their program. It is important to identify the 
      design motifs used in a program architecture to understand solved 
      design problems and to make informed changes to the program. The 
      identification of \emph{micro-architectures} similar to design motifs 
      is difficult because of the large search space, \ie{} the many 
      possible combinations of classes. We propose an experimental study of 
      classes playing roles in design motifs using metrics and a machine 
      learning algorithm to \emph{fingerprint} design motifs roles. 
      Fingerprints are sets of metric values characterising classes playing 
      a given role. We devise fingerprints experimentally using a 
      repository of micro-architectures similar to design motifs. We show 
      that fingerprints help in reducing the search space of 
      micro-architectures similar to design motifs efficiently using the 
      \ygg@pattern{Composite} design motif and the \JHotDraw{} framework.}
}

@TECHREPORT{Khosravi04-TR-DPQualityModel,
   AUTHOR       = {Khashayar Khosravi and Yann-Gaël Guéhéneuc},
   INSTITUTION  = {University of Montreal},
   TITLE        = {A Quality Model for Design Patterns},
   YEAR         = {2004},
   OPTADDRESS   = {},
   MONTH        = {September},
   NOTE         = {94 pages.},
   NUMBER       = {1249},
   OPTTYPE      = {},
   KEYWORDS     = {Quality models, Design patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Quality+Models+September04.doc.pdf},
   ABSTRACT     = {Design patterns are high level building blocks that are 
      claimed to promote elegance in object-oriented programs by increasing 
      flexibility, scalability, usability, reusability, and robustness. 
      However, there is some evidence that design patterns do not 
      intrinsically promote quality. We believe that the problem of quality 
      with design patterns comes both from the design patterns themselves 
      and from their misuse. Unfortunately, little work has attempted so 
      far to study the quality characteristics of design patterns 
      rigorously. The objective of this technical report is to introduce a 
      quality model and metrics that help in assessing the quality 
      characteristics of design patterns and in concluding on design 
      patterns quality. We begin with a summary of definitions on quality 
      and related concepts and by introducing the most common and standard 
      quality models. Then, we define characteristics of the models in 
      details and present the metrics used to measure programs. Some of the 
      most common characteristics of quality models introduced are used to 
      develop a quality model to assess and measure the quality 
      characteristics that design patterns claim to possess.}
}

@MISC{PMARt,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {since November},
   NOTE         = {A database of occurrences of patterns in object-oriented programs.},
   TITLE        = {PMARt},
   YEAR         = {2004},
   KEYWORDS     = {Design patterns},
   URL          = {http://www.ptidej.net/}
}

@PHDTHESIS{Gueheneuc03-PhD,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   SCHOOL       = {École des Mines de Nantes et Université de Nantes},
   TITLE        = {Un cadre pour la traçabilité des motifs de conception},
   YEAR         = {2003},
   OPTADDRESS   = {},
   MONTH        = {juin},
   NOTE         = {350 pages.},
   OPTTYPE      = {},
   KEYWORDS     = {Design patterns, Binary class relations},
   URL          = {http://www.yann-gael.gueheneuc.net/Work/PhDThesis/},
   PDF          = {http://www.yann-gael.gueheneuc.net/Work/PhDThesis/},
   ABSTRACT     = {Les patrons de conception sont importants en g\'enie 
      logiciel \`a objets car ils contribuent \`a la qualit\'e des 
      programmes. Ils proposent des solutions \'el\'egantes \`a des 
      probl\`emes r\'ecurrents de conception, des motifs utilis\'es pendant 
      l'implan\-tation. \`A~l'usage, ces motifs de conception sont 
      diss\'emin\'es dans le code source et ne sont plus explicites lors de 
      la maintenance~; pourtant, ils aideraient \`a comprendre 
      l'implantation et la conception des programmes, assurant leur 
      qualit\'e. Ce m\'emoire propose des mod\`eles et des algorithmes pour 
      garantir la tra\c cabilit\'e des motifs de conception entre les 
      phases d'implantation et de r\'etroconception des programmes par 
      l'identification semi-automatique des micro-architectures similaires 
      \`a ces motifs dans le code source. La m\'etamod\'elisation est 
      utilis\'ee pour d\'ecrire les motifs de conception et les programmes 
      Java{}. Elle am\`ene \`a expliciter certaines relations interclasses 
      (association, agr\'e\-gation et composition) offertes par les 
      langages de conception comme UML{} et \`a pr\'eciser leurs 
      propri\'et\'es (dur\'ee de vie, exclusivit\'e, multiplicit\'e et site 
      d'invocation) pour les identifier avec des algorithmes d'analyses 
      statiques et dynamiques. Elle conduit aussi \`a traduire les motifs 
      en syst\`emes de contraintes et \`a identifier les 
      micro-architectures similaires, formes compl\`etes et approch\'ees, 
      par la r\'esolution de probl\`emes de satisfaction de contraintes. La 
      programmation par contraintes avec explications permet de guider la 
      r\'esolution et d'expliquer les micro-architectures identifi\'ees. La 
      suite d'outils Ptidej{} est une implantation des mod\`eles et des 
      algorithmes propos\'es. Elle est int\'egr\'ee \`a l'environnement 
      \Eclipse{} de d\'eveloppement en Java{}. Elle inclut le 
      m\'etamod\`ele PADL{}, d\'eriv\'e du m\'etamod\`ele \PDL{}~; des 
      outils d'analyses statiques et dynamiques, \Introspector{} et 
      Caffeine{}~; et un solveur de contraintes, PtidejSolver{}, d\'eriv\'e 
      du solveur de contraintes avec explications de r\'ef\'erence \PaLM{}.}
}

@ARTICLE{Farias03-ENTCS-CoherenceProtocols,
   AUTHOR       = {Andrés Farìas and Yann-Gaël Guéhéneuc},
   JOURNAL      = {Electronic Notes in Theoretical Computer Science (ENTCS)},
   TITLE        = {On the Coherence of Component Protocols},
   YEAR         = {2003},
   MONTH        = {April},
   NOTE         = {12 pages.},
   NUMBER       = {5},
   OPTPAGES     = {},
   VOLUME       = {82},
   EDITOR       = {Uwe Assmann and Elke Pulvermueller and Isabelle Borne and 
      Noury Bouraqadi and Pierre Cointe},
   PUBLISHER    = {Elsevier Science},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ETAPS03SC.doc.pdf},
   ABSTRACT     = {Component-based programming promises to ease the 
      construction of large-scale applications. The construction of 
      applications using components relies on the notion of interfaces. 
      However, the notion of interfaces provided by current component 
      models is restricted: In particular, it does not include behavioral 
      information to define the protocols of the components: Sequences of 
      service requests. The lack of behavioral information limits our trust 
      in components: Security, reuse, and quality relate directly on this 
      missing information. In this paper, we consider the problem of 
      verifying if a component implementation respects the protocol 
      specified during its design. First, we define a notion of coherence 
      between protocols and an algorithm to verify the coherence between 
      two protocols. Then, we describe an algorithm to extract the protocol 
      of a component from its source code. Finally, we present a tool that 
      enables the static verification and enforcement of the notion of 
      coherence.}
}

@INPROCEEDINGS{Gueheneuc03-ASE-P-AAC,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Hervé Albin-Amiot},
   BOOKTITLE    = {Proceedings of the 18<sup>th</sup> Conference on Automated Software Engineering (ASE)},
   TITLE        = {A Pragmatic Study of Binary Class Relationships},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {John Grundy and John Penix},
   MONTH        = {September},
   NOTE         = {Short paper. 4 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {277--280},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Binary class relations, ASE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE03.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE03.ppt.pdf},
   ABSTRACT     = {A discontinuity exists between modeling and 
      object-oriented programming languages. This discontinuity is a 
      consequence of ambiguous notions in modeling languages and lack of 
      corresponding notions in object-oriented programming languages. It 
      hinders the transition between software implementation and design and 
      hampers software maintenance. This discontinuity is particularly 
      acute for binary class relationships, such as the association, 
      aggregation, and composition relationships. We present a solution to 
      bridge the discontinuity between implementation and design for the 
      binary class relationships: We propose consensual definitions of the 
      binary class relationships in terms of four properties (exclusivity, 
      invocation site, lifetime, multiplicity). We describe algorithms to 
      detect these properties in Java{} source code.}
}

@INPROCEEDINGS{Gueheneuc03-GDRALPOCM-PtidejEclipse,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Hervé Albin-Amiot and 
      Pierre Cointe},
   BOOKTITLE    = {Journée GDR ALP-OCM},
   TITLE        = {PatternsBox--Ptidej, intégration de deux outils de 
      conception et de rétro-conception à Eclipse},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Jacques Malenfant},
   MONTH        = {février},
   NOTE         = {6 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, GDR ALP-OCM},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Projet+GDRALP+OCM03.doc.pdf},
   ABSTRACT     = {Nous nous int{\'e}ressons aux phases de conception et de 
      maintenance de programmes {\`a} objets. Nous pensons que 
      l'utilisation des motifs (tels les motifs de conception 
      de~\cite{GoF94-Patterns}) facilite, d'une part, la conception et la 
      documentation~\cite{AlbinAmiot03-PhD} et, d'autre part, la 
      compr{\'e}hension et l'am{\'e}lioration~\cite{Gueheneuc03-PhD} de ces 
      programmes. Nous avons d{\'e}velopp{\'e} {\`a} l'occasion de nos 
      travaux de th{\`e}se de doctorat, 
      \PatternsBox{}~\cite{AlbinAmiot03-PhD} et 
      Ptidej{}~\cite{Gueheneuc03-PhD}, deux outils de conception et de 
      maintenance bas{\'e}s sur les motifs. \PatternsBox{} permet (i) 
      d'appliquer les solutions recommand{\'e}es par un ensemble de motifs 
      de conception et (ii) d'identifier dans l'architecture d'un programme 
      {\`a} objets les solutions compl{\`e}tes correspondant {\`a} des 
      motifs donn{\'e}s. Ptidej{} permet (i) d'identifier des solutions 
      {\`a} des motifs donn{\'e}s et leurs variantes et~(ii) d'identifier 
      des d{\'e}fauts de conception dans l'architecture du programme. Ces 
      deux outils pr{\'e}sentent un int{\'e}r{\^e}t pour les 
      d{\'e}veloppeurs essentiellement lorsqu'ils sont int{\'e}gr{\'e}s 
      avec les outils utilis{\'e}s habituellement pendant les phases de 
      conception et de maintenance. C'est pourquoi nous les avons 
      int{\'e}gr{\'e}s {\`a} des environnements de d{\'e}veloppements 
      int{\'e}gr{\'e}s (EDI). Dans cet article, et apr{\`e}s avoir 
      pr{\'e}sent{\'e} l'EDI d'\ygg@company{OTI~/ IBM} 
      \Eclipse{}~\cite{OTI01-Eclipse}, nous d{\'e}crivons notre 
      premi{\`e}re exp{\'e}rience relative {\`a} l'int{\'e}\-gration de 
      Ptidej{} avec \Eclipse{}, puis nos projets quant {\`a} 
      l'int{\'e}gration de \PatternsBox{}.}
}

@TECHREPORT{Baroni03-TR-DPFormalization,
   AUTHOR       = {Aline Lúcia Baroni and Yann-Gaël Guéhéneuc and 
      Hervé Albin-Amiot},
   INSTITUTION  = {Computer Science Department, École des Mines de Nantes},
   TITLE        = {Design Patterns Formalization},
   YEAR         = {2003},
   OPTADDRESS   = {},
   MONTH        = {June},
   NOTE         = {59 pages.},
   NUMBER       = {03/03/INFO},
   OPTTYPE      = {},
   KEYWORDS     = {Design patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Metamodeling+June03.doc.pdf},
   ABSTRACT     = {Design patterns were introduced in software engineering 
      as an effective mean of disseminating solutions to problems 
      repeatedly encountered in object oriented programming and since their 
      emergence, they have been widely accepted and adopted by software 
      practitioners. Design patterns contribution covers the definition, 
      the design and the documentation of class libraries and frameworks, 
      offering elegant and reusable solutions to design problems, and 
      consequently increasing productivity and development quality. Each 
      design pattern lets some aspects of the system structure vary 
      independently of other aspects, thereby making the system more robust 
      to a particular kind of change. The majority of publications in the 
      pattern field focuses on micro-architectures; i.e., intentionally 
      abstract description of generic aspects of software systems. Despite 
      this abstractness, the academic community recognizes that a better 
      understanding of design patterns by means of systematic investigation 
      is essential. Reflective tasks in this direction include comparative 
      analyses of design patterns, proposals for precise means of 
      specification, attempts for tools, analysis of relationships among 
      patterns, and other discussions. However, few works offer methods of 
      precise specification of design patterns, resulting in lack of 
      formalism. In this sense, patterns remain empirical and manually 
      applied. According to, manual application is tedious and error prone. 
      Precise specification can improve the application of design patterns 
      as well as the analysis of relationships among them and tools in 
      support of their application. Very little progress has been made 
      towards better understanding of the micro-architectures dictated by 
      design patterns. This report tries to capture the ''essence'' of 
      patterns, showing the importance of researches able to illuminate how 
      design patterns are essentially structured.}
}

@INPROCEEDINGS{AlbinAmiot02-LMO-MetaModele,
   AUTHOR       = {Hervé Albin-Amiot and Pierre Cointe and 
      Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Actes du 8<sup>e</sup> colloque Langages et Modèles à Objets (LMO)},
   TITLE        = {Un méta-modèle pour coupler application et détection des 
      design patterns},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Michel Dao and Marianne Huchard},
   MONTH        = {janvier},
   NOTE         = {18 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {41--58},
   PUBLISHER    = {Hermès Science Publications},
   SERIES       = {RSTI -- L'objet},
   VOLUME       = {8, numéro 1-2/2002},
   KEYWORDS     = {Design patterns, LMO},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO02.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/LMO02.ppt.pdf},
   ABSTRACT     = {Les design patterns (ou patrons de conception) sont 
      reconnus comme une des bonnes techniques du g\'enie logiciel \`a 
      objets. Cette technique am\'eliore le cycle de vie du logiciel en 
      facilitant la conception, la documentation, la maintenance et la 
      r\'etro-conception. Peu d'environnements de d\'eveloppement 
      int\'egr\'es (EDIs) sont \`a la fois outill\'es pour inciter 
      l'utilisateur \`a appliquer un catalogue de patterns et pour l'aider 
      \`a am\'eliorer ses programmes en y extrayant automatiquement des 
      micro-architectures correspondant \`a celles de patterns. Ce papier 
      pr\'esente une partie de nos travaux visant \`a outiller l'EDI Visual 
      Age pour Java en lui adjoignant un catalogue recensant l'ensemble des 
      patterns du GoF et deux assistants d\'edi\'es \`a l'application et 
      \`a la d\'etection de patterns. Nous proposons un m\'eta-mod\`ele 
      permettant de d\'ecrire ces diff\'erents patterns, de les manipuler, 
      de les synth\'etiser et de les reconna\^{\i}tre dans des programmes 
      existants. Nous discutons les limites de ce m\'eta-mod\`ele apparues 
      apr\`es exp\'erimentation et sugg\'erons comment l'am\'eliorer pour 
      prendre en charge l'aspect intentionnel des patterns et supporter la 
      reconnaissance de micro-architectures voisines de celles de patterns 
      d\'ej\`a r\'epertori\'es.}
}

@INPROCEEDINGS{Farias02-WBS-ProtocolsEJB,
   AUTHOR       = {Andrés Farìas and Yann-Gaël Guéhéneuc and Mario Südholt},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> OOPSLA workshop on Behavioral Semantics: Serving the Customer},
   TITLE        = {Integrating Behavioral Protocols in Enterprise Java 
      Beans},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Kenneth Baclawski and Haim Kilov},
   MONTH        = {October},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   ORGANIZATION = {College of Computer Science},
   PAGES        = {80--89},
   PUBLISHER    = {Northeastern University},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OOPSLA02BehavioralSemantics.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OOPSLA02BehavioralSemantics.ppt.pdf},
   ABSTRACT     = {Behavioral protocols have been proposed to enhance 
      component-based systems by including sequencing constraints on 
      component interactions in component interfaces. However, no existing 
      component-based models provide support for behavioral protocols. In 
      this paper, we discuss the integration of behavioral protocol in 
      Sun's Enterprise JavaBeans (EJB) component model in three steps. 
      First, we introduce the notion of coherence between behavioral 
      protocols and component source code. Second, we discuss of the 
      relations of behavioral protocols to the different interface-related 
      concepts in EJB components (remote interface, deployment 
      descriptor...). Third, we describe possibilities of automatic 
      enforcement of behavioral protocols by means of automated extraction 
      of protocols from components and verification of the notion of 
      coherence against expected behavioral protocols.}
}

@INPROCEEDINGS{Gueheneuc02-WDMP-ThreeMusketeers,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> ASE workshop on Declarative Meta-Prorgramming},
   TITLE        = {Three Musketeers to the Rescue -- Meta-Modelling, Logic 
      Programming, and Explanation-based Constraint Programming for Pattern 
      Description and Detection},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Kris De Volder and Kim Mens and Tom Mens and Roel Wuyts},
   MONTH        = {September},
   NOTE         = {8 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Computer Science Department, University of British Columbia},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, WDMP},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE02DMP.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE02DMP.ppt.pdf},
   ABSTRACT     = {Software maintenance is a costly and tedious phase in 
      the software development process Woods98-ConstraintRecovery. During 
      this phase, a maintainer needs both to understand and to modify a 
      program source code. Therefore, the maintainer must obtain a 
      representation of the program that accurately reflects its structure 
      and its behavior. Then, the maintainer must find those places in the 
      program that require modification. Finally, the maintainer must 
      perform changes that improve the program behavior and do not 
      introduce further defects. In our research work, we focus on the 
      maintainer's first and second tasks: The obtention of an accurate 
      representation of the program structure and behavior, and the 
      detection of places to improve. We propose a set of software 
      engineering tools, for the structural and dynamic representation of 
      Java program, and for the (semi-) automated detection of design 
      patterns and design defects. Design patterns and design defects are 
      related: A group of classes which micro-architecture is similar (but 
      not identical) to a design pattern corresponds to a possible design 
      defect}
}

@TECHREPORT{Gueheneuc02-TR-GapLanguages,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Hervé Albin-Amiot and 
      Rémi Douence and Pierre Cointe},
   INSTITUTION  = {Computer Science Department, École des Mines de Nantes},
   TITLE        = {Bridging the Gap Between Modeling and Programming 
      Languages},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {July},
   NOTE         = {56 pages.},
   NUMBER       = {02/09/INFO},
   OPTTYPE      = {},
   KEYWORDS     = {Binary class relations},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+AAC+July02.doc.pdf},
   ABSTRACT     = {A discontinuity exists between modeling languages and 
      ob\-ject-oriented programming languages. This discontinuity is a 
      consequence of ambiguous notions in modeling languages and lack of 
      corresponding notions in object-oriented programming languages. It 
      hinders the transition between a software design and its 
      implementation, and vice versa. Thus, it hampers the implementation 
      and the maintenance processes. This discontinuity is particularly 
      acute for binary class relationships, which describe, at the design 
      level, notions such as association, aggregation, and composition. 
      From the current state of the art, we propose synthetic definitions 
      for the binary class relationships at the design level and 
      corresponding definitions at the implementation level. We express the 
      latter definitions in terms of common properties. We present 
      algorithms to synthesize code for these properties and to detect 
      these properties in code. These algorithms allow us to generate and 
      to detect binary class relationships. We verify the detection 
      algorithms on several well-known frameworks. The definitions and 
      algorithms bring continuity between modeling languages and 
      object-oriented programming languages.}
}

@TECHREPORT{Gueheneuc02-TR-Caffeine,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Rémi Douence and 
      Narendra Jussien},
   INSTITUTION  = {Computer Science Department, École des Mines de Nantes},
   TITLE        = {No Java Without Caffeine -- A Tool for Dynamic Analysis 
      of Java Programs},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {May},
   NOTE         = {16 pages.},
   NUMBER       = {02/07/INFO},
   OPTTYPE      = {},
   KEYWORDS     = {Binary class relations},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/Research+report+Caffeine+May02.doc.pdf},
   ABSTRACT     = {To understand the behavior of a program, a maintainer 
      reads some code, asks a question about this code, conjectures an 
      answer, and searches the code and the documentation for confirmation 
      of her conjecture. However, the confirmation of the conjecture can be 
      error-prone and time-consuming because the maintainer only has static 
      information at her disposal. She would benefit from dynamic 
      information. In this paper, we present Caffeine{}, an assistant that 
      helps the maintainer in checking her conjecture about the behavior of 
      a Java{} program. Our assistant is a dynamic analysis tool that uses 
      the Java{} platform debug architecture to generate a trace, \ie{} an 
      execution history, and a \Prolog{} engine to perform queries over the 
      trace. We present a usage scenario based on the n-queens problem, and 
      two examples based on the Singleton design pattern and on the 
      composition relationship.}
}

@MISC{Caffeine,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {since May},
   NOTE         = {A tool to analyse Java programs dynamically.},
   TITLE        = {Caffeine},
   YEAR         = {2002},
   KEYWORDS     = {Design patterns},
   URL          = {http://www.ptidej.net}
}

@INPROCEEDINGS{AlbinAmiot01-ASE-BitsPieces,
   AUTHOR       = {Hervé Albin-Amiot and Pierre Cointe and 
      Yann-Gaël Guéhéneuc and Narendra Jussien},
   BOOKTITLE    = {Proceedings of the 16<sup>th</sup> Conference on Automated Software Engineering (ASE)},
   TITLE        = {Instantiating and Detecting Design Patterns: Putting 
      Bits and Pieces Together},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Debra Richardson and Martin Feather and Michael Goedicke},
   MONTH        = {November},
   NOTE         = {8 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {166--173},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, ASE},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE01.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ASE01.ppt.pdf},
   ABSTRACT     = {Design patterns ease designing, understanding, and 
      re-engineering software. Achieving a well-designed piece of software 
      requires a deep understanding and a good practice of design patterns. 
      Understanding existing software relies on the ability to identify 
      architectural forms resulting of the implementation of design 
      patterns. Maintaining software involves spotting places that can be 
      improved by using better design decisions, like those advocated by 
      design patterns. Nevertheless, there is a lack of tools automating 
      the use of design patterns to achieve well-designed pieces of 
      software, to identify recurrent architectural forms, and to maintain 
      software. In this paper, we present a set of tools and techniques to 
      help OO software practitioners design, understand, and re-engineer a 
      piece of software, using design-patterns. A first prototype tool, 
      PatternsBox, provides assistance in designing the architecture of a 
      new piece of software, while a second prototype tool, Ptidej, 
      identifies design patterns used in an existing one. These tools, in 
      combination, support maintenance by highlighting defects in an 
      existing design, and by suggesting and applying corrections based on 
      widely-accepted design patterns solutions.}
}

@INPROCEEDINGS{AlbinAmiot01-WGP-Generative,
   AUTHOR       = {Hervé Albin-Amiot and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> OOPSLA workshop on Generative Programming},
   TITLE        = {Design Patterns Application: Pure-generative Approach 
      vs. Conservative-generative Approach},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Krzysztof Czarnecki},
   MONTH        = {October},
   NOTE         = {3 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, GP},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/OOPSLA01GP.doc.pdf},
   ABSTRACT     = {For our discussion we summarize software developments in 
      two kinds: Development of large applications (such as accounting 
      application or billing systems); and, development of large framework 
      (such as window system [SunAWT] or networking system [Zweig90]). In 
      one hand, when developing large applications, the developers need to 
      abstract the functional and non-functional requirements of the 
      application. They must be particularly careful with the 
      specifications of the business rules and policies of the application, 
      while the language and the code implementing the application are not 
      really important. On the other hand, when developing large 
      frameworks, the developers need to abstract the potential extension 
      and implementations of the framework. They must be particularly 
      careful with the architecture, the design, and the implementation of 
      the framework, which is, at least, as important as the 
      functionalities provided. In this position paper, we present two 
      tools that help the developers in implementing large applications and 
      large frameworks, using design patterns. Scriptor [Scriptor] (Section 
      2) is an industrial-strength application generator. Developers use it 
      to generate large applications from scripts stating their functional 
      and non-functional requirements. PatternsBox [PatternsBox] (Section 
      3) is an academic conservative application generator. Developers use 
      it to implement design patterns in existing applications. PatternsBox 
      modifies or creates only the required code artifacts (class, 
      interface, fields, methods) to implement the design patterns, leaving 
      the rest of the code untouched.}
}

@INPROCEEDINGS{AlbinAmiot01-WPHDOOS-RoundTrip,
   AUTHOR       = {Hervé Albin-Amiot and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 11<sup>th</sup> ECOOP workshop for Ph.D. Students in Object-Oriented Systems},
   TITLE        = {Design Patterns: A Round-Trip},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Gilles Ardourel and Michael Haupt and 
      Jose Luis Herrero Agustin and Rainer Ruggaber and Charles Suscheck},
   MONTH        = {June},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, PHDOOS},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP01PHDOOS.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP01PHDOOS.ppt.pdf},
   ABSTRACT     = {Design patterns are of major interest to increase 
      software quality and abstraction level. However, design patterns are 
      difficult to choose, to apply, and to recover. We propose a set of 
      tools to use design patterns in a round-trip fashion. We define a 
      meta-model to describe design patterns. This meta-model is 
      specifically oriented towards design patterns instantiation and 
      detection. We develop a source-to-source transformation engine to 
      modify the source code to comply with design patterns descriptions. 
      Meanwhile, we use an explanation-based constraint solver to detect 
      design patterns in source code from their descriptions. With these 
      tools, we hope to offer a mean to apply and to recover design 
      patterns without overhead for the developers.}
}

@INPROCEEDINGS{AlbinAmiot01-WAOOSDM-MetaModel,
   AUTHOR       = {Hervé Albin-Amiot and Yann-Gaël Guéhéneuc},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> ECOOP workshop on Automating Object-Oriented Software Development Methods},
   TITLE        = {Meta-Modeling Design Patterns: Application to Pattern 
      Detection and Code Synthesis},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {van den Broek, Pim and Pavel Hruby and Motoshi Saeki and 
      Gerson Sunyé and Bedir Tekinerdogan},
   MONTH        = {October},
   NOTE         = {TR-CTIT-01-35. 8 pages.},
   OPTNUMBER    = {},
   ORGANIZATION = {Centre for Telematics and Information Technology},
   OPTPAGES     = {},
   PUBLISHER    = {University of Twente},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP01AOOSDM.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/ECOOP01AOOSDM.ppt.pdf},
   ABSTRACT     = {Design Patterns have been quickly adopted by the 
      object-oriented community, in particular since the publication of 
      ``Design Patterns: Elements of Reusable Object-Oriented Software". 
      They offer elegant and reusable solutions to recurring problems of 
      design. Their use increases productivity and development quality. 
      However, these solutions, at the boundary of programming languages 
      and design models, suffer from a lack of formalism. For this reason, 
      their application remains empirical and manually performed. This 
      position paper presents how a meta-model can be used to obtain a 
      representation of design patterns and how this representation allows 
      both automatic code generation and design patterns detection.}
}

@INPROCEEDINGS{Gueheneuc01-TOOLSUSA-DesignDefects,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Hervé Albin-Amiot},
   BOOKTITLE    = {Proceedings of the 39<sup>th</sup> Conference on the Technology of Object-Oriented Languages and Systems (TOOLS USA)},
   TITLE        = {Using Design Patterns and Constraints to Automate the 
      Detection and Correction of Inter-Class Design Defects},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Quioyun Li and Richard Riehle and Gilda Pour and 
      Bertrand Meyer},
   MONTH        = {July},
   NOTE         = {10 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {296--305},
   PUBLISHER    = {IEEE Computer Society Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Code and design smells, TOOLS USA},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TOOLSUSA01.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/TOOLSUSA01.ppt.pdf},
   ABSTRACT     = {Developing code free of defects is a major concern for 
      the object-oriented software community. In this paper, we classify 
      design defects as those within classes (\textit{intra-class}), those 
      among classes (\textit{inter-classes}), and those of semantic nature 
      (\textit{behavioral}). Then, we introduce guidelines to automate the 
      detection and correction of inter-class design defects: We assume 
      that design patterns embody good architectural solutions and that a 
      group of entities with organization similar, but not equal, to a 
      design pattern represents an inter-class design defect. Thus, the 
      transformation of such a group of entities, such that its 
      organization complies exactly with a design pattern, corresponds to 
      the correction of an inter-class design defect. We use a meta-model 
      to describe design patterns and we exploit the descriptions to infer 
      sets of detection and transformation rules. A constraints solver with 
      explanations uses the descriptions and rules to recognize groups of 
      entities with organizations similar to the described design patterns. 
      A transformation engine modifies the source code to comply with the 
      recognized distorted design patterns. We apply these guidelines on 
      the \ygg@pattern{Composite} pattern using \ygg@product{Ptidej}, our 
      prototype tool that integrates the complete guidelines.}
}

@INPROCEEDINGS{Gueheneuc01-JNPC-Explications,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Narendra Jussien},
   BOOKTITLE    = {Actes des 7<sup>e</sup> Journées Nationales sur la résolution de Problèmes NP-Complets (JNPC)},
   TITLE        = {Quelques explications pour les patrons -- Une 
      application de la PPC avec explications pour l'identification de 
      patrons de conception},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Bertrand Neveu},
   MONTH        = {juin},
   NOTE         = {12 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {111--122},
   PUBLISHER    = {ONERA},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, JNPC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JNPC01.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/JNPC01.ppt.pdf},
   ABSTRACT     = {Les patrons de conception d\'ecrivent des 
      micro-architectures qui r\'esolvent des probl\`emes architecturaux 
      r\'ecurrents. Il est important d'identifier ces micro-archi\-tectures 
      lors de la maintenance des programmes orient\'es objets. Mais ces 
      micro-architectures apparaissent souvent sous des formes 
      d\'egrad\'ees dans le code source. Nous pr\'esentons une application 
      de la programmation par contraintes avec explications pour 
      l'identification de ces micro-architectures d\'egrad\'ees.}
}

@INPROCEEDINGS{Gueheneuc01-WMSPC-Explanations,
   AUTHOR       = {Yann-Gaël Guéhéneuc and Narendra Jussien},
   BOOKTITLE    = {Proceedings of the 1<sup>st</sup> IJCAI Workshop on Modeling and Solving Problems with Constraints},
   TITLE        = {Using Explanations for Design-Patterns Identification},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Christian Bessière},
   MONTH        = {August},
   NOTE         = {8 pages.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {57--64},
   PUBLISHER    = {AAAI Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Design patterns, WMSPC},
   URL          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IJCAI01MSPC.doc.pdf},
   PDF          = {http://www-etud.iro.umontreal.ca/~ptidej/yann-gael/Work/Publications/Documents/IJCAI01MSPC.ppt.pdf},
   ABSTRACT     = {Design-patterns describe micro-architectures that solve 
      recurrent architectural problems in objec-oriented programming 
      languages. It is important to identify these micro-architectures 
      during the maintenant of objec-oriented programs. But, these 
      micro-architectures often appear distorted in the source code. We 
      present an application of explanation-based constraint programming 
      for identifying these distorted micro-architectures.}
}

@MISC{Ptidej,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {since July},
   NOTE         = {A tool suite to evaluate and to enhance the quality of object-oriented programs.},
   TITLE        = {Ptidej},
   YEAR         = {2001},
   URL          = {http://www.ptidej.net}
}

@MISC{PADL,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   OPTHOWPUBLISHED = {},
   MONTH        = {since July},
   NOTE         = {A meta-model (and parsers) to represent and to manipulate object-oriented programs and design motifs.},
   TITLE        = {PADL},
   YEAR         = {1999},
   URL          = {http://www.ptidej.net/}
}

@MASTERSTHESIS{Gueheneuc98-DEA,
   AUTHOR       = {Yann-Gaël Guéhéneuc},
   SCHOOL       = {École des Mines de Nantes et Université de Nantes},
   TITLE        = {Syntax-error Recovery in Interactive Environments},
   YEAR         = {1998},
   OPTADDRESS   = {},
   MONTH        = {septembre},
   NOTE         = {(Diplôme d'études approfondies)},
   OPTTYPE      = {}
}

