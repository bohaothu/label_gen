%% $Id: qnc.bib,v 1.39 2002/02/02 21:11:02 queinnec Exp queinnec $
%% These first lines are for Hypatia:
%%  viz. http://hypatia.dcs.qmw.ac.uk/authors/Q/QueinnecC/

%% bibtex-file{
%%  author=	  {Queinnec, Christian},
%%  date=         {$Date: 2002/02/02 21:11:02 $},
%%  filename=     {qnc.bib},
%%  url=          {http://www-spi.lip6.fr/~queinnec/Papers/qnc.bib},
%%  www-home=     {http://www-spi.lip6.fr/~queinnec/WWW/Queinnec.html},
%%  address=      {Pr. Christian Queinnec
%%                 Universit{\'e} Paris 6 --- Pierre et Marie Curie
%%                 LIP6, Boite 168
%%                 4, place Jussieu
%%                 75252 Paris Cedex 05
%%                 France},
%%  telephone=     {+33 1 44 27 40 55},
%%  fax=           {+33 1 44 27 40 42},
%%  ftp-archive=   {ftp://youpou.lip6.fr/pub/queinnec/Papers/},
%%  email=         {Christian.Queinnec at lip6.fr},
%%  dates=         {1951--},
%%  keywords=      {},
%%  supported=     {yes},
%%  suppported-by= {Christian Queinnec},
%%  abstract=      {Christian Queinnec's own bibliography
%%     This file contains the bibliography of Christian Queinnec.
%%     Specific keys are added to entries.
%%        ecritsdIcsla : refers to the issue of "Les Ecrits d'Icsla" where 
%%                       the paper also appears.
%%        abstract     : the English (or French) abstract of the paper.
%%        ftpfile      : this basename tells which file contains the
%%                       compressed Postscript paper in the ftp repository
%%                       http://youpou.lip6.fr/queinnec/Papers/
%%                       or http://youpou.lip6.fr/queinnec/PDF/
%%        programfile  : the name of the file that contains associated code
%%                       in the ftp repository.
%%        sourcefile   : the basename of the source files on my workstation.
%%        w3keyword    : the keyword used to refer to that paper from my
%%                       html pages.
%%        url          : a related url.
%%        coverpage    : the image of the cover page of a book.
%%}}
%%include header.bib here so Hypatia may resolve the missing string definitions.
$Id: header.bib,v 1.25 2000/10/21 18:28:06 queinnec Exp queinnec $

This bib file contains abbreviations to be used in other bib files.
Just mention it as first bib file that BibTeX will see, abbreviations are
fully pervasive. Similarly use trailer.bib as last bib file, it
contains the necessary crossref for conferences proceedings.

@string{popl = "Annual ACM symposium on Principles of Programming Languages"}
@string{popl79 = "POPL '79 -- Sixth "#popl}
@string{popl88 = "POPL '88 -- Fifteenth "#popl}
@string{popl89 = "POPL '89 -- Sixteenth "#popl}
@string{popl90 = "POPL '90 -- Seventeenth "#popl}
@string{popl91 = "POPL '91 -- Eighteenth "#popl}
@string{popl92 = "POPL '92 -- Nineteenth "#popl}
@string{popl93 = "POPL '93 -- Twentieth "#popl}
@string{popl94 = "POPL '94 -- Twenty-first "#popl}
@string{popl95 = "POPL '95 -- Twenty-second "#popl}
@string{popl96 = "POPL '96 -- Twenty-third "#popl}
@string{popl97 = "POPL '97 -- Twenty-fourth "#popl}

@string{lfp = "ACM Symposium on Lisp and Functional Programming"}
@string{lfp80 = "Conference Record of the 1980 Lisp Conference"}
@string{lfp82 = "LFP '82 -- "#lfp}
@string{lfp84 = "LFP '84 -- "#lfp}
@string{lfp86 = "LFP '86 -- "#lfp}
@string{lfp88 = "LFP '88 -- "#lfp}
@string{lfp90 = "LFP '90 -- "#lfp}
@string{lfp92 = "LFP '92 -- "#lfp}
@string{lfp94 = "LFP '94 -- "#lfp}
@string{icfp = "International Conference on Functional Programming"}
@string{icfp98 = "ICFP '98 -- "#icfp}
@string{icfp2000 = "ICFP '2000 -- "#icfp}
@string{icfp2002 = "ICFP '2002 -- "#icfp}

@string{ppopp = "ACM SIGPLAN Symposium on Principles and Practices of Parallel
                 Programming"}
@string{ppopp90 = "PPOPP '90 -- "#ppopp}

@string{pepm91 = "Symposium on Partial Evaluation and Semantics-Based
		  Program Manipulation"}
@string{pepm94 = "Proceeding of the ACM SIGPLAN workshop on Partial
                  Evaluation and Semantics-Based Program Manipulation"}

@string{esop = "European Symposium on Programming"}
@string{esop88 = "ESOP '88 -- "#esop}
@string{esop90 = "ESOP '90 -- "#esop}
@string{esop92 = "ESOP '92 -- "#esop}

@string{fpca = "Functional Programming and Computer Architecture"}
@string{fpca85 = "FPCA '85 -- "#fpca}
@string{fpca87 = "FPCA '87 -- "#fpca}
@string{fpca89 = "FPCA '89 -- "#fpca}
@string{fpca91 = "FPCA '91 -- "#fpca}

@string{pldi = "ACM SIGPLAN Programming Languages Design and Implementation"}
@string{pldi87 = "PLDI '87 --"#pldi}
@string{pldi90 = "PLDI '90 --"#pldi}
@string{pldi91 = "PLDI '91 --"#pldi}

@string{parle = "Parallel Architectures and Languages Europe"}
@string{parle87 = "PARLE '87 -- "#parle}
@string{parle89 = "PARLE '89 -- "#parle}
@string{parle91 = "PARLE '91 -- "#parle}
@string{parle92 = "PARLE '92 -- "#parle}

@string{tools = "Technology of Object-Oriented Languages and Systems"}
@string{tools89 = "TOOLS '89 --- "#tools}

@string{ecoop = "European Conference on Object-Oriented Programming"}
@string{ecoop92 = "ECOOP '92 --- 6th "#ecoop}
@string{ecoop93 = "ECOOP '93 --- 7th "#ecoop}
@string{ecoop94 = "ECOOP '94 --- 8th "#ecoop}

@string{oopsla = "Object-Oriented Programming Systems and LAnguages"}
@string{oopsla86 = "OOPSLA '86 --- "#oopsla}
@string{oopsla87 = "OOPSLA '87 --- "#oopsla}
@string{oopsla88 = "OOPSLA '88 --- "#oopsla}
@string{oopsla89 = "OOPSLA '89 --- "#oopsla}
@string{oopsla90 = "OOPSLA '90 --- "#oopsla}
@string{oopsla91 = "OOPSLA '91 --- "#oopsla}
@string{oopsla92 = "OOPSLA '92 --- "#oopsla}
@string{oopsla93 = "OOPSLA '93 --- "#oopsla}

@string{plilp = "Programming Language: Implementation and Logic Programming"}
@string{plilp90 = "International Workshop PLILP '90 -- "#plilp}
@string{plilp91 = "International Workshop PLILP '91 -- "#plilp}
@string{plilp94 = "International Workshop PLILP '94 -- "#plilp}
@string{plilp96 = "International Workshop PLILP '96 -- "#plilp}

@string{europal = "European Conference on Lisp and its Practical Applications"}
@string{europal90 = "EuroPal '90 -- "#europal}

@string{lncs = "Lecture Notes in Computer Science"}

@string{springer = "{S}pringer-{V}erlag"}
@string{springer-verlag = springer}
@string{north-holland = "North Holland"}
@string{mitpress = "MIT Press, Cambridge MA"}
@string{mit-press = mitpress}
@string{mcgraw-hill = "McGraw-Hill"}
@string{addison-wesley = "Addison Wesley"}
@string{acm-press = "ACM Press"}
@string{prentice-hall = "Prentice-Hall"}

@string{ieee = "IEEE"}

@string{lasc = "International journal on Lisp and Symbolic Computation"}
@string{hosc = "Higher-Order and Symbolic Computation"}
@string{lptr = "Lisp Pointers, ACM SIGPLAN Special Interest Publication
                  on Lisp"}
@string{toplas = "ACM Transaction on Programming Languages and Systems"}
@string{spe = "Software --- Practice and Experience"}
@string{cocom = "Symposium on Compiler Construction"}
@string{sigplan-notices = "SIGPLAN Notices"}
@string{tse = "{IEEE} Transactions on Software Engineering"}
@string{ipl = "{I}nformation {P}rocessing {L}etters"}
@string{tcs = "Theoretical Computer Science"}
@string{jacm = "Journal of the Association for Computing Machinery"}
@string{ddj = "Dr. Dobb's Journal, 
               Software Tools for the Professional Programmer"}

@string{inria = "Institut National de Recherche en Informatique et en
		  Automatique"}
@string{ensta = "\'Ecole Nationale Sup\'erieure des Techniques Avanc\'ees"}

@string{JPDC="Journal of Parallel and Distributed Computing"}

@string{lix = "Laboratoire d'Informatique de l'\'Ecole Polytechnique"}

@string{jfla = "Journ\'ees Francophones des Langages Applicatifs"}
@string{jfla90 = "JFLA 90 -- "#jfla}
@string{jfla91 = "JFLA 91 -- "#jfla}
@string{jfla92 = "JFLA 92 -- "#jfla}
@string{jfla93 = "JFLA 93 -- "#jfla}
@string{jfla94 = "JFLA 94 -- "#jfla}
@string{jfla95 = "JFLA 95 -- "#jfla}
@string{jfla96 = "JFLA 96 -- "#jfla}
@string{jfla97 = "JFLA 97 -- "#jfla}

@string{bigre = "Revue Bigre+Globule"}

@string{cacm = "Communications of the {ACM}"}
@string{ACM = "{A}ssociation of {C}omputing {M}achinery"}

@string{ifip = "IFIP"}

@PhdThesis{Queinnec78,
  author = 	 "Christian Queinnec",
  title = 	 "{C}ontribution {\`a} l'{\'e}tude des syst{\`e}mes
                  interactifs", 
  school = 	 "Paris VI \& ENSTA",
  year = 	 1978,
  type = 	 "Th{\`e}se de docteur-ing{\'e}nieur",
  month = 	 oct
}

@Unpublished{Queinnec79,
  author = 	 "Christian Queinnec",
  title = 	 "{A}nother {L}isp {F}ormalization",
  note = 	 "Proposed to the Lisp Bulletin",
  year = 	 1979,
  url =          {http://www-spi.lip6.fr/~{}queinnec/WWW/FirstPaper.html}
}

@InProceedings{Queinnec80,
  author = 	 "Jean-Pierre Crestin and Christian Queinnec",
  title = 	 "{T}owards {S}emantics for {G}raphical {I}nteractions",
  booktitle = 	 "Methodology of Interactions",
  year = 	 1980,
  pages =        "171--181",
  editor = 	 "Guedj {et al}",
  organization = ifip,
  publisher = north-holland
}

@Misc{Queinnec80a,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp et sa programmation",
  howpublished = "Projet de support de cours "#ensta,
  year = 	 1980,
  month = 	 jun
}

@Article{Queinnec81,
  author = 	 "Christian Queinnec",
  title = 	 "Une formalisation des syst{\`e}mes interactifs",
  journal = 	 "RAIRO Informatique th{\'e}orique",
  year = 	 1981,
  volume = 	 15,
  number = 	 4,
  pages = 	 "303-336"
}

@Misc{Queinnec81a,
  author = 	 "Christian Queinnec",
  title = 	 "{P}ratique de l'{U}nivac par la voie de l'assembleur",
  howpublished = "support de cours "#ensta#" IA11, {\'E}dition 178",
  year = 	 1981
}

@Misc{Queinnec81b,
  author = 	 "Christian Queinnec",
  title = 	 "{OS} 1100",
  howpublished = "support de cours "#ensta#" IA11, {\'E}dition 177",
  year = 	 1981
}

@Book{Queinnec82,
  author = 	 "Christian Queinnec",
  title = 	 "{L}angage d'un autre type : {L}isp",
  publisher = 	 "Eyrolles",
  year = 	 1982,
  address = 	 "Paris (France)",
  coverpage   =  "LduAT.png"
}

@Article{Queinnec82a,
  author = 	 "Christian Queinnec",
  title = 	 "{I}l {\'e}tait une fois : {L}isp",
  journal = 	 "La Jaune et la Rouge",
  year = 	 1982,
  number = 	 380,
  pages = 	 "90--91",
  month = 	 dec
}

@Article{Queinnec83a,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp: Langage d'hier ou de demain ?",
  journal = 	 "Informatique et Gestion",
  year = 	 1983,
  number = 	 141,
  pages = 	 "50--56",
  month = 	 apr
}

@Book{Queinnec84,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp mode d'emploi",
  publisher = 	 "Eyrolles",
  year = 	 1984,
  address = 	 "Paris (France)",
  coverpage   =  "LMdE.png"
}

@InProceedings{Queinnec84a,
  author = 	 "Christian Queinnec",
  title = 	 "{D}e la comparaison des syst{\`e}mes {L}isp, 1{\`e}re partie:
                  {T}opographie de {B}abel",
  booktitle = 	 "Actes des journ{\'e}es d'Avignon, les syst{\`e}mes
		  experts et leurs applications",
  year = 	 1984,
  month = 	 may
}

@Book{Queinnec84b,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp",
  publisher = 	 "Macmillan",
  year = 	 1984,
  isbn =         "ISBN 0-333-36795-2"
}

@Article{Queinnec85,
  author = 	 "Christian Queinnec",
  title = 	 "{D}e la comparaison des syst{\`e}mes {L}isp, Parties 1 et 2:
                  {A}rpentage d'{E}den",
  journal = 	 "G{\'e}nie logiciel",
  year = 	 1985,
  number = 	 2,
  OPTpages = 	 "??--??",
  month = 	 may
}

@Misc{Queinnec85a,
  author = 	 "Christian Queinnec",
  title = 	 "{TY}trucs, {M}ul{TY}trucs et {V}irtty universel",
  howpublished = "Les Mardis de Le-Lisp, num{\'e}ro 4",
  year = 	 1985,
  month = 	 dec
}

@Book{Queinnec86,
  author = 	 "Christian Queinnec",
  title = 	 "{ABC} d'{UNIX}",
  publisher = 	 "Eyrolles",
  year = 	 1986,
  coverpage   =  "ABCdU.png"
}

@InProceedings{Queinnec86a,
  author = 	 "Julian Padget and J{\'e}r{\^o}me Chailloux and
        Thomas Christaller and Ramon De Mantaras and Jeff Dalton and
        Matthieu Devin and John Fitch and Timm Krumnack and Eugen Neidl and
        Eric Papon and Stephen Pope and Christian Queinnec and Luc Steels and
        Herbert Stoyan",
  title = 	 "{D}esiderata for the standardisation of {L}isp",
  booktitle = 	 lfp86,
  year = 	 1986,
  pages = 	 "54--66",
}

I should inquire of this one some day. It's a paper similar to the previous one.
InProceedings{Queinnec86aa,
  author = 	 "?",
  title = 	 "?",
  booktitle = 	 "ECAI '86",
  year = 	 1986
}

@Article{Queinnec86b,
  author = 	 "Christian Queinnec",
  title = 	 "{D}e {L}isp \`a {P}rolog, Les langages de l'intelligence
		   artificielle",
  journal = 	 "Arm{\'e}es d'Aujourd'hui",
  year = 	 1986,
  number = 	 108,
  month = 	 mar
}

@Book{Queinnec86d,
  author = 	 "Christian Queinnec",
  title = 	 "{G}uida all'uso del linguaggio {L}isp",
  publisher = 	 "Fronco Angeli",
  year = 	 1986,
  address = 	 "Milano (Italia)"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1987

@Book{Queinnec87a,
  author = 	 "Christian Queinnec",
  title = 	 "{P}rogramaci{\'o}n en {L}isp",
  publisher = 	 "Paraninfo",
  year = 	 1987,
  address = 	 "Spa\~na",
  isbn =         "ISBN 84-283-1522-1"
}

@Article{Queinnec87b,
  author = 	 "Christian Queinnec",
  title = 	 "{E}ntit{\'e}s \`a dur{\'e}e de vie dynamique",
  journal = 	 bigre,
  year = 	 1988,
  number = 	 59,
  pages = 	 "127--139",
  month = 	 apr,
  note = 	 "Actes des journ{\'e}es Groplan AFCET, novembre 1987
                  (Rouen, France)",
  abstract = "
Traditionnellement les entit\'es que manipule Lisp sont allou\'ees dans
le tas plut\^ot que dans la pile: la raison est que leur dur\'ee de vie
effective est souvent inconnue, surtout en mode
interpr\'et\'e. Allouer en pile conf\`ere aux entit\'es une dur\'ee de
vie dynamique plut\^ot qu'ind\'efinie:
l'objet dispara{\^\i}tra lorsqu'il sera d\'epil\'e.
Cette r\'ecup\'eration s'effectue sans appel au Glaneur de Cellules
et procure ainsi d'int\'eressants gains de vitesse. Les mat\'eriels
sp\'ecialis\'es savent allouer en pile des entit\'es qu'ils
accompagnent de compteurs de r\'ef\'erences ou de d\'emons microcod\'es
de telle sorte qu'il est possible au d\'epilement de savoir si
l'entit\'e est encore utile et, par exemple, de la recopier alors
dans le tas. De telles solutions sont inefficaces sur des
calculateurs universels.

Cet article pr\'esente et analyse une technique d'implantation
d'entit\'es \`a dur\'ee de vie dynamique. 
Ces entit\'es sont allou\'ees en pile,
peuvent \^etre utilis\'ees tant qu'elles y sont et, lorsqu'elles n'y
sont plus, rendent incongrue toute tentative d'acc\`es. La technique ne
n\'ecessite pas de mat\'eriel sp\'ecialis\'e pour \^etre efficace et peut
\^etre proprement compil\'ee. Elle peut aussi \^etre mise \`a profit
dans d'autres langages si la s\'ecurit\'e d'emploi prime
l'absence de garde-fous. Les performances sont analys\'ees
en fin d'article."
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1988

@InBook{Queinnec88a,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp, langage de calcul symbolique",
  chapter = 	 "H 2 520",
  publisher = 	 "Techniques de l'ing{\'e}nieur",
  year = 	 1988,
  pages = 	 "1-13",
  address = 	 "Paris (France)",
  ecritsdIcsla = 1,
  note = "remis {\`a} jour en 1995"
}

@Proceedings{Queinnec88b,
  title = 	 "{P}roceedings of the {F}irst {I}nternational {W}orkshop on
		  {L}isp {E}volution and {S}tandardization",
  year = 	 1988,
  editor = 	 "Christian Queinnec and J{\'e}r\^ome Chailloux",
  organization = "AFCET",
  address = 	 "Paris (France)",
  month = 	 feb
}

@InProceedings{Queinnec88ba,
  author = 	 "Christian Queinnec",
  title = 	 "{F}or the {S}ake of {L}isp",
  booktitle = 	 "{P}roceedings of the {F}irst {I}nternational {W}orkshop on
		  {L}isp {E}volution and {S}tandardization",
  year = 	 1988,
  editor = 	 "Christian Queinnec and J{\'e}r\^ome Chailloux",
  pages = 	 "8--9",
  organization = "AFCET",
  publisher =    "IOS Amsterdam--Springfield",
  address = 	 "Paris (France)",
  month = 	 feb
}

@Proceedings{Queinnec88bb,
  title = 	 "{P}roceedings of the {F}irst {I}nternational {W}orkshop on
		  {L}isp {E}volution and {S}tandardization",
  year = 	 1988,
  editor = 	 "Christian Queinnec and J{\'e}r\^ome Chailloux",
  publisher = "IOS Amsterdam--Springfield",
  organization = "AFCET",
  address = 	 "Paris (France)"
}

@Article{Queinnec88bc,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp en renaissance",
  journal = 	 "Enjeux AFNOR",
  year = 	 1988,
  number = 	 88,
  month = 	 mar
}

@InProceedings{Queinnec88c,
  author = 	 "Christian Queinnec and Pierre Cointe",
  title = 	 "{A}n open-ended {D}ata {R}epresentation {M}odel 
                  for {E}u-{L}isp",
  booktitle = 	 lfp88,
  year = 	 1988,
  pages = 	 "298--308",
  address = 	 "Snowbird (Utah, USA)",
  ecritsdIcsla = 1,
  sourcefile =   "themes/LFP88/lc",
  ftpfile =      "lc",
  w3keyword =   "LFP88",
  abstract = "
The goal of this paper
is to describe an open-ended type system for Lisp
with explicit and full control of bit-level data representations.
This description uses a reflective architecture based on a
metatype facility. This low-level formalism solves the problem
of an harmonious  design of a class taxonomy inside a type system.

A prototype for this framework has been written in Le-Lisp and is
used to build the integrated type and object systems
of the {\eulisp} proposal."
}

@TechReport{Queinnec88d,
  author = 	 "Greg Nuyens and Christian Queinnec",
  title = 	 "{I}dentifier {S}emantics: a {M}atter of {R}eferences",
  institution =  lix,
  year = 	 1989,
  number = 	 "LIX RR 89 02, 67--80",
  month = 	 may,
  ecritsdIcsla = 1,
  sourcefile = 	"themes/LFP88/IdSem",
  ftpfile = 	"IdSem",
  w3keyword =   "TR89a",
  abstract = "
We present a clear semantics for identifier use.  Using precise
terminology, this semantics accounts for: the creation, use, modification
and visibility of bindings, as well as the mention of identifiers. It
covers current practice in Lisp-like languages, while incorporating
features usually found outside Lisp.  This semantics is shown to be
viable for both Lisp$_1$ (unified function and value cell Lisp) and
Lisp$_2$.  A syntactic device is included which allows concise
expression without sacrificing generality.  The ensemble has been
demonstrated in a meta-circular version, while a production version
for the next release of Le-Lisp is in progress. The associated denotational
semantics will figure in an annex of the full paper."
}

@Article{Queinnec88e,
  author = 	 "Christian Queinnec",
  title = 	 "{L}e point sur {L}isp",
  journal = 	 "Annales des t{\'e}l{\'e}communications",
  year = 	 1988,
  volume = 	 43,
  number = 	 12,
  month = 	 dec
}

@Article{Queinnec88f,
  author = 	 "Christian Queinnec",
  title = 	 "{D}ynamic {E}xtent {O}bjects",
  journal = 	 lptr,
  year = 	 1988,
  volume = 	 2,
  number = 	 1,
  pages = 	 "11-21",
  month = 	 "July-August-September",
  ecritsdIcsla = 1,
  sourcefile = 	"themes/DYNEXT/DynExt-All",
  ftpfile = 	"DynExt-All",
  w3keyword =   "LPTR88",
  abstract = "
Lisp objects are heap- rather than stack-allocated
because their extent is generally indefinite. Since
stack-deallocation is performed without running the garbage
collector, speed improvements are expected. Dedicated
hardware can stack-allocate objects associated with
reference counters or microcode daemons such that one can
exactly know the status of the object to be deallocated and perform
whatever appropriate treatment (usually a copy in the heap)
according to its reachability. However such a
solution is not efficient on stock hardware.

This paper presents and analyses a new technique to efficiently solve
this problem. It creates first class dynamic extent objects (DEO) that
are stack-allocated, permits to access them only while they are
in the stack and prevent to follow up dangling pointers. Every usual
indefinite extent object has its counterpart as a DEO associated
with the same set of operators.
Finally DEO do not require dedicated hardware and may be properly
compiled. The technique can be used within other programming languages.
Some performance figures are discussed at the end of the paper."
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1989

@InProceedings{Queinnec89,
  author =       "Christian Queinnec and Barbara Beaudoing and
                  Jean-Pierre Queille",
  title =        "{M}ark {DURING} {S}weep rather than {M}ark {THEN} {S}weep",
  booktitle =    parle89,
  year =         "1989",
  organization = lncs#" "#365,
  publisher =    springer,
  month =        jun,
  ecritsdIcsla = 1,
  sourcefile = 	"themes/GCP/gcp",
  ftpfile = 	"gcp",
  w3keyword =   "PARLE89",
  abstract = "
Garbage Collection frees the programmer from the burden of explicitly
deallocating unused data. This facility induces a considerable
overhead but also causes some delays that may affect real-time
applications.  Guaranteed throughput (with at most short and
predictable delays) is needed in many applications such as plane or
plant control and requires at least a worst case analysis to identify
the performances of the whole system.  Traditional GC are made of two
phases: the marker which identifies all useful data, followed by the
sweeper which reclaims all useless data.  On-the-fly GC schemes were
introduced to permit an application and a collector to run
concurrently. That concurrency may lessen the GC penalty incurred by
the application.

We present here a new algorithm where the application,
the marker and the sweeper are concurrent. The benefit is to tightly
adjust collection rate to application consumption and have an allocation
time bounded by a small constant. Moreover our algorithm does not waste memory
and appears to be well suited for embedded systems.

This ``mark {\sc during} sweep'' algorithm is completely presented.  An
interesting single-processor and incremental realisation is also
analysed and followed by  some implementation variations."
}

@TechReport{Queinnec89a,
  author = 	 "Christian Queinnec",
  title = 	 "{L}isp -- {A}lmost a whole {T}ruth",
  institution =  lix,
  year = 	 1989,
  number = 	 "LIX/RR/89/03, 79--106",
  month = 	 dec,
  ecritsdIcsla = 2,
  sourcefile = 	"themes/FEMTO/nano",
  ftpfile = 	"nano",
  w3keyword =   "TR89b",
  abstract = "
Lisp is well known for its metacircular definitions. They differ by their
intent (what they want to prove), their means (what linguistic features are
allowed for the definition) and by their scope (what linguistic features
are described). This paper provides a new metacircular definition for a
complete Lisp system including traditionally neglected features such as
{\tt cons}, {\tt read}, {\tt print} and {\tt error}. 
The programming style adopted for this
interpreter is inspired both by denotational semantics and its
continuation passing style (to explain continuation handling) and by the
object oriented paradigm as highlighted by type-driven generic functions.
The resulting interpreter lessens the number of primitives it uses to
only eight: {\tt car}, {\tt cdr}, {\tt rplaca}, 
{\tt rplacd}, {\tt eq}, {\tt read-char}, {\tt write-char} and
{\tt end}, while still providing Scheme-like essential capabilities (less
arithmetic). The overall size is near 500 lines of fully encapsulated
code that, if efficiency is not the main requirement, can be easily
turned into a stand alone program."
}

@Article{Queinnec89b,
  author = 	 "Christian Queinnec",
  title = 	 "{V}alidation {S}uite {G}eneration",
  journal = 	 bigre,
  year = 	 1989,
  number = 	 65,
  pages = 	 "134--144",
  month = 	 jul,
  ecritsdIcsla = 2,
  sourcefile = 	"themes/VSG/vsg",
  ftpfile = 	"vsg",
  w3keyword =   "BIGRE89",
  abstract = "
To validate big systems is a very complex task which has not been
solved yet. Many researchers have addressed the more restricted problem
of language validation but still did not
succeed. One reason is the lack of a semantical definition of the
language to be validated, the other reason is that such a semantics is often
considered as a theoretical object unable to provide more than meanings
to programs.

To validate a Lisp-like system is still a large problem due to the
number of its essential constructs (special forms and other unusual
features like {\tt eval} or multiple values) and to the size of its
run-time support of which the garbage collector is the main and most
complex part. However --- since Scheme
has only a few features and
may be considered as an efficient $\lambda$-calculus,
--- since  $\lambda$-calculus is the support of Denotational Semantics
and denotational semantics for Scheme
has already been published and
eventually --- since
the equation ``{\it program $=$ data}'' holds in Scheme,
it seems therefore possible to make use of the denotational semantics
of Scheme to generate validation suites.

The paper will present this technique, its implementation (via streams)
and some experimental results."
}

@Article{Queinnec89c,
  author = 	 "Christian Queinnec and Nitsan S{\'e}niak",
  title = 	 "{P}uzzling with current puzzles",
  journal = 	 lptr,
  year = 	 1989,
  volume = 	 2,
  number = 	 3,
  month = 	 jan,
  ecritsdIcsla = 2,
  w3keyword = "LPTR89"
}

@TechReport{Queinnec89e,
  author = 	 "Christian Queinnec",
  title = 	 "{R}easonable {L}isp",
  institution =  lix,
  year = 	 1990,
  number = 	 "LIX RR 90 01, 37--84",
  month = 	 jan,
  ecritsdIcsla = 3,
  sourcefile = 	"themes/RL/rl",
  ftpfile =	"rl",
  w3keyword =   "RL89",
  abstract = "
This document is a trial to define a reasonable Lisp language.
Its design spirit was to precisely describe a slightly extended kernel of
currently used Lisps in order to provide answers to semantic questions
such as evaluation order, evaluation time or evaluation
environment. The main aspect of this work was
to select an harmonious and efficient bunch among all interesting
features that have been experimented for many years in many
Lisp implementations.
Many design decisions might have been far more ambitious,
but we thought that it was preferable to live in a ``deterministic'' Lisp,
whatever it may be, rather than in a poorly semantically defined Lisp
with many trouble spots. On the other hand we tried to give a reasonable
meaning to many fuzzy but useful constructs such as types, modules, macros,
exceptions and threads.

Care have also been taken to only design the ``run-time''
part of Lisp {\ie} to clearly separate
environmental features such as {\tt trace}, {\tt *evalhook*} or
{\tt remove-method} \ldots
from execution primitives and to exclude the former features: programs must
not use environmental features to be run.
We put a great emphasis not to be encumbered by costly run-time
data; symbols are, for instance, nearly eliminated from run-time.
We also try not to reject interpretation nor the possibility of
development of production environments.

The form of the document is also an attempt of mixing formal semantics
with description text. All essential linguistic features are described
by a commented denotation. Other parts such as library
functions or useful macros are not present, since they do not introduce
semantical problems: they surely must be defined but the means to define
them (Lisp itself) are already present in this document.
This work is left to implementors or to users."
}

@InProceedings{Queinnec89f,
  author = 	 "A Pasquier and P Est{\`e}ve and O Roubine and C Queinnec
                  and V Delacour",
  title = 	 "{FLTR3}: {O}bject {O}riented {E}xtensions to a
		  {S}trongly {T}yped {R}eal-{T}ime {L}anguage",
  booktitle = 	 tools89,
  year = 	 1989,
  pages = 	 "115--122",
  address = 	 "Paris (France)",
  month = 	 nov,
  ecritsdIcsla = 3,
}

@Article{Queinnec89g,
  author = 	 "A Pasquier and P Est{\`e}ve and O Roubine and C Queinnec
                  and V Delacour",
  title = 	 "{FLTR3} : {E}xtensions \`a objets pour un langage temps
		  r{\'e}el fortement typ{\'e}",
  journal = 	 "G{\'e}nie Logiciel",
  year = 	 1989,
  number = 	 17,
  pages = 	 "58--67",
  month = 	 dec
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1990

@InProceedings{Queinnec90a,
  author = 	 "Christian Queinnec",
  title = 	 "{A} {F}ramework for {D}ata {A}ggregates",
  crossref =     "actes-jfla90",
  pages = 	 "21--32",
  ecritsdIcsla = 3,
  sourcefile = 	"themes/REFLTYP/refltyp",
  ftpfile = 	"refltyp",
  w3keyword =   "JFLA90",
  abstract = "
The representation of data aggregates is fundamentally made of
concatenation and/or repetition of smaller representations. These
structurations may be arbitrarily composed to form complex
aggregates of primitive representations such as characters, integers
or pointers. Knowing its structuration allows the interpretation of a
sequence of contiguous bits as an instance of a type represented by the
given structuration. This paper presents a formalization of data
representations, it identifies and analyses the features which
describe primitive representations as well as representation
structurers which allow to compose data representations.
These features can be very naturally expressed in terms
of objects, classes and methods.

Our model makes structurations fully explicit:
some computations can be performed
on them. We will show how to derive a general data inspector and a
garbage collector from them. We also present an extension of the subclass
concept based on concatenation of representations. All these
capabilities participate to the definition of a low level machinery for
a powerful and generalized memory management."
}

@Proceedings{Queinnec90aa,
   crossref = "actes-jfla90"
}

@InProceedings{Queinnec90b,
  author = 	 "Christian Queinnec",
  title = 	 "{S}truggle, {T}he {F}irst {D}enotational {G}ame",
  booktitle = 	 europal90,
  year = 	 1990,
  pages = 	 "351-361",
  month = 	 mar,
  address =     "Cambridge (UK)",
  ecritsdIcsla = 3,
  sourcefile = 	"themes/STRUGGLE/strugman",
  ftpfile = 	"strugman",
  w3keyword =   "EUROPAL90a",
  abstract = "
Games are often complex enough that new winning strategies cannot
be devised without a clear and precise knowledge of the rules of the game.
This situation makes games candidate to clear specifications and
denotational semantics an interesting framework to specify games.

This paper introduces a new game where two programs fight against
each other by alteration of their code: program errors lead to death.
Programs are written in a Scheme-like language
with {\tt lambda}, {\tt setq}, {\tt prog2},
{\tt if} and {\tt quote} special forms.
Another unusual special form {\tt fork} is offered
which allows to run independent threads.
Programs are interpreted in a very special way with continual
references to the store which acts as the fighting arena.
Data are restricted to functions (closures), symbols and dotted pairs.
Primitives are only
%{\tt cons},
{\tt car}, {\tt cdr},
{\tt consp}, {\tt eq}, {\tt rplaca} and {\tt rplacd}. The
two lattest primitives are the weapons that can alter
the code structure of the opponent, conversely they can also be used to
repair its own structure.

Although very simple, these capabilities must be precisely defined
since they are the rules of the game.
To know, for instance, the number of steps
taken by the execution of some construct
as well as the semantics of threads is answered by
the denotational semantics of the game.

The paper is probably the first use of denotational semantics in the
realm of games and as such may be viewed as an exercise in
denotation. It also offers some insights on
the meaning of the {\it data\/} =
{\it program\/} equation inside interpreters. Eventually it follows
the Lisp tradition and offer a world-wide arena for cleverness."
}

@Article{Queinnec90c,
  author = 	 "Christian Queinnec",
  title = 	 "{A} {S}ubjective {V}iew of {L}isp",
  journal = 	 lptr,
  year = 	 1990,
  volume = 	 3,
  number = 	 1,
  month = 	 jan,
  ecritsdIcsla = 3,
}

@TechReport{Queinnec90d,
  author = 	 "Christian Queinnec and Julian Padget",
  title = 	 "A deterministic Model for Modules and Macros",
  institution =  "University of Bath",
  year = 	 1990,
  type = 	 "Bath Computing Group Technical Report",
  number = 	 "90-36",
  address = 	 "Bath (UK)",
  ecritsdIcsla = 3,
  sourcefile = 	"themes/MODULE",
  ftpfile = 	"modmac2",
  w3keyword =   "BCG90",
  abstract = " Lisp has some specialised capability for reflective
operations, exemplified by its macro facility, structured name
spaces, file compilation, file loading and dynamic code synthesis.
There has been some progress in the last few years on the semantics
of macros, but the other operations have been categorized as
environmental issues.  In this paper, we present a semantics for
modules and will show that it substantially reduces the difficulty of
defining precisely several features of usual Lisp systems such as
macros, module compilation (file compilation), module loading (fasl
loading) and dynamic evaluation.  The module schema addresses the
questions of name visibility and separate compilation.
Macro-expansion is specified relative to where and how it takes place
as part of operations on modules.

We do not present a radical Lisp,
but rather one that tries to stay within the commonly understood Lisp
paradigm.  We do not simply borrow from other languages --- the
particular behaviour of Lisp precludes this.  The semantics we have
developed describes a Lisp with modules and macros enhancing
portability and understandability.
"
}

@Article{Queinnec90e,
  author = 	 "Christian Queinnec",
  title = 	 "{F}iltrage et compilation",
  journal = 	 bigre,
  year = 	 1990,
  number = 	 70,
  pages = 	 "25--36",
  month = 	 sep,
  note = 	 "Actes des Journ{\'e}es Groplan AFCET, janvier 1990
                  (Nice, France)",
  abstract = "
Le filtrage est un important concept linguistique notamment dans le domaine
des syst\`emes experts. C'est aussi un chapitre consacr\'e figurant dans
tous les livres c\'el\'ebrant Lisp. Le filtrage est largement
utilis\'e dans les langages fonctionnels tels que ML ou Miranda\trademark.
Pourtant ces deux emplois sont diff\'erents puisque les langages
fonctionnels mettent l'accent sur une discrimination fond\'ee sur le
type tandis que Lisp ou Plasma font usage de listes et de segments de
listes au sein des filtres ou motifs. Le pr\'esent article pr\'esente
un langage de filtrage ainsi que sa s\'emantique d\'enotationnelle.
Ce langage, quoique r\'eduit, est assez puissant pour exprimer les
compositions bool\'eennes de filtres, le filtrage par segments et la
r\'ep\'etition non born\'ee de motifs. Un compilateur de ce langage est
ensuite d\'efini qui traduit ces filtres en un code fonctionnel.
Nous pr\'esentons une esquisse des r\`egles de typage des filtres.
Ce travail, qui est assez ind\'ependant du langage sous-jacent, rend
le filtrage efficace et utile car il permet d'incorporer aux motifs
une connaissance li\'ee \`a la forme ou {\it gestalt} des donn\'ees
\`a traiter."
}

@InProceedings{Queinnec90f,
  author = 	 "Christian Queinnec",
  title = 	 "{C}ompilation of {N}on-{L}inear, {S}econd {O}rder
		  {P}atterns on {S}-{E}xpressions",
  booktitle = 	 lncs#" 456",
  year = 	 "1990",
  editor = 	 "P Deransart and J Ma{\l}uszy{\'n}ski",
  pages = 	 "340--357",
  organization = plilp90,
  publisher = springer,
  address = 	 "Link{\"o}ping",
  month = 	 aug,
  ecritsdIcsla = 4,
  sourcefile = 	"themes/CSA/csm",
  ftpfile =	"csm",
  w3keyword =   "PLILP90",
  abstract = "
Pattern matching is a key concept for rule-based expert systems.
Simple pattern interpreters appear in nearly every book on Lisp.
Pattern matching is also a useful tool for case analyses as provided by
functional languages such as ML or Miranda\trademark.
These two uses are somewhat different since functional languages
emphasize a discrimination based on types while Lisp, or Plasma,
make use of S-expressions or segments of S-expressions within patterns.
The paper presents an intermediate language for patterns and
its denotational semantics. This reduced language is powerful enough to
express boolean composition of patterns as well as segment handling and
unbounded pattern repetition. A compiler is then defined which translates
patterns into functional code. We discuss some compilation variant as
well as the integration of the pattern sub-language into Lisp.
These capabilities make
pattern matching an useful and efficient tool for a wide class of
applicative languages and allow to incorporate into patterns more knowledge
about the form or {\it gestalt\/} of the data to be matched."
}

@InProceedings{Queinnec90g,
  author = 	 "Christian Queinnec",
  title = 	 "{P}oly{S}cheme : {A} {S}emantics for a {C}oncurrent
		  {S}cheme",
  booktitle = 	 "Workshop on High Performance and Parallel Computing in Lisp",
  year = 	 1990,
  organization = europal,
  address = 	 "Twickenham (UK)",
  month = 	 nov,
  ecritsdIcsla = 4,
  sourcefile = 	"themes/POLYSCM/polyman",
  ftpfile = 	"polyman",
  w3keyword =   "EUROPAL90b",
  abstract = "
The Scheme language does not fully specify the
semantics of combination: the evaluation order of the terms composing
a combination is left indeterminate.  We investigate in this paper a
different semantics for Scheme where terms of combinations are evaluated
concurrently. The resulting semantics models a language with concurrent
threads sharing a common workspace. The semantics is given in terms
of denotational semantics and uses resumptions as well as a choice operator:
{\it oneof\/} which mimics a scheduler.
An alternate definition for this operator lets appear
the classical powerdomains. The main interest of this operator is to
offer a formalization that can be read with an operational point of view
while keeping a firm theoretical base.

Scheme also offers first class continuations with indefinite extent;
we examine some semantics for continuations with respect to
concurrency. Each of these semantics is a natural extension
of the sequential case of regular Scheme. Still they strongly
differ in their observed behaviours.

The resulting language, named PolyScheme, offers much of the features
of current concurrent Lisp (or Scheme) dialects thanks to the sole
extension of its combination semantics and without any explicit
specialized construct dealing with concurrency."
}

@Book{Queinnec90h,
  author = 	 "Christian Queinnec",
  title = 	 "{L}e filtrage : une application de (et pour) {L}isp",
  publisher = 	 "Inter{\'E}ditions",
  year = 	 1990,
  address = 	 "Paris (France)",
  isbn =         "ISBN 2-7296-0332-8",
  coverpage   =  "lF.png"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1991


@InProceedings{Queinnec91a,
  author = 	 "Christian Queinnec and Bernard Serpette",
  title = 	 "{A} {D}ynamic {E}xtent {C}ontrol {O}perator for
		  {P}artial {C}ontinuations",
  booktitle = 	 popl91,
  year = 	 1991,
  pages = 	 "174--184",
  address = 	 "Orlando (Florida USA)",
  month = 	 jan,
  ecritsdIcsla = 5,
  sourcefile = 	"themes/DECC/popl6",
  ftpfile = 	"popl6",
  w3keyword =   "POPL91",
  abstract = "
A partial continuation is a prefix of the computation that remains to
be done. We propose in this paper a new operator
which precisely controls which prefix is to be abstracted into a partial
continuation. This operator is strongly related to the notion of
dynamic extent which we denotationally characterize.
Some programming examples are commented and
we also show how to express previously proposed control operators.
A suggested implementation is eventually discussed."
}

@Proceedings{Queinnec91aa,
  crossref = "actes-jfla91"
}

@InProceedings{Queinnec91b,
  author = 	 "Christian Queinnec",
  title = 	 "{C}rystal {S}cheme, {A} {L}anguage for {M}assively
		  {P}arallel {M}achines",
  editor =       "M Durand and F {El Dabaghi}",
  booktitle = 	 "Second Symposium on High Performance Computing",
  year = 	 1991,
  pages =        "91-102",
  publisher =    north-holland,
  address = 	 "Montpellier (France)",
  month = 	 oct,
  ecritsdIcsla = 5,
  sourcefile = 	"themes/CRYSTAL/shpc",
  ftpfile =	"shpc",
  w3keyword =   "SHPC91",
  abstract = "
Massively parallel computers are built out of thousand conventional
but powerful processors with independent memories. Very simple
topologies mainly based on physical neighbourhood link these
processors. The paper discusses extensions to the Scheme language in
order to master such machines. Allowing arguments of functions to be
concurrently evaluated introduces parallelism. Migration across the
different processors is achieved through a remote evaluation
mechanism. We propose a clean semantics for first class continuations
in presence of concurrency and show how they can be used to build,
in the language itself, advanced concurrent constructs such as futures.
Eventually we comment some simulations, with various topologies and
migration policies, which enables to appreciate our previous
linguistical choices and confirms the viability of the model."
}

@InProceedings{Queinnec91c,
  author = 	 "Christian Queinnec and Julian Padget",
  title = 	 "Modules, macros and {L}isp",
  booktitle = 	 "Eleventh International Conference of the Chilean
		  Computer Science Society",
  year = 	 1991,
  pages = 	 "111-123",
  publisher =    "Plenum Publishing Corporation, New York NY (USA)",
  address = 	 "Santiago (Chile)",
  month = 	 oct,
  ecritsdIcsla = 6,
  sourcefile = 	"themes/MODULE/chili",
  ftpfile =	"chili",
  w3keyword =   "ICCCSS91",
  abstract = "
Many modern languages offer a concept of modules to encapsulate a set
of definitions and make some of them visible from outside.  Associated
to modules are directives ruling importations and exportations as well
as controlling other capabilities like renaming or qualified notation.
We propose here a language to handle sets of named locations with the
aim of describing precisely which locations are to be shared between
modules and under which local names they are known.  The language is
symmetric for imports and exports. It is also extensible since it
provides a framework to handle named locations.  Mutability, for
instance, can readily be expressed thanks to a simple extension of our
language.

Another more subtle extension is to offer a protocol for modules with
``macros''. Macros allow a user to extend the syntax of a language by
providing rewriting rules expressed as computations performed on the
representation of programs.  Lisp is a language offering macros and
much of its extensibility stems from them.  However, many problems
arise from macros, amongst them being the exact definition of when,
where and how the macroexpansion is done to turn the body of a module
using extended syntaxes into a regular form in the bare, unextended
language.

This paper presents, in the framework of Lisp, a definition of modules
offering tight control over module environments as well as
a precise semantics of separate compilation
and macroexpansion. These new (for Lisp) capabilities definitely
add some power relative to the management of name spaces but also
justify compiling optimizations (inlining, partial evaluation etc.)
and, above all, turn Lisp into a language
suitable for application delivery since applications are finite
collections of modules. Our proposal contributes to a vision of
Lisp composed of a multitude of linked and reusable modules.
Our results concerning name space management and macros
can also be applied to other languages.

Two different implementations of these concepts exist: in FEEL, the
implementation of EuLisp done by the University of Bath and in the idiom
of Icsla, a dialect of Lisp designed at INRIA-Rocquencourt and \'Ecole
Polytechnique. This paper reflects the results of the experiments
carried out in these systems during the last year."
}

@InProceedings{Queinnec91d,
  author = 	 "Christian Queinnec and Julian Padget",
  title = 	 "{A} Proposal for a Modular {L}isp with Macros and
		  Dynamic Evaluation",
  booktitle = 	 "Journ{\'e}es de Travail sur l'Analyse Statique en
		  Programmation {\'E}quationnelle, Fonctionnelle et Logique",
  year = 	 "1991",
  pages = 	 "1--8",
  publisher =    bigre#" 74",
  address = 	 "Bordeaux (France)",
  month = 	 oct,
  w3keyword =   "JTASPEFL91",
  abstract = "
Lisp has some specialised capability for reflective operations,
exemplified by its macro facility, structured name spaces, file
compilation, file loading and dynamic code synthesis.  There has been
some progress in the last few years on the semantics of macros, but
the other operations have been categorized as environmental issues.
In this paper, we present a semantics for modules and will show that
it substantially reduces the difficulty of defining precisely several
features of usual Lisp systems such as macros, module compilation
(file compilation), module loading (fasl loading) and dynamic
evaluation.  The module schema addresses the questions of name
visibility and separate compilation.  Macro-expansion is specified
relative to where and how it takes place as one of the operations on
modules. "
}

@TechReport{Queinnec91e,
  author = 	"Christian Queinnec",
  title = 	"{\sc Meroon}: A Small, Efficient and Enhanced Object
                 System",
  institution = "{\'E}cole Polytechnique",
  year = 	"1991",
  type =        "Technical Report",
  number =      "LIX.RR.92.14",
  address =     "Palaiseau Cedex, France",
  month =       nov,
  ecritsdIcsla = 7,
  sourcefile = 	"DEA/Meroon-V3/Doc/MeroonV3",
  ftpfile = 	"../Reports/MeroonV3",
  programfile = "Programs/MeroonV3-98Feb09.tar.gz",
  abstract = "
{\meroon} is a very simple object system and therefore is easy to
master at the usual level or at the meta-level. Regular usage
requires to know only three macros ({\tt define-class}, {\tt
define-generic} and {\tt define-method}) as well as some naming rules
to be able to use all the various functions that are automatically
generated when classes are defined.  Yet {\meroon} is not too
inefficient since to send a message costs approximatively 2.5 function
calls independently of the number of methods defined on the class.
Moreover {\meroon} is easily portable. Some parts may of course be
improved if functions can be inspected or if weak pointers are
offered in the underlying Scheme system.  {\meroon} also provides
some features not found elsewhere such as the possibility to have
indexed fields combined with unrestricted inheritance. This
capability allows an implementation to only provide {\meroon} objects
instead of vectors and structures etc.
"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1992

Aussi en rapport technique X
@InProceedings{Queinnec92a,
  author = 	 "Bernard Lang and Christian Queinnec and Jos{\'e} Piquer",
  title = 	 "Garbage Collecting the World",
  booktitle = 	 popl92,
  year = 	 "1992",
  pages = 	 "39--50",
  address = 	 "Albuquerque (New Mexico, USA)",
  month = 	 jan,
  ecritsdIcsla = 6,
  sourcefile = 	"themes/GChd/gc",
  ftpfile = 	"gc",
  w3keyword =   "POPL92",
  abstract = "
Distributed symbolic computations involve the existence of {\em remote
references} allowing an object, local to a processor, to designate another
object located on another processor. To reclaim inaccessible objects is
the non trivial task of a distributed Garbage Collector (GC).  We present
in this paper a new distributed GC algorithm which
{ \em(i)\/} is fault-tolerant,
{ \em(ii)\/} is largely independent of how a processor garbage collects its
      own data space,
{ \em(iii)\/} does not need centralized control nor global stop-the-world
      synchronization,
{ \em(iv)\/} allows for multiple concurrent active GCs,
{ \em(v)\/} does not require to migrate objects from processor to processor and
{ \em(vi)\/} eventually reclaims all inaccessible objects including
      distributed cycles.

These results are mainly obtained through the concept of a {\em group}
of processors (or processes).
 Processors of a same group cooperate together to a GC inside this group;
this GC is conservative with respect to the outside of the group.
 A processor contributes to the global GC of all groups to which it
belongs. Garbage collection on small groups reclaims quickly locally
distributed garbage clusters, while garbage collection on large groups
ultimately reclaims widely distributed garbage clusters, albeit more
slowly.
 Groups can be reorganized dynamically, in particular to tolerate
failures of some member processors.
 These properties make the algorithm usable on very large and evolving
networks of processors.
 Other than distributed symbolic computations, possible applications
include for example distributed file or database systems."
}

@Proceedings{Queinnec92b,
  crossref = "actes-jfla92"
}

@Article{Queinnec92tr1,
  author =       "Christian Queinnec",
  title =        "Compiling Syntactically Recursive Programs",
  journal =   lptr,
  year =      1992,
  volume =    5,
  number =    4,
  pages =     "2--10",
  month =     "October-December",
  ecritsdIcsla = 7,
  sourcefile   = "themes/SYNREC/synrec",
  ftpfile = 	"synrec",
  w3keyword =   "LPTR92",
  abstract = "
The representation of Lisp programs is based on S-expressions.
Side-effects on S-expressions allied to macros allow to easily build
{\em syntactically recursive} programs {\ie} programs, the representation
of which contains cycles.  Usual compilers are defeated by these
programs since they only expect {\em regular} programs {\ie} programs
with finite DAG-like representation.  The paper proposes a program
transformation that translates possibly syntactically recursive
programs into equivalent regular programs. This result lessens the gap
between Lisp interpreters and compilers and, in particular, allows the
dynamic evaluation facility {\ie} the {\tt eval} function, to be fully
compiler-based."
}

@InProceedings{Queinnec92c,
  author =       "Christian Queinnec and Jean-Marie Geffroy",
  title =        "Partial Evaluation applied to Symbolic Pattern
                  Matching with Intelligent Backtrack",
  editor =    "M Billaud and P Cast{\'e}ran and MM Corsini and K
                  Musumbu and A Rauzy",
  number =    "81-82",
  series =    bigre,
  pages =     "109--117",
  booktitle = "WSA '92---Workshop on Static Analysis",
  year =      1992,
  address =   "Bordeaux (France)",
  month =     sep,
  ecritsdIcsla = "7",
  sourcefile   = "themes/PEWIB/pewib",
  ftpfile = 	"pewib",
  w3keyword =   "WSA92a",
  abstract = "
We present in this paper a general pattern matching algorithm which
leads to a very clever pattern compiler thanks to partial evaluation.
We examine some target code produced for classical patterns, and show
how techniques such as Kuth-Morris-Pratt or Boyer-Moore (in the domain
of string or tree matching) are automatically re-discovered by our 
compiler."
}

@InProceedings{Queinnec92d,
  author = 	 "Christian Queinnec",
  title = 	 "A Concurrent and Distributed Extension to Scheme",
  booktitle = 	 parle92,
  year = 	 "1992",
  editor = 	 "D. Etiemble and J-C. Syre",
  pages = 	 "431--446",
  organization = lncs#" 605",
  publisher = springer,
  address = 	 "Paris (France)",
  month = 	 jun,
  ecritsdIcsla = 6,
  sourcefile = 	"themes/CRYSTAL/parle",
  ftpfile = 	"parle",
  w3keyword =   "PARLE92",
  abstract = "
The Lisp family of languages has traditionally been a privileged
domain where linguistic experiments were done, this paper presents a
new dialect offering concurrency and distribution. This dialect,
nicknamed CD-Scheme, has been designed above Scheme with as few as
possible features to allow a great expressiveness but still to retain
the original consistency and simplicity of Scheme. We explicitly show
how common parallel constructs can be written in regular CD-Scheme.

A denotational semantics is also presented that expresses the detailed
meaning of assignment, data mutation, continuations in presence of
concurrency and distribution. This semantics offers a basis to
understand new proposals of concurrent or distributed features and may
be used to justify compiler optimizations or implementation
techniques.  The proposed set of features of CD-Scheme can be also
used to extend languages other than Scheme."
}

@InProceedings{Queinnec92e,
  author =       "Christian Queinnec",
  title =        "Value Transforming Style",
  editor =    "M Billaud and P Cast{\'e}ran and MM Corsini and K
                  Musumbu and A Rauzy",
  number =    "81-82",
  series =    bigre,
  pages =     "20--28",
  booktitle = "WSA '92---Workshop on Static Analysis",
  year =      1992,
  address =   "Bordeaux (France)",
  month =     sep,
  annote =      "short version of \cite{Queinnec92f}.",
  abstract = "
A new program transformation is presented that allows to remove
control operators related to partial continuations. The basis for the
transformation is to adopt an improved representation for
continuations that makes frames apparent. Various examples of control
operators with or without dynamic extent stress are presented.
"
}

@TechReport{Queinnec92f,
  author =       "Christian Queinnec",
  title =        "Value Transforming Style",
  institution =  "Laboratoire d'Informatique de l'{\'E}cole Polytechnique",
  year =         1992,
  type =      "Research Report",
  number =    "LIX RR 92/07",
  address =   "91128 Palaiseau Cedex, France",
  month =     may,
  ecritsdIcsla = 7,
  sourcefile = 	"themes/TVS/vts",
  w3keyword =   "WSA92b",
  ftpfile =	"vts"
}

@InProceedings{Queinnec92g,
  author =       "Christian Queinnec and David {De\,Roure}",
  title =        "Design of a concurrent and distributed language",
  editor =    "Robert H {Halstead Jr} and Takayasu Ito",
  volume =    lncs#" 748",
  pages =     "234--259",
  booktitle = "Parallel Symbolic Computing: Languages, Systems, and
                  Applications, (US/Japan Workshop Proceedings)",
  year =      "1993",
  address =   "Boston (Massachussetts USA)",
  month =     oct,
  ecritsdIcsla = "8",
  sourcefile = 	"icslas/pwb",
  ftpfile = 	"pwb",
  w3keyword =   "PSC:LSA92",
 abstract = "
This paper presents the idiom of Icsla (Icsla, standing for
  interpretation, compilation and semantics of applicative languages,
  is the name of a joint project between \'Ecole Polytechnique 
  and INRIA-Rocquencourt, hence the name of the designed language),
a language belonging
to the Lisp family and more precisely a descendant of Scheme. This
dialect has been designed with respect to the following main
objectives: 
--- It should have a very simple and understandable semantics, 
      with few but powerful and unrestrictively combinable concepts;
--- It should offer concurrency, distribution and some other modern
      features such as sophisticated control features
      while not sacrificing the variety of styles traditionally
      offered by Lisp.
"
}

@TechReport{Queinnec92h,
  author =       "Christian Queinnec",
  title =        "Continuation Sensitive Compilation",
  institution =  lix,
  year =         1992,
  type =      "Research Report",
  number =    "LIX RR 92/14",
  address =   "91128 Palaiseau Cedex, France",
  month =     nov,
  annote =    "weeding",
  ecritsdIcsla = 7,
  sourcefile = 	"themes/CSC/csc",
  ftpfile =	"csc",
  abstract  = "
This paper presents a compilation technique for Scheme-like languages
where functions may look at their continuation before pushing frames
onto it. This allows for some optimizations when the frame to be
pushed and the frame on top of the continuation can be combined into a
single and simplified frame.  Among possible simplifications are:
intermediate data structure elimination and removal of redundant calculations.
Functions can therefore be compiled with respect to their near future
and reorganize it when appropriate.

The compilation technique is based on an improved CPS-like
transformation that makes continuation ({\ie} stack) frames explicit. Shape
of continuations is approximated to determine which frames would
gain by being combined together then partial evaluation is used to
determine the behavior of combined frames.  Our main results cover
local deforestation-like effect as well as iterative compilation of
associatively wrapped recursions.
"
}

@Article{Queinnec92i,
  author =       "Jos{\'e} M Piquer and Christian Queinnec",
  title =        "TransPive: A Distributed Lisp System",
  journal =   "La lettre du Transputer, Laboratoire d'Informatique de
                  Besan{\c{c}}on",
  year =      1992,
  number =    16,
  pages =     "55--68",
  month =     dec,
  ecritsdIcsla = 8,
  sourcefile = 	"themes/TRANSPIVE/transpive",
  w3keyword =   "TRANSP92",
  ftpfile = 	"transpive"
}

@Article{Queinnec92j,
  author =       "Christian Queinnec",
  title =        "A Library of high-level control operators",
  journal =      lptr,
  year =         1993,
  volume =       6,
  number =       4,
  pages =        "11--26",
  month =        oct,
  ecritsdIcsla = 9,
  sourcefile = 	"themes/CONTLIB/contlib",
  ftpfile =	"contlib",
  w3keyword =   "LPTR93b",
  programfile =	"Programs/contlib94Apr25.tar.gz",
  abstract ="
Numerous high-level control operators, with various properties, exist
in the literature. To understand or compare them is difficult since
their definitions use quite different formal frameworks; moreover, to
our knowledge, no implementation offers them all. This paper tries to explain
control operators by the often simple stack manipulation they
perform. We therefore present what we think these operators are, in an
executable framework derived from abstract continuations. This library
is published in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. For instance, we do not claim our
implementation to be faithful nor we attempt to formally derive these
implementations from their original definitions. The goal is to give a
flavor of what control operators are, from an implementation  point
of view. Last but worth to say, all errors are mine.
"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1993

@Article{Queinnec93a,
  author =       "Christian Queinnec",
  title =        "Continuation Conscious Compilation",
  journal =   lptr,
  year =      1993,
  volume =    6,
  number =    1,
  pages =     "2--14",
  month =        jan,
  annote =    "weeding",
  ecritsdIcsla = 8,
  sourcefile = 	"themes/CSC/ccc",
  ftpfile =	"ccc",
  w3keyword =   "LPTR93a",
  abstract  = "
This paper proposes some (unimplemented) 
ideas for the compilation of Scheme-like
languages where functions may be specialized with respect to some of
the continuations with which they are invoked. This allows for some
optimizations, for instance, when a frame to be pushed and the frame
on top of the continuation can be combined into a single and
simplified frame.  Among possible improvements are: intermediate data
structure elimination and removal of useless calculations.  Functions
can therefore be compiled with respect to their near future and
reorganize it when appropriate.

The compilation technique is based on a program transformation named
Abstract Continuation Passing Style that makes continuation ({\ie}
stack) frames explicit. Shape of continuations is approximated to
determine which frames would gain by being combined together then
partial evaluation is used to determine the behavior of combined
frames.  Our main results cover local deforestation-like
effect as well as iterative compilation of associatively wrapped
recursions.
"
}

@TechReport{Queinnec93b,
  author =       "Christian Queinnec",
  title =        "Literate programming from Scheme to {\TeX}",
  institution =  lix,
  year =         1993,
  type =      "Research Report",
  number =    "LIX RR 93.05",
  address =   "91128 Palaiseau Cedex, France",
  month =     nov,
  sourcefile =    	"scm/LiSP/LiSP2TeX",
  ftpfile =	"LiSP2TeX",
  programfile =	"Programs/LiSP2TeX2001Jan06.tar.gz",
  ecritsdIcsla = 8,
  abstract = "
This report describes a system that allows easy insertions of Scheme,
or Lisp, code towards {\TeX} files. The originality of {\rm LiSP2\TeX} is
that it extracts Scheme definitions from the files where they appear
and wraps them appropriately within {\TeX} macros for insertion into
the documentation file. {\rm LiSP2\TeX} decorrelates writing documentation
from programming: it is therefore possible to separately develop
programs and documentations and to merge them at the end to produce up
to date final documents. {\rm LiSP2\TeX} also has some pretty-printing
capabilites to produce denotations full of greek letters. {\rm LiSP2\TeX}
has been used for more than two years.

This documentation is a reference guide to {\rm LiSP2\TeX} and, being
itself processed by {\rm LiSP2\TeX}, it provides some examples of use 
both in source and final form."
}

@InProceedings{Queinnec93c,
  author =       "Christian Queinnec",
  title =        "Designing {\sc{Meroon}} V3",
  editor =       {Rathke, Christian and Kopp, J\"urgen and Hohl, Hubertus and
                  Bretthauer, Harry},
  booktitle =  {Object-Oriented Programming in Lisp: Languages and 
               Applications. A Report on the ECOOP'93 Workshop},
  institution = {Gesellschaft f\"ur Mathematik und Datenverarbeitung},
  year =        1993,
  number =      788,
  address =     {Sankt Augustin (Germany)},
  month =       sep,
  sourcefile =  "DEA/Meroon-V3/Doc/oopil",
  ftpfile =	"oopil",
  programfile = "Programs/MeroonV3-98Feb09.tar.gz",
  ecritsdIcsla = 8,
  w3keyword =   "OOPL:LA93",
  abstract = "
The {\meroon} object system was originally invented for a book to
describe implementations of Lisp and Scheme. It was designed to have a
pedagogical but efficient implementation, to support separate compilation
yet to be powerful enough to unify all the data types of Scheme even
vectors and strings without restriction of inheritance.

While designing a distributed extension of Scheme \cite{Queinnec92g},
new needs appeared that a new release of {\meroon} tries to satisfy.
This paper exposes these problems and how they are solved in
{\meroon} V3. Among these new features are
{ \em(i)\/} compact dispatchers for generic functions,
{ \em(ii)\/} a new initialization protocol for a better control of mutability, 
{ \em(iii)\/} a new vision of metaclasses as a code generation mechanism 
in relation to separate compilation.

The paper first recalls the previous state of {\meroon}, presents the
new needs then their associated solutions.
"
}

@InProceedings{Queinnec93d,
  author =       "Luc Moreau and Christian Queinnec",
  title =        "Partial Continuations as the Difference of
                  Continuations, A Duumvirate of Control Operators",
  editor =       "Manuel Hermenegildo and Jaan Penjam",
  pages =        "182--197",
  booktitle =    lncs#" 844",
  year =         1994,
  organization = plilp94,
  publisher =    springer,
  address =      "Madrid (Spain)",
  month =        sep,
  sourcefile =  "themes/MOREAU/pc",
  ftpfile = 	"pc",
  ecritsdIcsla = 8,
  w3keyword =   "PLILP94",
  abstract = "
We propose to define a partial continuation as the difference of two
continuations.  We exhibit several places where design choices can be
made and the influence they have on the extent during which partial
continuations can be reified.  In particular, we characterise a notion
of extent underlying this model of partial continuation that we call
{\em weak prefixal extent\/}. Then, the semantics of partial
continuations is formalised in a context-rewriting system and in a cps
translation, both proved to be equivalent.  
This notion of partial continuation is
intuitive, it avoids the complexity of hierarchies of control
operators and it is more expressive than others.  We illustrate these
qualities with some new realistic examples.  
"
}

@Article{Queinnec93e,
  author =       "Christian Queinnec",
  title =        "Lisp et les objets",
  journal =      "Normatique",
  year =         1993,
  number =       50,
  pages =        3,
  month =        oct
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1994

@Proceedings{Queinnec94aa,
  crossref = "actes-jfla94"
}

@Book{Queinnec94a,
  author =       "Christian Queinnec",
  title =        "Les langages Lisp",
  publisher =    "Inter{\'E}ditions",
  year =         1994,
  address =      "Paris (France)",
  isbn =         {ISBN 2 7296 0549 5, 61 2448 1},
  annote =       "English version see \cite{Queinnec96}",
  programfile =  "Books/LiSP94Oct27.tar.gz",
  coverpage   =  "LiSP.png"
}

@InProceedings{Queinnec94b,
  author =       "Christian Queinnec",
  title =        "Sharing Mutable Objects and Controlling Groups of Tasks
                   in a Concurrent and Distributed Language",
  editor =       "Takayasu Ito and Akinori Yonezawa",
  series =       lncs#" 907",
  pages =        "70--93",
  booktitle =    "Proceedings of the Workshop on Theory and Practice
                  of Parallel Programming (TPPP'94)",
  year =         1994,
  publisher =    springer,
  address =      "Sendai (Japan)",
  month =        nov,
  ecritsdIcsla = "9",
  sourcefile =   "themes/DISSEM/dissem",
  ftpfile =	"dissem",
  w3keyword =   "TPPP94",
  abstract = "
This paper presents:
an operational semantics, based on a functional framework,
        for a concurrent and distributed extension of the Scheme
        programming language,
a coherency protocol taking care of shared mutable objects,
a new coherency protocol to imperatively control
        hierarchical groups of cooperating tasks.
These two protocols do not require broadcast, nor FIFO communications,
nor a centralized machine; they allow to manage an unbound number of
shared mutable values and groups of tasks. This paper also advocates
for the use of a functional continuation-based presentation for these
protocols."
}

@InProceedings{Queinnec94c,
  author =       "Christian Queinnec",
  title =        "Locality, Causality and Continuations",
  pages =        "91--102",
  booktitle =    lfp94,
  year =         1994,
  publisher =    acm-press,
  address =      "Orlando (Florida, USA)",
  month =        jun,
  ecritsdIcsla = "9",
  sourcefile =   "themes/icslas/lcc",
  ftpfile = 	"lcc",
  w3keyword =   "LFP94",
  abstract =     "
Concurrency and distribution are topics exacerbated by the
omnipresence of Internet. Although many languages address these
topics, few offer the real opportunity to control and coordinate
widely spread dynamic computations. This paper presents such a
language and its prominent features. Besides explaining the software
architecture of the implementation (based on objects and generic
functions), it also presents an original coherency protocol for shared
mutable variables.
"
}

@Article{Queinnec94d,
  author =       "Sophie Anglade and Jean-Jacques Lacrampe and
                  Christian Queinnec",
  title =        "Semantics of Combinations in Scheme",
  journal =      lptr,
  year =         1995,
  volume =       7,
  number =       4,
  pages =        "15--20",
  month =        oct#"--"#dec,
  ecritsdIcsla = 9,
  sourcefile = "themes/UNORDER/orleans",
  ftpfile =    "orleans",
  w3keyword = "LPTR95",
  abstract = "This paper 
presents a denotational semantics for the combinations of the
Scheme language. Scheme leaves unspecified the order of evaluation of
the terms of a combination. Our purpose is to formally and
denotationally characterize such indeterminacy. We achieve this by
extending the denotation as well as the domain of final answers to
take into account the various possible orders of evaluation.
"
}
                  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1995

@InProceedings{Queinnec95a,
  author =       {Christian Queinnec},
  title =        {{\dmeroon}:
    Overview of a Distributed Class-based Causally-coherent Data Model},
  booktitle =    {PSLS 95 -- Parallel Symbolic Langages and Systems},
  editor =    {Takayasu Ito and Robert H {Halstead, Jr} and Christian Queinnec},
  series =    lncs#" 1068",
  year =      1995,
  address =   {Beaune (France)},
  month =     oct,
  pages =        {297--309},
  ecritsdIcsla = 10,
  sourcefile =   "icslas/DMeroon/Doc/psls",
  ftpfile =      "psls",
  w3keyword = "PSLS95",
  abstract = "
{\dmeroon} is a library of C functions that 
provides a data model above a coherently distributed shared
memory. {\dmeroon} allows users 
to statically or dynamically create
new classes, to dynamically instantiate these classes and to
dynamically and coherently share the resulting instances over a
network. {\dmeroon} automatically 
takes care of representation and
alignment, migrating and sharing objects, local and global garbage
collections. This document describes {\dmeroon} 
and its philosophy of design."
}

@InProceedings{Queinnec95b,
  author =       {Christian Queinnec and David {De\,Roure}},
  title =        {Sharing Code through First-class Environments},
  booktitle =    {Proceedings of ICFP'96 --- ACM SIGPLAN International
                  Conference on Functional Programming},
  year =         1996,
  address =      "Philadelphia (Pennsylvania, USA)",
  month =        may,
  pages =        {251--261},
  ecritsdIcsla =  10,
  sourcefile =   "themes/MODENV/modenv",
  ftpfile =      "modenv",
  w3keyword =    "ICFP96",
  abstract = "
Nowadays the Net is one of the most obvious driving forces. Yet, to
consider it as one global store through which values and code may be
shared is still immature. This paper
suggests first-class environments as a means to achieve that goal in a
multi-user Scheme framework. We propose two new special forms with a
simple semantics. Our model allows precise control over environments
(including extensible environments) and does not require (but does not
prevent) reflective operations."
}

@Article{Queinnec95c,
  author =       {Christian Queinnec},
  title =        {Fast and Compact Dispatching for Dynamic
                  Object-Oriented Languages},
  journal =      ipl,
  year =         1998,
  volume =       64,
  number =       6,
  month =        jan,
  pages =        {315--321},
  ecritsdIcsla = 10,
  sourcefile =   "themes/DISPATCH/dispatch",
  ftpfile =      "dispatch",
  w3keyword =    "IPL98",
  abstract =     "
Dynamic Object-Oriented languages allows for dynamic definition of new
classes, new generic functions and new methods. This paper proposes a
single and compact data structure to, at the same time, facilitate the
addition of new classes, generic functions or methods, and still
ensure a fast method selection."
}

@InProceedings{Queinnec95d,
  author =       {Christian Queinnec},
  title =        {Macroexpansion Reflective Tower},
  booktitle =    {Proceedings of the Reflection'96 Conference},
  editor =    {Gregor Kiczales},
  year =      1996,
  address =      {San Francisco (California, USA)},
  month =     apr,
  pages =     {93--104},
  ecritsdIcsla =  10,
  sourcefile =   "themes/TOWEXP/towexp",
  ftpfile  =     "towexp",
  w3keywords =   "REFLECTION96",
  abstract  =    "
Macros are reflective tools that operate on the representation of
programs. Though having been used, and still being useful, for more
than thirty years, their semantics and pragmatics are still unclear.
This paper proposes a new model to understand the macroexpansion
process; this model is based on a reflective tower of macroexpansion
engines."
}
                             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1996
      
@InProceedings{Queinnec96a,
  author =       {Christian Queinnec},
  title =        {Bribes de {\dmeroon}},
  booktitle =    {Actes des journ{\'e}es de recherche sur la
                  M{\'e}moire Partag{\'e}e R{\'e}partie --- MPR 96},
  editor =       {Christian Toinard},
  year =         1996,
  address =      {Bordeaux (France)},
  month =        may,
  pages =        {51--56},
  abstract = "
Cet article est un
survol fragmentaire de {\dmeroon}, un projet inachev\'e de recherche
visant \`a l'\'ecriture d'une biblioth\`eque multilingue procurant un
mod\`ele de m\'emoire dynamique, distribu\'ee et partag\'ee. Rien
n'est original dans cet article fors l'emploi du fran\c{c}ais. Son
contenu provient de \cite{Queinnec94c} et \cite{Queinnec95a} amend\'e de
r\'eflexions d\'ecousues mais motiv\'ees par l'\'ecriture des
programmes composant cette biblioth\`eque.
"
}

@Book{Queinnec96,
  author =       {Christian Queinnec},
  title =        {Lisp in Small Pieces},
  publisher =    {Cambridge University Press},
  year =         1996,
  isbn =         {ISBN 0 521 56247 3},
  programfile =  "Books/LiSP94Oct27.tar.gz",
  coverpage   =  "LiSPeng.png"
}

@Article{Queinnec96b,
  author =       {Christian Queinnec and Pierre Weis},
  title =        {Programmation applicative, {\'E}tat des lieux et
                  perspectives},
  journal =      "Technique et science informatiques",
  year =         1996,
  volume =       15,
  number =       7,
  pages =        {1009--1013},
  sourcefile =   "themes/ARTICLE/langappl",
  ftpfile  =     "langappl",
  abstract  =    "
Apr\`es avoir rappel\'e la lign\'ee des langages de programmation
applicative, nous d\'ecrivons les qualit\'es qui font leur succ\`es, en
particulier dans l'enseignement. Nous brossons ensuite leurs perspectives
d'avenir et donnons en annexe une liste des syst\`emes francophones
disponibles."
}

@TechReport{Queinnec96c,
  author =       {Luc Moreau and Christian Queinnec},
  title =        {On the Finiteness of Resources in Distributed Computing},
  institution =  {INRIA},
  year =         1997,
  type =         {Research Report},
  number =       {3147},
  month =        apr,
  sourcefile =   "themes/DISTENG/LUCMOREAU/report/diseng",
  ftpfile    =   "RR-3147",
  url =          "http://www.inria.fr/RRRT/RR-3147.html",
  abstract = "
Millions of computers are now connected together by the Internet.  At a fast
pace, applications are taking profit of these new capabilities, and become
parallel and distributed, e.g. applets on the WWW or agent technology.  As we
live in a world with finite resources, an important challenge is to be able to
control computations in such an environment.  For instance, a user might like
to suspend a computation because another one seems to be more promising.  In
this paper, we present a paradigm that allows the programmer to monitor and
control computations, whether parallel or distributed, by mastering their
resource consumption.
"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1997

@InProceedings{Queinnec97a,
  author =       {Christian Queinnec},
  title =        {S{\'e}rialisation--d{\'e}s{\'e}rialisation en {\dmeroon}},
  booktitle =    {NOTERE97 --- Colloque international sur les NOuvelles 
                  TEchnologies de la R{\'E}partition},
  editor =       {Omar Rafiq},
  year =      1997,
  publisher =    {{\'E}ditions TASC},
  isbn = {ISBN 2-9511875-0-5},
  url = {http://rerir.univ-pau.fr/NOTERE97/},
  address =   {Pau (France)},
  month =     nov,
  pages =        {333--346},
  sourcefile =   "themes/SERDES/serdes",
  ftpfile    =   "serdes",
  w3keyword  =   "NOTERE97",
  abstract = "
La transmission de valeurs entre m\'emoires s\'epar\'ees passe par une
s\'erialisation qui les transforme en un train d'octets puis par une
d\'es\'eria\-li\-sa\-tion qui retransforme ces octets en valeurs
\'equivalentes. Ces deux proc\'ed\'es sont g\'en\'eralement
con\c{c}us, \'ecrits et maintenus de concert: toute am\'elio\-ration
n\'ecessite de les faire \'evoluer tous deux. Nous proposons ici de
consid\'erer la s\'erialisation comme une compilation transformant une
valeur en un programme d\'elivr\'e, pour \'evaluation, \`a un
interpr\`ete de d\'es\'erialisation. Le protocole est alors d\'efini
comme le langage d'\'echange. La richesse de ce dernier fonde la
souplesse de ce premier puisqu'une large gamme de compilations
est possible selon les particularit\'es des valeurs \`a
transmettre. Nous relatons cette exp\'erience dans le cadre du
syst\`eme de m\'emoire partag\'ee r\'epartie {\dmeroon}.
"
}

@TechReport{Queinnec97b,
  author =       {Christian Queinnec},
  title =        {Le langage de commande Gibiane, 
                  Description informelle, 
                  Revision 1.23},
  institution =  {LIP6},
  year =         1997,
  type =         {Contrat CEA/SAV 24025/SAV, Rapport},
  number =       {LIP6/SPI/019},
  month =        jun,
  sourcefile =   "themes/CEA/gibact",
  ftpfile    =   "../Reports/gibact",
  url        =   "ftp://ftp.lip6.fr/reports/1997/lip6.1997.019.ps.gz",
  abstract = "
{\gibiane} est un langage invent\'e et utilis\'e depuis une quinzaine
d'ann\'ees par le Commissariat \`a l'\'Energie Atomique
(CEA). {\gibiane} permet la mise en {\oe}uvre de biblioth\`eques de
codes \'ecrits en Fortran, C, etc. Les points d'entr\'ee de ces
biblioth\`eques sont consid\'er\'es comme des op\'erateurs dont
l'enchainement est assur\'e, interactivement ou pas, par
\gibiane. Ce rapport technique (correspondant \`a la premi\`ere
\'etape du contrat CEA/SAV 24025/CH) d\'ecrit ce langage de commande.
"
}

@InProceedings{Queinnec97c,
  author =       {Luc Moreau and Christian Queinnec},
  title =        {Design and Semantics of Quantum: a Language to Control
                  Resource Consumption in Distributed Computing},
  booktitle =    {Usenix Conference on Domain Specific Language, DSL'97},
  year =      1997,
  address =   {Santa-Barbara (California, USA)},
  month =        oct,
  pages =        {183--197},
  sourcefile =   "themes/DISTENG",
  ftpfile =      "dsl97",
  url =          "http://www.ecs.soton.ac.uk/~{}lavm/Quantum/",
  w3keyword =    "DSL97",
  abstract =     "
This paper describes the semantics of \quantum, a language that was
specifically designed to control resource consumption of distributed
computations, such as mobile agent style applications.  In \quantum,
computations can be driven by mastering their resource consumption.
Resources can be understood as processors cycles, geographical
expansion, bandwidth or duration of communications, etc.  We adopt a
generic view by saying that computations need energy to be performed.
\quantum relies on three new primitives that deal with energy. The
first primitive creates a tank of energy associated with a
computation.  Asynchronous notifications inform the user of energy
exhaustion and computation termination.  The other two primitives
allow us to implement suspension and resumption of computations by
emptying a tank and by supplying more energy to a tank.  The semantics
takes the form of an abstract machine with explicit parallelism and
energy-related primitives."
}

@InProceedings{Queinnec97d,
  author =       {Luc Moreau and Christian Queinnec},
  title =        {Distributed Computations Driven by Resource Consumption},
  booktitle =    {ICCL 98 --- IEEE International Conference on 
                              Computer Languages},
  year =         1998,
  organization = {IEEE},
  address =      {Chicago (Illinois, USA)},
  month =        may,
  pages =        {68--77},
  isbn =         "0-8186-8454-2",
  ftpfile =      {iccl98},
  sourcefile =   {themes/DISTENG},
  w3keyword =    {ICCL98},
  abstract = "
Millions of computers are now connected together by the Internet.
At a fast pace, applications are taking advantage of these new capabilities,
and are becoming parallel and distributed, e.g. applets on the WWW or
agent technology. As we live in a world with finite resources, an important
challenge is to be able to control computations in such an environment. For 
instance, a user might like to suspend a computation because another one
seems to be more promising. In this paper, we present a paradigm that allows
the programmer to monitor and control computations, whether parallel or
distributed, by mastering their resource consumption. We describe an 
implementation on top of the thread library PPCR and the message-passing
library Nexus. "
}

@InProceedings{Queinnec97e,
  author =       {Christian Queinnec},
  title =        {Distributed Generic Functions},
  booktitle =    {Second France-Japan workshop on Object-Based Parallel 
                  and Distributed Computing --- OBPDC '97},
  editor =       {Jean-Paul Bahsoun and Takanobu Baba and Jean-Pierre Briot},
  year =      1997,
  address =   {Toulouse (France)},
  month =        oct,
  w3keyword =    "OBPDC97",
  sourcefile =   "themes/GENDIST",
  ftpfile =      "gendist",
  abstract = "
The network now gives the opportunity to combine code and data from
everywhere in the world. However, the dominant paradigm is the
client/server model where immotile objects with static interfaces can
only be used as prescribed on their proprietary site. While this
constraint corresponds to understandable industrial programming
practices, it negates the point of view of dynamic clients that
collect interesting objects and want to confer new behaviors to these
collected objects. To enrich objects ``from the outside'' that is,
without access to their source code thus without recompilation, is the
problem addressed in this paper.
"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1998

@Manual{Queinnec98a,
  title =        {{\dmeroon} A Distributed Class-based Causally-Coherent 
                  Data Model -- General documentation},
  author =       {Christian Queinnec},
  organization = {LIP6},
  year =         1998,
  note =         {Rapport LIP6 1998/039 
                  <http://www.lip6.fr/reports/lip6.1998.039.html>},
  abstract =     {
\dmeroon{} provides a data model above a coherently distributed shared
memory. \dmeroon{} allows multiple users to statically or dynamically
create new classes hierarchically organized, to dynamically
instantiate these classes and, to dynamically and coherently share the
resulting instances over a network. \dmeroon{} automatically takes
care of representation and alignment, marshaling and unmarshaling
objects, migrating and sharing objects, local and global garbage
collections.

This document describes \dmeroon{}, its philosophy of design, its
architecture and principles of implementation, and its bindings with
various languages. It also presents some applications above \dmeroon.
},
  ftpfile =      {../Reports/dmeroon},
  sourcefile =   {icslas/DMeroon/Doc/},
  url =          {http://www-spi.lip6.fr/~{}queinnec/WWW/DMeroon.html}
}

@TechReport{Queinnec98b,
  author =       {Christian Queinnec},
  title =        {Marshaling/Unmarshaling as a Compilation/Interpretation 
                  Process},
  institution =  {LIP6},
  year =         1998,
  type =         {Research Report},
  number =       {LIP6/1998/049},
  month =        dec,
  abstract =     {
Marshaling is the process through which structured values are
serialized into a stream of bytes; unmarshaling converts this stream
of bytes back to structured values. Most often, for a given data
structure, the marshaler and the unmarshaler are tightly related
pieces of code that are synthesized conjunctly. This paper proposes a
new point of view: the unmarshaler is considered as a byte-code
interpreter evaluating a stream of bytes considered as a program \ie{}
a sequence of commands interspersed with quoted raw data. This program
is an expression of the {\em marshaling language}. From that point of
view, the marshaler logically appears as a compiler translating values
into expressions of the marshaling language.
},
  ftpfile =      {marsh},
  programfile =  {Programs/DMeroon98Aug23.tar.gz},
  sourcefile =   {themes/SERDES/},
  url =          {http://www.lip6.fr/reports/lip6.1998.049.html},
  ftplip6 = {ftp://ftp.lip6.fr/lip6/reports/1998/lip6.1998.049.ps.gz}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1999

@InProceedings{Queinnec99a,
  author =       {Christian Queinnec},
  title =        {Marshaling/Unmarshaling as a Compilation/Interpretation 
                  Process},
  booktitle =    {Second Merged Symposium IPPS/SPDP 1999 -- 
                  13th International Parallel Processing Symposium \&
                  10th Symposium on Parallel and Distributed Processing},
  pages =        {616--621},
  year =         1999,
  address =      {San-Juan (Puerto-Rico USA)},
  month =        apr,
  organization = {IEEE},
  note =         {See detailed report \cite{Queinnec98b}},
  abstract =  {
Marshaling is the process through which structured values are
serialized into a stream of bytes; unmarshaling converts this stream
of bytes back to structured values. Most often, for a given data
structure, the marshaler and the unmarshaler are tightly related
pieces of code that are synthesized conjunctly. This paper proposes a
new point of view: the unmarshaler is considered as a byte-code
interpreter evaluating a stream of bytes considered as a program \ie{}
a sequence of commands interspersed with quoted raw data. This program
is an expression of the {\em marshaling language}. From that point of
view, the marshaler logically appears as a compiler translating values
into expressions of the marshaling language.
},
  ftpfile =     {marshort},
  programfile = {Programs/DMeroon98Aug23.tar.gz},
  sourcefile =  {themes/SERDES/},
  w3keyword =   {ISPP-SPDP99},
  url =         {http://www-spi.lip6.fr/~{}queinnec/WWW/DMeroon.html}
}

@Book{Queinnec99,
  author =       {Luc Moreau and Christian Queinnec 
                  and Daniel Ribbens and Manuel Serrano},
  title =        {Recueil de petits probl{\`e}mes en Scheme},
  publisher =    springer,
  series =       {Scopos},
  year =         1999,
  isbn =         {ISBN 3-540-66043-7},
  w3keyword =    {SCOPOS},
  url = {http://www.cmla.ens-cachan.fr/Utilisateurs/scopos/Moreau/index.html},
  coverpage =    {rdppes.png}
}

@InProceedings{Queinnec99b,
  author =       {Christian Queinnec and Luc Moreau},
  title =        {Graceful disconnection},
  booktitle =    {Parallel and Distributed Computing for 
                  Symbolic and Irregular Applications -- PDCSIA'99},
  pages =     {242--252},
  year =         1999,
  editor =    {Takayasu Ito and Taiichi Yuasa},
  address =   {Tohoku University, Sendai (Japan)},
  month =     jul,
  publisher = {World Scientific Publishing},
  abstract =  {
A distributed object system allows objects to be communicated from
site to site disregarding their physical locations.  Communicating
objects often leaves a trail homing to the site that owns the original
object. To shortcut these trails reduces the number of ``zombies''
\ie{} sites that are part of the trail but do not need the object for
themselves.  This paper proposes an algorithm that allows a site to
disconnect gracefully that is, without global network synchronization
and therefore quickly. This algorithm focuses on the proper treatment
of zombies.
},
  ftpfile =   {gradisc},
  w3keyword = {PDCSIA99},
  isbn = {981-02-4139-9}
}

ps3i doc, annote doc, sty doc, xscript doc ???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2000

@Unpublished{Queinnec2000a,
  author =       {Claire Cazes and Christian Queinnec and Chantal Steinberg},
  title =        {Enseignement du langage {C} {\`a} l'aide d'un 
                  c{\'e}d{\'e}rom et d'un site -- {M}ise en {\oe}uvre et 
                  observation},
  note =         {Troyes (France), Atelier TICE},
  month =     oct,
  year =      {2000},
  abstract =  {
Entre octobre 1999 et janvier 2000, dans le cadre de la licence d'informatique 
de l'universit Paris 6, a t mene une  exprience pdagogique consistant  
enseigner le langage C  l'aide d'un cdrom. Cet article prsente les 
objectifs viss lors de la conception de ce cdrom et du site associ, 
dcrit la mise en {\oe}uvre pratique de cet enseignement et analyse son 
impact sur les tudiants. Les rsultats montrent que les objectifs semblent 
globalement atteints, et de nouvelles pistes d'amliorations sont proposes 
en conclusion. Pourtant, les entretiens avec les tudiants font apparatre 
un certain nombre de paradoxes qui semblent caractriser une situation de 
travail personnel perturbe et qui n'a pas encore trouv un nouvel tat 
d'quilibre.
},
  ftpfile =   {tice2000a},
  sourcefile = {Cours/licence/UPI/},
  w3keyword = {TICE2000a},
  url =       {http://www.infop6.jussieu.fr/cederoms/Videoc2000/}
}

@InProceedings{Queinnec2000aa,
  author =       {Claire Cazes and Christian Queinnec and Chantal Steinberg},
  title =        {Enseignement du langage {C} {\`a} l'aide d'un 
                  c{\'e}d{\'e}rom et d'un site -- {M}ise en {\oe}uvre et 
                  observation},
  booktitle =    {Colloque international -- Technologie de l'Information 
                  et de la Communication dans les Enseignements d'ingnieurs 
                  et dans l'industrie -- TICE 2000},
  pages =        {63--63},
  address =         {Troyes (France)},
  month =     oct,
  year =      {2000},
  note =      {Version courte de \cite{Queinnec2000a}},
  abstract =  {
Entre octobre 1999 et janvier 2000, dans le cadre de la licence d'informatique 
de l'universit Paris 6, a t mene une  exprience pdagogique consistant  
enseigner le langage C  l'aide d'un cdrom. Cet article prsente les 
objectifs viss lors de la conception de ce cdrom et du site associ, 
dcrit la mise en {\oe}uvre pratique de cet enseignement et analyse son 
impact sur les tudiants. Les rsultats montrent que les objectifs semblent 
globalement atteints, et de nouvelles pistes d'amliorations sont proposes 
en conclusion. Pourtant, les entretiens avec les tudiants font apparatre 
un certain nombre de paradoxes qui semblent caractriser une situation de 
travail personnel perturbe et qui n'a pas encore trouv un nouvel tat 
d'quilibre.
}
}

@InProceedings{Queinnec2000b,
  author =       {Christian Queinnec},
  title =        {Enseignement du langage {C} {\`a} l'aide d'un 
                  c{\'e}d{\'e}rom et d'un site -- {A}rchitecture logicielle},
  booktitle =    {Colloque international -- Technologie de l'Information 
                  et de la Communication dans les Enseignements d'ingnieurs 
                  et dans l'industrie -- TICE 2000},
  pages =        {93--102},
  year =      2000,
  address =   {Troyes (France)},
  month =     oct,
  publisher =    {CNED},
  abstract =  {
Entre octobre 1999 et janvier 2000, dans le cadre de la licence
d'informatique de l'universit Paris 6, a t mene une exprience
pdagogique consistant  enseigner le langage C  l'aide d'un
cdrom. Cet article prsente l'architecture du logiciel mis en place
pour cette ralisation et principalement la notion de ~parcours~ qui
permet d'agencer des cheminements complexes et ractifs au sein d'une
base de d'informations dcoupes en pages.
},
  ftpfile =   {tice2000b},
  programfile = {VideoC/VideoCtools-99Oct26.tgz},
  sourcefile = {Cours/licence/UPI/},
  w3keyword = {TICE2000b},
  url =       {http://www.infop6.jussieu.fr/cederoms/Videoc2000/}
}

@InBook{Queinnec2000c,
  author =    {Christian Queinnec},
  editor =    {Pierre Cointe},
  title =        {Le{\c{c}}on de {CLOS}},
  chapter =      {?},
  publisher =    {Herm{\`e}s},
  year =         {2000},
  OPTkey =       {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  OPTtype =      {},
  OPTaddress =   {},
  OPTedition =   {},
  OPTmonth =     {},
  OPTpages =     {},
  note =      {Livre en pr{\'e}paration},
  OPTabstract =  {},
  OPTftpfile =   {},
  OPTprogramfile = {},
  OPTsourcefile = {themes/closchapter/clos},
  OPTw3keyword = {},
  OPTurl =       {},
  OPTcoverpage = {}
}

@InProceedings{Queinnec2000d,
  author =       {Christian Queinnec},
  title =        {The Influence of Browsers on Evaluators or,
                  Continuations to Program Web Servers},
  booktitle =    icfp2000,
  pages =        {23--33},
  year =      2000,
  address =   {Montreal (Canada)},
  month =     sep,
  abstract =  {
While developping the software of a browser-operated educational
CD-ROM, we had to face a number of problems. This paper presents these
problems and the solutions we found. Amusingly, most of our solutions
rely on continuations. Are browsers and multimedia the future of continuations ?
\par
Through their ``Back'' button or ``Clone window'' menu item, browsers
have powerful abilities that force servers to take care of multiply
and simultaneously answered questions. A comprehensive tool to
apprehend these problems as well as to solve them is to view these
abilities as operators acting on the continuations of the computation
performed by servers.
\par
Thematical trails are provided to walk through the CD-ROM but do not
prevent students to wander elsewhere. A trail may contain choices or
quizzes so the rest of the trail should adapt to the walked part. We
consider the trail as a computation and the position of the student as
a continuation within that computation.
\par
Moreover this paper advocates a computation-centric view of servers
(in opposition to the usual page-centric view) where interactions with
users suspend the computation into continuations that may be later
resumed. This approach is superior because the continuation reifies
automatically and without errors the whole state of the computation.
},
  ftpfile =   {webcont},
  programfile = {VideoC/VideoCtools-99Oct26.tgz},
  sourcefile = {themes/PS3I/},
  w3keyword = {ICFP2000},
  url =       {http://youpou.lip6.fr/queinnec/VideoC/ps3i.html}
}

@InProceedings{Queinnec2000e,
  author =       {Christian Queinnec},
  title =        {Distributed Generic Functions},
  booktitle =    {Object-Oriented Parallel and Distributed Programming},
  pages =        {135--150},
  year =         2000,
  editor =       {Jean-Paul Bahsoun and Takanobu Baba and Jean-Pierre Briot 
                  and Akinori Yonezawa},
  publisher =    {Hermes Science Publications},
  isbn =         {ISBN 2-7462-0091-0},
  note =         {Definitive version of \cite{Queinnec97e}},
  ftpfile =      {gendist},
  sourcefile =   {themes/GENDIST},
  abstract = "
The network now gives the opportunity to combine code and data from
everywhere in the world. However, the dominant paradigm is the
client/server model where immobile objects with static interfaces can
only be used as prescribed by their proprietary site. While this
constraint corresponds to understandable industrial programming
practices, it negates the point of view of dynamic clients that
collect interesting objects and want to confer new behaviors to these
collected objects. How to enrich objects ``from the outside'' that is,
without access to their source code hence without re-compilation of
their defining classes, is the problem addressed by this paper.
"
}

@InProceedings{Queinnec2000f,
  author =       {Christian Queinnec},
  title =        {Continuations and Conversations},
  booktitle =    {9th International Conference, AIMSA 2000 --
                  International Conference on Artificial Intelligence: 
                  Methodology, Systems, Applications},
  pages =        {363--363},
  year =         2000,
  editor =       {Stefano A Cerri and Danail Dochev},
  number =       1904,
  series =       {Lecture Notes in Artificial Intelligence},
  address =      {Varna (Bulgaria)},
  month =        sep,
  publisher =    springer
}

@TechReport{Queinnec2000h,
  author =       {Christian Queinnec},
  title =        {Inverting back the inversion of control or, 
                  Continuations versus page-centric programming},
  institution =  "LIP6",
  number =    7,
  month =     may,
  year =      2001,
  abstract =  "
Our thesis is that programming web applications with continuations is
superior to the current page-centric technology. A continuation is a
program-level manageable value representing the rest of the
computation of the program. ``What to do next'' is precisely what has
to be explicitly encoded in order to program non trivial web
interactions. Continuations allow web applications to be written in
direct style that is, as a single program that displays forms and
reads form submission since continuations automatically capture
everything (control point, lexical bindings, etc.) that is needed to
resume the computation. Programming is therefore safer, easier and
more re-usable. ",
  ftpfile =   {www},
  sourcefile = {themes/PS3I},
  url =       {http://www.lip6.fr/reports/lip6.2001.007.html},
  ftplip6 = {ftp://ftp.lip6.fr/lip6/reports/2001/lip6.2001.007.pdf}
}
% presente a France-Japan Workshop on Distributed Objects and Agents (DOA'2000)
% 4 and 5 December 2000, Maison Franco Japonaise - Nichi Futsu Kaikan, Tokyo
% Soumis a Sigplan Notices le 25 mars 2002.

@TechReport{Queinnec2000i,
  author =       {Christian Queinnec and H{\'e}l{\`e}ne Giroire},
  title =        {Pages dynamiques composes par filtrage 
                  Une mise en {\oe}uvre sur cdrom},
  institution =  "LIP6",
  number =    {6},
  month = may,
  year = 2001,
  abstract = "
Afin de s'adapter aux tudiants,  leur prfrences ou  ce qui, tout
simplement, semble appropri compte-tenu de l'enseignement qu'ils
suivent, une solution couramment prise est d'utiliser des pages
dynamiques (\emph{servlets} ou \emph{Java Server Pages}). Notre
propos est de montrer que ce choix peut tre utilement complt par
une mcanique de filtrage.
\par
Cette dmarche a t employe avec succs pour la ralisation d'un
cdrom, distribu en guise de polycopi lectronique accompagnant un
cours sur le langage C en licence d'informatique.
",
  ftpfile =   {filtre},
  sourcefile = {Cours/VideoC/Java/Documents},
  ftplip6 = {ftp://ftp.lip6.fr/lip6/reports/2001/lip6.2001.006.pdf}
}

@InProceedings{Queinnec2000ii,
  author =       {Christian Queinnec and H{\'e}l{\`e}ne Giroire},
  title =        {Pages dynamiques composes par filtrage 
                  Une mise en {\oe}uvre sur cdrom},
  booktitle =    {EIAO'2001 -- Environnements Interactifs d'Apprentissage 
                  avec Ordinateur},
  pages =        {190--191},
  year =      2001,
  editor =    {Cyrille Desmoulins and Monique Grandbastien and 
               Jean-Marc Labat},
  volume =       8,
  number =       {1-2},
  series =    {Sciences et Techniques {\'E}ducatives},
  address =   {Cit{\'e} des Sciences de La Villette, Paris (France)},
  month =     may,
  publisher = {Herms Science Publications},
  note =      {version longue en \cite{Queinnec2000i}},
  abstract =  {
Afin de s'adapter aux tudiants,  leur prfrences ou  ce qui, tout
simplement, semble appropri compte-tenu de l'enseignement qu'ils
suivent, une solution couramment prise est d'utiliser des pages
dynamiques (\emph{servlets} ou \emph{Java Server Pages}). Notre
propos est de montrer que ce choix peut tre utilement complt par
une mcanique de filtrage.
\par
Cette dmarche a t employe avec succs pour la ralisation d'un
cdrom, distribu en guise de polycopi lectronique accompagnant un
cours sur le langage C en licence d'informatique.
},
  ftpfile =      {filtre2},
  sourcefile = {Cours/VideoC/Java/Documents},
  w3keyword = {EIAO2001},
  url =       {http://youpou.lip6.fr/queinnec/filtre.ps.gz}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2001

@Misc{Queinnec2000siteDeug,
  author =       {Christian Queinnec},
  title =        {Site ou{\`e}be des DEUG},
  year =         2000,
  note = {cf. \verb+http://www.infop6.jussieu.fr/deug/+},
  url =          {http://www.infop6.jussieu.fr/deug/}
}

@Misc{Queinnec2000VideoC2000,
  author =       {Christian Queinnec},
  title =        {C{\'e}d{\'e}rom Videoc2000: enseignement de C en licence},
  year =         2000,
  note = {cf. \verb+http://www.infop6.jussieu.fr/cederoms/Videoc2000/+},
  url =          {http://www.infop6.jussieu.fr/cederoms/Videoc2000/}
}

@InBook{Queinnec2001a,
  author = 	 "Christian Queinnec",
  title = 	 "Langage C",
  chapter = 	 "H 3 068",
  publisher = 	 "Techniques de l'Ing{\'e}nieur, trait{\'e} Informatique",
  year = 	 2001,
  pages = 	 "1-15",
  address = 	 "Paris (France)"
}

@Unpublished{Queinnec2001b,
  author =       {Fr{\'e}d{\'e}ric Peschanski and Christian Queinnec 
                  and Jean-Pierre Briot},
  title =        {A Typeful Composition Model for Dynamic Software 
                  Architectures},
  note =         {Soon as a TR},
  month =     jul,
  year =      2001,
  abstract =  {
Future generations of software systems should be able to evolve
consistently while they are running. To address this problem, we
propose a model and a domain-specific language, named Scope, that
offers the dynamic composition of component-based software
architectures. The basic constitutive operation available is the
establishment of a connection between two given
composnents. Interconnected components can exchange information in the
form of anonymous event emissions. Event types are used in our work
both to capture programmer's intentions at the conceptual level and to
ensure type safety at the operational level. A type inference
algorithm maps these two levels. Compositions can be flat or
recursive, the result being an architecture or a composite
component. Language-level extensions are proposed through type
confinement, connection labelling and component refinement.
},
  ftpfile =   {scope-report2001}
}

% Liban

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2002

@Misc{Queinnec2001siteLicence,
  author =       {Christian Queinnec},
  title =        {Site ou{\`e}be de la licence d'informatique},
  year =         2001,
  note = {cf. \verb+http://www.infop6.jussieu.fr/licence/+},
  url =          {http://www.infop6.jussieu.fr/licence/}
}

@Misc{Queinnec2001VideoScm,
  author =       {Christian Queinnec},
  title =        {C{\'e}d{\'e}rom VideoScm 2001 --- SPAD},
  year =         2001,
  note = {cf. \verb+http://www.infop6.jussieu.fr/cederoms/VideoScm2001/+},
  url =          {http://www.infop6.jussieu.fr/cederoms/VideoScm2001/}
}

@InProceedings{Queinnec2002a,
  author =       {Anne Brygoo and Titou Durand and Pascal Manoury and
                  Christian Queinnec and Mich{\`e}le Soria},
  title =        {Experiment around a training engine},
  booktitle =    {IFIP WCC 2002 -- World Computer Congress},
  OPTcrossref =  {},
  OPTkey =       {},
  OPTpages =     {},
  year =      {2002},
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Montreal (Canada)},
  month =     aug,
  organization = {IFIP},
  OPTpublisher = {},
  OPTnote =      {},
  abstract =     {
We describe a teaching experiment where an introductory course to
Computer Science is accompanied by a computerized training
engine. This whole engine relies on the existence of an interpreter of
the taught programming language that allows us to offer quizzes as
well as exercises with some automatic marking facility. Students may
then perform their homework with an immediate feedback without being
connected to the Internet. However students' answers are eventually
gathered in a central database where they may be analyzed thus
providing the means for ``personal coaching''.
},
  ftpfile =   {shortifip2002},
  OPTprogramfile = {},
  sourcefile = {Cours/VideoScm/Papers/ifip2002},
  OPTw3keyword = {IFIP2002},
  OPTurl =       {},
  OPTcoverpage = {}
}

@Unpublished{Queinnec2002aa,
  author =       {Anne Brygoo and Titou Durand and Pascal Manoury and
                  Christian Queinnec and Mich{\`e}le Soria},
  title =        {Experiment around a training engine},
  note =         {Complete version of \cite{Queinnec2002a}},
  OPTkey =       {},
  month =     oct,
  year =      {2002},
  OPTabstract =  {},
  ftpfile =   {ifip2002},
  OPTprogramfile = {},
  sourcefile = {Cours/VideoScm/Papers/ifip2002},
  w3keyword = {IFIP2002},
  OPTurl =       {},
  OPTcoverpage = {}
}

@InProceedings{Queinnec2002b,
  author =       {Anne Brygoo and Titou Durand and Pascal Manoury and
                  Christian Queinnec and Mich{\`e}le Soria},
  title =        {Un cdrom pour Scheme ---
                  Chacun son entraineur, un entraineur pour tous},
  booktitle =    {TICE 2002},
  OPTcrossref =  {},
  OPTkey =       {},
  OPTpages =     {},
  year =      {2002},
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Lyon (France)},
  month =     nov,
  OPTorganization = {},
  OPTpublisher = {},
  OPTnote =      {},
  abstract =  {
 la rentre 2001, un enseignement semi-prsentiel d'informatique en
DEUG MIAS a t mis en place  l'universit Pierre et Marie Curie
(Paris 6). Le support principal de cet enseignement fut un cdrom
permettant aux tudiants de s'entrainer chez eux par le biais
d'auto-valuations et d'exercices instantanment apprcis par le
systme hors connexion Internet.  Cet article prsente cette
exprience et ses rsultats.
},
  ftpfile =   {tice2002},
  OPTprogramfile = {},
  sourcefile = {Cours/VideoScm/Papers/tice2002},
  OPTw3keyword = {},
  OPTurl =       {}
}

@InProceedings{Queinnec2002ca,
  author =       {Christian Queinnec and Emmanuel Chailloux},
  title =        {Une exprience de notation en masse},
  OPTcrossref =  {},
  OPTkey =       {},
  booktitle = {atelier TICE 2002},
  OPTpages =     {},
  year =      {2002},
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Lyon (France)},
  month =     nov,
  OPTorganization = {},
  OPTpublisher = {},
  note =      {version complte disponible en 
   \texttt{http://www.infop6.jussieu.fr/licence/2001/cct/cfsreport.ps.gz}},
  abstract =  {
Une exprience d'examen d'informatique mene sur ordinateur et
assortie d'une notation automatique (1800 copies environ) est dcrite
dans cet article. L'laboration des sujets, le processus de notation
et l'architecture logicielle de notation ainsi que les techniques
d'affichage des notes et de consultation des copies corriges sont
tour  tour exposes et commentes.
},
  ftpfile =   {cfsreport},
  OPTprogramfile = {},
  sourcefile = {Cours/Licence/CFS/Papers/cfsreport},
  OPTw3keyword = {},
  url =       {http://www.infop6.jussieu.fr/licence/2001/cct/},
  OPTcoverpage = {}
}

@InProceedings{Queinnec2002d,
  author =       {Luc Moreau and Christian Queinnec},
  title =        {Distributed and Multi-Type Resource Management},
  booktitle =    {ECOOP'02 Workshop on Resource Management for Safe Languages},
  OPTcrossref =  {},
  OPTkey =       {},
  OPTpages =     {},
  year =      {2002},
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Malaga, Spain},
  month =     jun,
  OPTorganization = {},
  OPTpublisher = {},
  OPTnote =      {},
  abstract =  {
The authors have previously defined Quantum, a framework for managing
resources, which can be used by both providers and consumers of resources to
express and program resource-related operations.
In this paper, we extend this framework to the distributed setting by
introducing distribution-specific operations, and we generalise the framework
to support multiple types of resources.
},
  ftpfile =   {dres},
  OPTprogramfile = {},
  sourcefile = {themes/DISTENG/dres},
  OPTw3keyword = {},
  OPTurl =       {http://www.ecs.soton.ac.uk/~lavm/papers/dres.pdf},
  OPTcoverpage = {}
}

@InProceedings{Queinnec2002e,
  author =       {Christian Queinnec},
  title =        {A library for quizzes},
  OPTcrossref =  {},
  OPTkey =       {},
  booktitle = {Scheme Workshop 2002},
  OPTpages =     {},
  year =      {2002},
  editor =    {Olin Shivers},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Pittsburgh (Pennsylvania, USA)},
  month =     oct,
  OPTorganization = {},
  OPTpublisher = {},
  note =      {accepted to the Scheme workshop},
  abstract =  {
Programming web dialogs is already known to be well served by
continuations; this paper presents a continuation-based library for a
particular class of web dialogs: quizzes for students. The library is
made of objects representing the individual questions and of
functional combinators hiding the imperative aspects of
page shipping over HTTP and management of continuations.  Mixing these
three styles provide an elegant framework that fulfills our initial
goal. The description of that library is hoped to be helpful for
quizzes designers.
},
  ftpfile =   {qcm},
  OPTprogramfile = {},
  OPTsourcefile = {Cours/VideoScm/Papers/schemews2002/qcm},
  OPTw3keyword = {},
  OPTurl =       {},
  OPTcoverpage = {}
}

@InProceedings{Queinnec2002f,
  author =       {Christian Queinnec},
  title =        {Modules in Scheme},
  OPTcrossref =  {},
  OPTkey =       {},
  booktitle = {Scheme Workshop 2002},
  OPTpages =     {},
  year =      {2002},
  editor =    {Olin Shivers},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  address =   {Pittsburgh (Pennsylvania, USA)},
  month =     oct,
  OPTorganization = {},
  OPTpublisher = {},
  note =      {Invited talk at the Scheme workshop},
  abstract =  {
The benefits of modularization are well known. However, modules are
not standard in Scheme. This paper accompanies an invited talk at the
Scheme Workshop 2002 on the current state of modules for
Scheme. Implementation is not addressed, only linguistic features are
covered.
},
  ftpfile =   {sws},
  programfile = {sws-2002Aug18.tgz.tgz},
  sourcefile = {themes/SCHEMEWS2002/sws},
  OPTw3keyword = {},
  OPTurl =       {},
  OPTcoverpage = {}
}

end of qnc.bib
