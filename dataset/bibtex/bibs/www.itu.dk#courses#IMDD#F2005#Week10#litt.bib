%%% -*-BibTeX-*-
%%% ====================================================================
%%%  BibTeX-file{
%%%     author          = "Mikkel Bundgaard",
%%%     version         = "0.15",
%%%     date            = "05 January 2004",
%%%     time            = "09:54:46 CEST",
%%%     filename        = "litt.bib",
%%%     address         = "The IT University of Copenhagen,
%%%                        Glentevej 67,
%%%                        DK-2400 Copenhagen NV,
%%%                        Denmark",
%%%     telephone       = "XXXXXXX",
%%%     FAX             = "XXXXXXX",
%%%     URL             = "http://www.itu.dk/people/mikkelbu/",
%%%     email           = "mikkelbu -at- itu -dot- dk",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "bibliography, BibTeX, higher order,
%%%                        mobile resources, read material",
%%%     supported       = "yes",
%%%     docstring       = "This is a bibliography of publications on
%%%                        case-based reasoning (CBR) and related
%%%                        fields, in particular publications from
%%%                        project FABEL of GMD German National Research
%%%                        Center for Information Technology (main
%%%                        contractor),
%%% }
%%% ====================================================================


% HAR ALLE PROCEEDINGS EDITORS ????
% HVAD MED SERIES ???
% TILFØJ PLACERING AF DOKUMENTER
% TODO: All abbreviation enclosed in {} like ({POPL}'96)
% SKAL DER STÅR JOURNAL FORAN ALLE JOURNALS
% Make Proceedings more similar
% Skal International og Conference skrives med stort ???? i proceedings

%%----------------------------------------------------------------------
%% Journal abbreviations:

@String{j-INFO-COMP             = "Journal of Information and Computation"}
%@String{j-PROC-IEEE             = "Proceedings of the IEEE"}
@String{j-ACTA-INFORM           = "Acta Informatica"}
@String{j-THEO-CS               = "Theoretical Computer Science"}
@String{j-FUNC-PROG             = "Journal of Functional Programming"}
@String{j-ACM                   = "Journal of the ACM"}
@String{j-CACM                  = "Communications of the ACM"}
@String{j-CSUR                  = "ACM Computing Surveys"}
@String{j-MAT-STRUCT            = "Journal of Mathematical Structures in Computer Science"}
@String{j-NOR-COMP              = "Nordic Journal of Computing"}

%%----------------------------------------------------------------------
%% Publishers and their addresses:
@String{pub-ACM                 = "ACM Press"}
@String{pub-ACM:adr             = "New York, NY 10036, USA"}
@String{pub-AP                  = "Academic Press"}
@String{pub-AP:adr              = "New York, USA"}
@String{pub-AW                  = "Addison-Wesley"}
@String{pub-AW:adr              = "Reading, MA, USA"}
@String{pub-CRC                 = "CRC Press"}
@String{pub-CUP                 = "Cambridge University Press"}
@String{pub-CUP:adr             = "Cambridge, UK"}
@String{pub-OUP                 = "Oxford University Press"}
@String{pub-ELS                 = "Elsevier"}
@String{pub-ELS:adr             = "Amsterdam, The Netherlands"}
@String{pub-ESP                 = "Elsevier Science Publishers B.V."}
@String{pub-ESP:adr             = "Amsterdam, The Netherlands"}
@String{pub-IOS                 = "IOS Press"}
@String{pub-IEEE                = "IEEE Computer Society Press"}
@String{pub-IEEE:adr            = "1109 Spring Street, Suite 300, Silver
                                   Spring, MD 20910, USA"}
@String{pub-KLUWER              = "Kluwer Academic Publishers"}
@String{pub-KLUWER:adr          = "Dordrecht, The Netherlands"}
@String{pub-MORGAN-KAUF         = "Morgan Kaufmann Publishers"}
@String{pub-MIT                 = "MIT Press"}
@String{pub-MCGRAW-HILL         = "Mc{\-}Graw-Hill"}
@String{pub-MCGRAW-HILL:adr     = "New York, NY, USA"}
@String{pub-NH                  = "North-Holland Publishing Co."}
@String{pub-NH:adr              = "Amsterdam, The Netherlands"}
@String{pub-PEARSON             = "Pearson Education"}
@String{pub-PH                  = "Prentice-Hall"}
@String{pub-PH:adr              = "Englewood Cliffs, NJ 07632, USA"}
@String{pub-SV                  = "Springer Verlag"}
@String{pub-SV:adr              = "Berlin, Germany~/ Heidelberg, Germany~/
                                   London, UK~/ etc."}
@String{pub-WILEY               = "John Wiley and Sons"}
@String{pub-WILEY:adr           = "New York, NY, USA; London, UK; Sydney,
                                    Australia"}
@String{pub-WROX                = "Wrox Press Ltd"}

%%----------------------------------------------------------------------
%% Series abbreviations:
@String{ser-LNCS                = "Lecture Notes in Computer Science"}
@String{ser-ENTCS               = "Electronic Notes in Theoretical Computer Science"}
@String{ser-NATO                = "NATO Science Series"}
@String{ser-SERS-f              = "Science Institutes Series SERS F"}
@String{ser-FOUND-COMP          = "Foundations of Computing Series"}

%%----------------------------------------------------------------------
%% Universities and Institutions

@string{uni-BRICS               = "{BRICS}"}
@string{addr-daimi              = "Department of Computer Science, University of Aarhus"}
@String{uni-CAM:cl              = "University of Cambridge, Computer Laboratory"}


%%----------------------------------------------------------------------


%% Bibliography entries:

@Unpublished{Castagna:03:SealCalc,
  author = 	 {Castagna, Giuseppe and Vitek, Jan and Nardelli, Fracesco Zappa},
  title = 	 {The {S}eal Calculus},
  note = 	 {Unpublished manuscript},
  year = 	 2003,
  annote = 	 {},
  folder =    "Calculi 2"
}

@InCollection{Vitek:99:SealFrameworkSecMobComp,
  author =       "Vitek, Jan and Castagna, Giuseppe",
  title =        "{S}eal: {A} Framework for Secure Mobile Computations",
  booktitle =    "Internet Programming Languages",
  pages =        {47--77},
  publisher =    pub-SV,
  year =         1999,
  OPTeditor =    {},
  number =       1686,
  series =       ser-LNCS,
  abstract = "The Seal calculus is a distributed process calculus with
             localities and mobility of computational entities called
             seals. Seal is also a framework for writing secure
             distributed applications over large scale open networks
             such as the Internet.  This paper motivates our design
             choices, presents the syntax and reduction semantics of
             the calculus, and demonstrates its expressiveness by
             examples focused on security and management distributed
             systems.",
  url = "citeseer.ist.psu.edu/vitek99seal.html",
  annote =    {},
  folder =    "Calculi 1"
}

@Article{Milner:92:CalcMobileProcess,
  author = 	 {Milner, Robin and Parrow, Joachim and Walker, David},
  title = 	 {A Calculus of Mobile Processes, Parts {I} and {II}},
  journal = 	 j-INFO-COMP,
  year = 	 1992,
  volume = 	 100,
  pages = 	 {1--40 and 41--77},
  abstract = "We present the pi-calculus, a calculus of communicating
             systems in which one can naturally express processes
             which have changing structure. Not only may the component
             agents of a system be arbitrarily linked, but a
             communication between neighbours may carry information
             which changes that linkage. The calculus is an extension
             of the process algebra CCS, following work by Engberg and
             Nielsen who added mobility to CCS while preserving its
             algebraic properties. The pi-calculus gains simplicity by
             removing all distinction between variables and constants;
             communication links are identified by names, and
             computation is represented purely as the communication of
             names across links.

             After an illustrated description of how the pi-calculus
             generalises conventional process algebras in treating
             mobility, several examples exploiting mobility are given
             in some detail. The important examples are the encoding
             into the pi-calculus of higher-order functions (the
             lambda-calculus and combinatory algebra), the
             transmission of processes as values, and the
             representation of data structures as processes.

             The paper continues by presenting the algebraic theory of
             strong bisimilarity and strong equivalence, including a
             new notion of equivalence indexed by distinctions --
             i.e. assumptions of inequality among names. These
             theories are based upon a semantics in terms of a
             labelled transition system and a notion of strong
             bisimulation, both of which are expounded in detail in a
             companion paper. We also report briefly on
             work-in-progress based upon the corresponding notion of
             weak bisimulation, in which internal actions cannot be
             observed.",
  annote = {Proof of congruence for $\sim_D$ over parallel
              composition. Bisimulation up-to restriction.},
  folder =    "Calculi 1"
}

@Book{dataontheweb:99,
  author = 	 "Abiteboul, S. and Buneman, P. and Suciu, D.",
  title = 	 "Data on the Web: From Relations to Semistructured Data and XML",
  publisher = 	"Morgan Kaufmann",
  year = 	 1999
}

@Book{Milner:80:CalcuCommSyst,
  author = 	 "Milner, Robin",
  title = 	 "A Calculus of Communicating Systems",
  publisher = 	 pub-SV,
  year = 	 1980,
  series = 	 ser-LNCS,
  volume = 	 92,
  OPTedition = 	 {},
  annote = 	 {}
}


@InCollection{Pitts:97:OperBaTheoProgEqui,
  author = 	 {Pitts, Andrew M.},
  title = 	 "Operationally-Based Theories of Program Equivalence",
  booktitle = 	 "Semantics and Logics of Computation",
  pages = 	 {241--298},
  publisher =    pub-CUP,
  year = 	 1997,
  editor = 	 {Dybjer, Peter and Pitts, Andrew M.},
  OPTtype = 	 {},
  OPTchapter = 	 {},
  annote = 	 "The article describes mathematical methods for verifying 
                  properties of programs in higher-order, functional 
                  languages",
  url =          "citeseer.ist.psu.edu/113777.html",
  folder =    "Div 2",
}
   
@Book{Pitts:02:LecNotesSemProgLang,
  author = 	 {Pitts, Andrew M.},
  title = 	 {Lecture Notes on Semantics of Programming Languages},
  publisher = 	 uni-CAM:cl,
  year = 	 2002,
  annote =    "",
  folder =    "Div 1"
}

@Book{Pitts:99:LecNotesSemProgLang,
  author = 	 {Pitts, Andrew M.},
  title = 	 {Lecture Notes on Denotational Semantics},
  publisher = 	 uni-CAM:cl,
  year = 	 1999,
  annote =    "",
  folder =    "Div 1"
}

@Article{Pitts:94:CoinductivePrincipRecursivDefDoms,
  author =       "Pitts, Andrew M.",
  title =        "A Co-induction Principle for Recursively Defined
                 Domains",
  journal =      j-THEO-CS,
  volume =       124,
  number =       2,
  year =         1994,
  pages =        "195--219",
  note =         "(A preliminary version of this work appeared as
                 Cambridge Univ. Computer Laboratory Tech. Rept.
                 No.~252, April 1992.)",
  abstract =     "This paper establishes a new property of predomains
                 recursively defined using the cartesian product,
                 disjoint union, partial function space and convex
                 powerdomain constructors. We prove that the partial
                 order on such a recursive predomain $D$ is the greatest
                 fixed point of a certain monotone operator associated
                 to $D$. This provides a structurally defined family of
                 proof principles for these recursive predomains: to
                 show that one element of $D$ approximates another, it
                 suffices to find a binary relation containing the two
                 elements that is a post-fixed point for the associated
                 monotone operator. The statement of the proof
                 principles is independent of any of the various methods
                 available for explicit construction of recursive
                 predomains. Following Milner and Tofte, the method of
                 proof is called {\em co-induction}. It closely
                 resembles the way bisimulations are used in concurrent
                 process calculi.

                 Two specific instances of the co-induction principle
                 already occur in work of Abramsky in the form of
                 `internal full abstraction' theorems for denotational
                 semantics of SCCS and the lazy lambda calculus. In
                 the first case post-fixed binary relations are
                 precisely Abramsky's {\em partial bisimulations},
                 whereas in the second case they are his {\em
                 applicative bisimulations}. The co-induction
                 principle also provides an apparently useful tool for
                 reasoning about equality of elements of recursively
                 defined datatypes in (strict or lazy) higher order
                 functional programming languages.",
  folder =    "Div 1"
}


@Article{Crole:01:CompletBisimContextEquivLinearTheo, 
  title =        {Completeness of Bisimilarity for Contextual Equivalence in Linear Theories}, 
  author =       {Crole, Roy L.}, 
  pages =        {27--51}, 
  volume =       9, 
  number =       1, 
  year =         2001, 
  journal =      {Logic Journal of the IGPL}, 
  abstract = "In this paper, we develop new variations of methods from
              operational semantics, and show how to apply these to a
              linear type theory which has a \emph{lazy} operational
              semantics. In particular, we consider how one can
              establish contextual equivalences in a linear theory
              with function types and tensor types by instead
              establishing bisimulations. Thus bisimilarity is sound
              for contextual equivalence. Further, we show that
              bisimilarity is complete for contextual equivalence. We
              shall show that the notion of a program context in the
              linear setting is non-trivial. In particular, we give a
              definition of linear context which is amenable to
              mechanization in a theorem prover, and explain why a
              more naive approach to dealing with linear contexts
              would not be so tractable. The central contributions of
              the paper are: the formulation, in a linear setting, of
              a good notion of program context and the associated
              contextual equivalence; an adaptation of Howe's method;
              the notion of a linear precongruence; and a proof that
              bisimilarity is sound and complete for contextual
              equivalence.",
  folder = "Div 1"
}

@inproceedings{Gordon:95:TutorialCoInducFuncProg,
    author =     "Gordon, Andrew D.",
    title =      "A Tutorial on Co-induction and Functional Programming",
    booktitle =  "Proceedings of the 7th {G}lasgow Workshop on Functional Programming",
    publisher =  "Springer Workshops in Computing",
    pages =      "78--95",
    year =       1995,
    url =        "citeseer.nj.nec.com/gordon94tutorial.html",
    abstrct = "This tutorial explains the foundations of co-induction, 
               and shows how it justifies intuitive arguments about lazy 
               streams. We explain from first principles a theory based 
               on a new formulation of bisimilarity for functional programs, 
               which coincides exactly with Morris-style contextual 
               equivalence.",
    annotate = "Co-induction, bisimulation, contextual equivalence, 
                Take Lemma, Howe's method, fixpoint" 
}

@InProceedings{Sands:91:OperatTheoImproFuncLangExtAbs,
  author =       "Sands, David",
  title =        "Operational Theories of Improvement in Functional
                 Languages (Extended Abstract)",
  booktitle =    "Proceedings of the Fourth {G}lasgow Workshop on
                 Functional Programming",
  year =         1991,
  publisher =    "{S}pringer Workshop Series",
  OPTaddress =      "Skye",
  pages =        "298--311",
  OPTmonth =        aug,
  annotate =     "",
  folder =    "Div 1"
}




@inproceedings{Howe:89:EqualityLazyComp,
    author = "Howe, Douglas J.",
    title = "Equality in Lazy Computation Systems",
    booktitle = "Proceedings of the 4th {IEEE} Symposium on Logic in Computer Science (LICS'89)",
    OPTmonth = "June",
    publisher = pub-IEEE,
    pages = "198--203",
    year = 1989,
    abstract = "In this paper we introduce a general class of lazy
               computation systems and define a natural program
               equivalence for them. We prove that if an
               extensionality condition holds of each of the operators
               of a computation system, then the equivalence relation
               is a congruence, so that the usual kinds of equality
               reasoning are valid for it. This condition is a simple
               syntactic one, and is easy to verify for the various
               lazy computation system we have considered so far. We
               also give conditions under which the equivalence
               coincides with observational congruence. These results
               have some important consequences for type theories like
               those of Martin-L{\"o}f and Nuprl.",
    folder = "Div 1",
    url = "citeseer.nj.nec.com/howe89equality.html" 
}


@Article{Howe:96:ProvingCongBisimFunctProgLang,
  title =        "Proving Congruence of Bisimulation in Functional
                 Programming Languages",
  author =       "Howe, Douglas J.",
  pages =        "103--112",
  journal =      j-INFO-COMP,
  OPTmonth =        "1~" # feb,
  year =         1996,
  volume =       124,
  number =       2,
  abstract =     "We give a method for proving congruence of
                 bisimulation-like equivalences in functional
                 programming languages. The method applies to languages
                 that can be presented as a set of expressions together
                 with an evaluation relation. We use this method to show
                 that some generalizations of Abramsky's applicative
                 bisimulation are congruences whenever evaluation can be
                 specified by a certain natural form of structured
                 operational semantics. One of the generalizations
                 handles nondeterminism and diverging computations.",
  annote = 	 {},
  folder =    "Div 1"
}


@TechReport{Gordon:95:BisimTheoFuncProg,
  author = 	 "Gordon, Andrew D.",
  title = 	 "Bisimilarity as a Theory of Functional Programming. {M}ini-Course",
  institution =  uni-BRICS,
  year = 	 1995,
  type = 	 "Notes Series",
  number = 	 "NS-95-3",
  address = 	 addr-daimi,
  abstract = 	 "Operational intuition is central to computer
                  science. These notes introduce functional
                  programmers to operational semantics and
                  operational equivalence. We show how the idea
                  of bisimilarity from CCS may be applied to
                  deterministic functional languages. On
                  elementary operational grounds it justifies
                  equational reasoning and proofs about infinite
                  streams.",
  note = 	 "Extended version of MFPS'95 and Glasgow FP'94 papers",
  annote = 	 {},
  url =       "http://www.brics.dk/NS/95/3/BRICS-NS-95-3.ps.gz",
  folder =    "Div 1"
}

@TechReport{Baldamus:95:CongProofWeak,
  author = 	 {Baldamus, Michael and Frauenstein, Thomas},
  title = 	 "Congruence Proofs for Weak Bisimulation Equivalences on Higher-order Process Calculi",
  institution =  {Berlin University of Technology, Computer Science Department},
  year = 	 1995,
  OPTtype = 	 {},
  number = 	 {Report 95--21},
  OPTaddress = 	 {},
  annote = 	 {},
  abstract = "Congruence proofs for bisimulation equivalences on
             higher-order process calculi tend to be significantly
             more complex than their counterparts in first-order
             process algebra frameworks. The fact that higher-order
             synchronization invokes substitution seems to be the main
             problem. The reason is that it renders standard
             first-order proof techniques circular in the higher-order
             case, and this situation is difficult to deal
             with. Moreover, some techniques that allow us to cover
             strong forms of bisimulation equivalence on higher-order
             calculi seem to fail for the corresponding weak forms.

             Applicative simulation equivalence on lambda-calculi
             poses similar problems and our starting point is that
             Howe has invented a general and elegant technique for
             solving them. Our contribution is that we use Howe-style
             techniques to prove that three forms of weak bisimulation
             equivalence on variants of Thomsen's Plain CHOCS and
             CHOCS second-order process calculi are congruences. In
             the Plain CHOCS case we treat late weak context
             equivalence; in the CHOCS case we treat late and a minor
             variant of early weak higher-order equivalences.",
  url =       "http://uebb.cs.tu-berlin.de/~thofra/papers/TR95-21-tf.ps.gz",
  folder =    "Calculi 1"
}

@Book{Hennessy:90:SemanProgLang,
  author =       "Hennessy, Matthew",
  title =        "The Semantics of Programming Languages: An Elementary
                 Introduction using Structural Operational Semantics",
  publisher =    pub-WILEY,
  year =         1990,
  annote =       "Revised version of selected chapters of the original.
                  Some good examples in structural induction. Induction on
                  the size of the expressions. Proof of several
                  statements simultaneously. Rule induction.",
  folder =    "Books + Theses 2"
}


@incollection{Cardelli:97:TypeSyst,
    author =     "Cardelli, Luca",
    title =      "Type Systems",
    booktitle =  "The Computer Science and Engineering Handbook",
    pages =      "2208--2236",
    publisher =  pub-CRC,
    OPTaddress = "Boca Raton, FL",
    editor =     "Tucker, Allen B.",
    year =       1997,
    chapter = 	 103,
    abstract = "The purpose of a type system is to prevent the
               occurrence of execution errors during the running of a
               program. The accuracy of this informal statement
               depends on the rather subtle issue of what constitutes
               an execution error. Even when that is settled, the type
               soundness of a programming language (the absence of
               certain execution errors in all program runs) is a
               non-trivial property. A fair amount of careful analysis
               is required to avoid false and embarrassing claims of
               type soundness; as a consequence, the classification,
               description, and study of type systems has emerged as a
               formal discipline. This chapter describes the purpose,
               technology, and outlook of type systems for programming
               languages.",
    annote = "Introduction to type systems and their nomenclature, a
              general framework for formalizing type systems,
              description of many constructions (within $F_1$, $F_2$,
              and $F_{2<:}$), and simple type inference algorithms.",
    url = "citeseer.nj.nec.com/cardelli97type.html",
    folder = "Div 1"
}

@incollection{Pierce:97:FoundCalProgLang,
    author = "Pierce, Benjamin C.",
    title = "Foundational Calculi for Programming Languages",
    booktitle = "The Computer Science and Engineering Handbook",
    pages = "2190--2207",
    publisher = pub-CRC,
    OPTaddress = "Boca Raton, FL",
    editor = "Tucker, Allen B.",
    year = 1997,
    chapter = 139,
    annote = "General introduction to the lambda-calculus as a
             canonical model of purely function
             computation. Introduction to the syntax, semantics,
             nomenclature, combinators, Church Numerals, normal form,
             divergence, confluence, the Church-Rosser
             Theorem. Discussion of contextual equivalence,
             applicative bisimulation. Introduction to Pi-Calculus as
             a model for concurrent systems. Nonconfluence, and
             research areas within process algebra.",
    url = "http://citeseer.nj.nec.com/pierce95foundational.html",
    folder = "Div 1"
}

%%% Papers from the course "Behavioral Type Systems and Model Checking" 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@inproceedings{Kobayashi:96:LinearityPi,
    author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
    title = {Linearity and the Pi-Calculus},
    booktitle = {Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'96)},
    year = 1996,
    isbn = {0-89791-769-3},
    pages = {358--371},
    location = {St. Petersburg Beach, Florida, United States},
    doi = {http://doi.acm.org/10.1145/237721.237804},
    publisher = pub-ACM,
    annote = "A linear type system for a asynchronous fragment of the 
              polyadic $\pi$-calculus. The type system guarantees that 
              communication over a linear channel cannot interfere with 
              other communicating processes. Examples on how linear 
              types helps in proving behavioral equivalence. Proof of 
              'Subject Reduction' and 'Partial confluence'. Strong/weak 
              barbed congruence are also presented.",
    folder = "Courses 1"
 }

@Unpublished{Kobayashi:02:TypeSysConcurProg,
    author = 	 {Kobayashi, Naoki},
    title = 	 {Type Systems for Concurrent Programs},
    note = 	 {To appear in {\em Proceedings of UNU/IIST 10th Anniversary Colloquium}},
    year = 	 2002,
    annote =	 "A simple type system for a variant of the 
                  $\pi$-calculus. The simple type system only differs 
                  between boolean and channels and checks the arity of 
                  the channels. The type system is first extended with 
                  input/output modes, linear types. Thereafter it is 
                  extended with channel usage which contains information 
                  about in which order channels are used for input and 
                  output. Lastly through a kind of time tags we obtain 
                  a type system for deadlock-freedom.",
    folder = "Courses 1 + Edinburgh 03"
}

@inproceedings{Igarashi:01:GenericTypeSysPiCalc,
    author    = {Igarashi, Atsushi and Kobayashi, Naoki},
    title     = {A Generic Type System for the Pi-Calculus},
    booktitle = {Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'01)},
    year      = 2001,
    isbn      = {1-58113-336-7},
    pages     = {128--141},
    location  = {London, United Kingdom},
    doi       = {http://doi.acm.org/10.1145/360204.360215},
    publisher = pub-ACM,
    abstract  = "We propose a general, powerful framework of type 
                 systems for the $\pi$-caiculus, and show that we can 
                 obtain as its instances a variety of type systems 
                 guaranteeing non-trivial properties like deadlock-freedom 
                 and race-freedom. A key idea is to express types and 
                 type environments as abstract processes: We can check 
                 various properties of a process by checking the 
                 corresponding properties of its type environment. The 
                 framework clarifies the essence of recent complex type 
                 systems, and it also enables sharing of a large amount 
                 of work such as a proof of type preservation, making it 
                 easy to develop new type systems.",
    folder = "Courses 1"
}



@inproceedings{Chaki:02:TypesModelCheckMessPassProg,
    author    = "Chaki, Sagar and Rajamani, Sriram K. and Rehof, Jakob",
    title     = "Types as Models: Model Checking Message-Passing Programs",
    booktitle = {Proceedings of the 29th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'02)},
    year      = 2002,
    isbn      = {1-58113-450-9},
    pages     = "45--57",
    location  = {Portland, Oregon},
    doi       = {http://doi.acm.org/10.1145/503272.503278},
    publisher = pub-ACM,
    abstract    = "Abstraction and composition are the fundamental 
                   issues in making model checking viable for software. 
                   This paper proposes new techniques for automating 
                   abstraction and decomposition using source level 
                   type information provided by the programmer. Our 
                   system includes two novel components to achieve this 
                   end: (1) a new behavioral type-and-effect system for 
                   the Pi-calculus, which extracts sound models as 
                   types, and (2) a new assume-guarantee proof rule for 
                   carrying out compositional model checking on the 
                   types. Open simulation between CCS processes is used 
                   as both the subtyping relation in the type system 
                   and the abstraction relation for compositional model 
                   checking.

                   We have implemented these ideas in a tool--- PIPER.
                   PIPER exploits type signatures provided by the
                   programmer to partition the model checking problem,
                   and emit model checking obligations that are
                   discharged using the SPIN model checker. We present
                   the details on applying PIPER on two examples: (1)
                   the SIS standard for managing trouble tickets
                   across multiple organizations and (2) a file reader
                   from the pipelined implementation of a web server.",
    folder = "Courses 1"
}

@inproceedings{Rajamani:02:ConformanceChckAsyncMessPass,
    author    = {Rajamani, Sriram K. and Rehof, Jakob},
    title     = {Conformance Checking for Models of Asynchronous Message Passing Software},
    booktitle = {Proceedings of the 14th International Conference on Computer Aided Verification (CAV'02)},
    year      = 2002,
    isbn      = {3-540-43997-8},
    pages     = {166--179},
    location  = {Copenhagen, Denmark}, 
    publisher = pub-SV,
    abstract  = "We propose a notion of conformance between a 
                 specification S and an implementation model I 
                 extracted from a message-passing program. In our 
                 framework, S and I are CCS processes, which soundly 
                 abstract the externally visible communication 
                 behavior of a message-passing program. We use the 
                 extracted models to check that programs do not get 
                 stuck, waiting to receive or trying to send messages 
                 in vain. We show that our definition of stuckness and 
                 conformance capture important correctness conditions 
                 of message-passing software. Our definition of 
                 conformance was motivated by the need for modular 
                 reasoning over models, leading to the requirement that 
                 conformance preserve substitutability with respect to 
                 stuck-freeness: If I conforms to S, and P is any 
                 environment such that P | S  is stuck-free, then it 
                 follows that P | I is stuck-free. We present a simple 
                 algorithm for checking if I conforms to S, when I and 
                 S obey certain restrictions.",
    folder = "Courses 1"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@inproceedings{Pierce:95:ConcurrentObjectsProcCalc,
    author = "Pierce, Benjamin C. and Turner, David N.",
    title = "Concurrent Objects in a Process Calculus",
    booktitle = "Proceedings of Theory and Practice of Parallel Programming (TPPP'94)",
    pages = "187--215",
    year = 1995,
    editor = "Ito, Takayasu and Yonezawa, Akinori",
    OPTaddress = "Sendai, Japan",
    volume =  907,
    series =  ser-LNCS,
    publisher = pub-SV,
    annote = "",
    folder = "Div 1",
    url = "citeseer.nj.nec.com/pierce95concurrent.html"
}

@Book{Hoare:85:CommSequProc,
  author = 	 "Hoare, C.A.R.",
  title = 	 "Communicating Sequential Processes",
  publisher = 	 pub-PH,
  year = 	 1985,
  OPTaddress = 	 pub-PH:adr,
  annote = 	 {},
  folder =    "Books + Theses 1"
}

@inproceedings{Zimmer:03:ExpressivenessPureMobAmb,
    author = {Zimmer, Pascal},
    title = {On the Expressiveness of Pure Mobile Ambients},
    booktitle = {Proceedings of the 7th International Workshop on
Expressiveness in Concurrency (EXPRESS'00)},
    pages = "81--104",
    year = 2003,
    editor = {Aceto, Luca and Victor, Bj{\"o}rn},
    OPTaddress 	= {State College, USA},
    volume = 39,
    series = ser-ENTCS,
    publisher = pub-ELS,
    abstract = "We consider the Pure Ambient Calculus, which is
                Cardelli and Gordon's Ambient Calculus (or more
                precisely its safe version by Levi and Sangiorgi)
                restricted to its mobility primitives, and we focus on
                its expressive power. Since it has no form of
                communication or substitution, we show how these
                notions can be simulated by mobility and modifications
                in the hierarchical structure of ambients. As an
                example, we give an encoding of the synchronous
                $\pi$-calculus into pure ambients and we state an
                operational correspondence result. In order to
                simplify the proof and give an intuitive understanding
                of the encoding, we design an intermediate language:
                the $\pi$-Calculus with Explicit Substitutions and
                Channels, which is a syntactic extension of the
                $\pi$-calculus with a specific operational semantics.",
  folder =    "Calculi 1"
}

@techreport{Zimmer:02:ExpressPureSafeAmbients,
    author = "Zimmer, Pascal",
    title = {On the Expressiveness of Pure Mobile Ambients},
    year = 2002,
    institution = "INRIA",
    type = "Research Report",
    number = 4350,
    url = "http://www-sop.inria.fr/mimosa/personnel/Pascal.Zimmer/papers/RR-4350.ps",
    annote = "The technical report accompanying \cite{Zimmer:03:ExpressivenessPureMobAmb}.",
    folder =    "Calculi 1"
}

@inproceedings{Berry:90:ChemicalAbstractMachine,
    author = {Berry, Gerard and Boudol, G{\'e}rard},
    title = {The Chemical Abstract Machine},
    booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming laguages (POPL'90)},
    year = 1990,
    isbn = {0-89791-343-4},
    pages = {81--94},
    location = {San Francisco, California, United States},
    doi = {http://doi.acm.org/10.1145/96709.96717},
    publisher = pub-ACM,
    abstract = "We introduce a new kind of abstract machine based on
                the chemical metaphor used in the $\Gamma$ language of
                Ban{\^a}tre \& al. States of a machine are chemical
                solutions where floating molecules can interact
                according to reaction rules. Solutions can be
                stratified by encapsulating subsolutions within
                membranes that force reactions to occur locally. We
                illustrate the use of this model by describing the
                operational semantics of the TCCS and CCS process
                calculi. We also show how to extract a higher-order
                concurrent $\lambda$-calculus out of the basic
                concepts of the chemical abstract machine.",
    folder = "Calculi 1"
}

@TechReport{Sewell:00:AppliedPi,
    author = 	 {Sewell, Peter},
    title = 	 {Applied $\pi$ --- {A} Brief Tutorial},
    institution =  uni-CAM:cl,
    year = 	 2000,
    number = 	 498,
    url =        "http://www.cl.cam.ac.uk/TechReports/UCAM-CL-TR-498.ps.gz",
    annotate = "A brief introduction to $\pi$-calculus and their 
                application to concurrent and distributed programming.",  
    folder = "ISKS"
}

@Unpublished{Stefani:03:ReqGlobCompProgModl,
  author = {Stefani, Jean-Bernard},
  title = {Requirements for a Global Computing Programming Model},
  Abstract = {This document presents a set of requirements for a
              global computing programming model. Requirements are
              grouped into eight classes covering issues ranging from
              implementability and effectiveness to support for
              high-level coordination and atomic activities
              abstractions.},
  year = 2003, 
  note = {Mikado Deliverable D1.1.2}, 
  url = {http://mikado.di.fc.ul.pt/repository/D1.1.2v1.0.pdf},
  annotate = "",
  folder = "ISKS"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@TechReport{Jeffrey:02:ContxtEquivHOpiRevisited,
  author = 	 {Jeffrey, Alan and Rathke, Julian},
  title = 	 {Contextual equivalence for higher-order $\pi$-calculus revisited},
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 2002,
  number = 	 "2002:04",
  abstract = "The higher-order pi-calculus is an extension of the
              pi-calculus to allow communication of abstractions of
              processes rather than names alone. It has been studied
              intensively by 
               in his thesis where a
              characterisation of a contextual equivalence for
              higher-order pi-calculus is provided using labelled
              transition systems and normal bisimulations. 
              Unfortunately the proof technique used there requires 
              a restriction of the language to only allow finite types. 
              We revisit this calculus and offer an alternative
              presentation of the labelled transition system and a
              novel proof technique which allows us to provide a fully
              abstract characterisation of contextual equivalence
              using labelled transitions and bisimulations for
              higher-order pi-calculus with recursive types also.",
  url =       "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs042002.ps.Z",
  folder =    "HOBisimulation"
}

@TechReport{Merro:01:BisimCongSafeAmb,
  author = 	 {Merro, Massimo and  Hennessy, Matthew},
  title = 	 {Bisimulation Congruences in Safe Ambients},
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 2001,
  number = 	 "2001:05",
  abstract = "We study a variant of Levi and Sangiorgi's Safe Ambients
             (SA) enriched with passwords (SAP). In SAP by managing
             passwords, for example generating new ones and
             distributing them selectively, an ambient may now program
             who may migrate into its computation space, and
             when. Moreover in SAP an ambient may provide different
             services depending on the passwords exhibited by its
             incoming clients. We give an lts based operational
             semantics for SAP and a labelled bisimulation based
             equivalence which is proved to coincide with barbed
             congruence. We use our notion of bisimulation to prove a
             set of algebraic laws which are subsequently exploited to
             prove more significant examples.",
  url =       "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs052001.ps.Z",
  folder =    "HOBisimulation, Models"
}

@TechReport{Merro:03:BisimProofMethMobAmb,
  author = 	 {Merro, Massimo and Nardelli, Francesco Zappa},
  title = 	 {Bisimulation Proof Methods for Mobile Ambients},
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 2003,
  number = 	 "2003:01",
  abstract = "We study the behavioural theory of 
   and Gordon's
             Mobile Ambients. We give an lts based operational
             semantics, and a labelled bisimulation based equivalence
             that coincides with reduction barbed congruence. We also
             provide two up-to proof techniques that we use to prove a
             set of algebraic laws, including the perfect firewall
             equation. ",
  url =          "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs012003.ps.Z",
  folder =    "HOBisimulation"
}

@TechReport{Quaglia:98:PiCalcNotesLabelSem,
  author = 	 "Quaglia, Paola",
  title = 	 "The $\pi$-Calculus: {N}otes on Labelled Semantics",
  institution =  uni-BRICS,
  year = 	 1998,
  type = 	 "Lecture Series",
  number = 	 "LS-98-4",
  address = 	 addr-daimi,
  note =	 "viii+16~pp",
  abstract =	 "The $\pi$-calculus is a name-passing calculus that allows
		  the description of distributed systems with a dynamically
		  changing interconnection topology.  Name communication,
		  together with the possibility of declaring and exporting
		  local names, gives the calculus a great expressive power.
		  For instance, it was remarkably shown that
		  process-passing calculi, that express mobility at higher
		  order, can be naturally encoded in $\pi$-calculus.

		  Since its very first definition, the $\pi$-calculus
		  proliferated in a family of calculi slightly departing
		  the one another either in the communication paradigm
		  (polyadic vs monadic, asynchronous vs synchronous) or in
		  the bisimulation semantics (labelled vs unlabelled, late
		  vs early vs open vs barbed vs \ldots).

		  These short notes present a collection of the labelled
		  strong semantics of the (synchronous monadic)
		  $\pi$-calculus.  The notes could not possibly substitute
		  any of the standard references listed in the
		  Bibliography.  They rather represent an attempt to group
		  together, using a uniform notation and the terminology
		  that got assessed over the last years, a few definitions
		  and concepts otherwise scattered throughout the
		  $\pi$-calculus literature.
		  \subsubsection*{Contents}
		  \begin{itemize}
		  \item[1] Preliminaries
	     	  \item[2] Syntax
	     	  \item[3] Labelled semantics
	     	    \begin{itemize}
	     	    \item[3.1] Late semantics
	     	    \item[3.2] Early semantics
	     	    \item[3.3] Open semantics
	     	    \end{itemize}
	     	  \end{itemize}.",
  annote =       "This article describe three kinds of bisimulations
                  introduced in the $\pi$-calculus: early, late, and
                  open bisimulation. 

                  Late follows the intutition that the derivation of a
                  input is a function of the received name and that
                  the function should be in the relation for all
                  inputs.

                  Early bisimulation follows the intuition that
                  committing on the input channel and the choice of
                  the actual parameter is considered as a single
                  atomic event. Early reverses the quantification of
                  late, since instead of finding a Q' st. it satisfies
                  the condition for all input, it is enough to --- for
                  each input --- to find a Q' which satisfies the
                  condition.

                  Open bisimulation delayes the name instantiation
                  even more and moves the name instantiation inside
                  the definition of the bisimulation (so that it
                  becomes non-grounded)",
  url =       "http://brics.dk/LS/98/4/BRICS-LS-98-4.ps.gz",
  folder =    "HOBisimulation"
}

@article{Sangiorgi:98:BisimulationProofMethod,
    author = "Sangiorgi, Davide",
    title = "On the Bisimulation Proof Method",
    journal = j-MAT-STRUCT,
    volume = 8,
    number = 5,
    pages = "447--479",
    year = 1998,
    url = "citeseer.nj.nec.com/sangiorgi94bisimulation.html",
    abstract = "The most popular method for establishing
               bisimilarities among processes is to exhibit
               bisimulation relations. By definition, R is a
               bisimulation relation if R progresses to R itself,
               i.e., pairs of processes in R can match each other's
               actions and their derivatives are again in R.

               We study generalisations of the method aimed at
               reducing the size of the relations to exhibit and hence
               relieving the proof work needed to establish
               bisimilarity results. We allow a relation R to progress
               to a different relation F (R), where F is a function on
               relations. Functions which can be safely used in this
               way (i.e., such that if R progresses to F( R), then R
               only includes pairs of bisimilar processes) are
               sound. We give a simple condition which ensures
               soundness. We show that the class of sound functions
               contains non-trivial functions and we study the closure
               properties of the class with respect to various
               important function constructors, like composition,
               union and iteration. These properties allow us to
               construct sophisticated sound functions--and hence
               sophisticated proof techniques for bisimilarity--from
               simpler ones.

               The usefulness of our proof techniques is supported by
               various non-trivial examples drawn from the process
               algebras CCS and pi-calculus . They include the proof
               of the unique solution of equations and the proof of a
               few properties of the replication operator. Among
               these, there is a novel result which justifies the
               adoption of a simple form of prefix-guarded replication
               as the only form of replication in the pi-calculus.",
    folder =    "HOBisimulation"
}

@article{Sangiorgi:96:BisimulationHigherOrderProcCal,
    author = "Sangiorgi, Davide",
    title = "Bisimulation for Higher-Order Process Calculi",
    journal = j-INFO-COMP,
    volume = 131,
    number = 2,
    pages = "141--178",
    year = 1996,
    url = "citeseer.nj.nec.com/sangiorgi96bisimulation.html",
    abstract = "A higher-order process calculus is a calculus for
                communicating systems which contains higher-order
                constructs like communication of terms. We analyse the
                notion of bisimulation in these calculi. We argue that
                both the standard definition of bisimulation (i.e.,
                the one for CCS and related calculi), as well as
                higher-order bisimulation (studied by
                Astesiano-Giovini-Reggio, Boudol, and Thomsen) are in
                general unsatisfactory, because over-discriminating.

                We propose and study a new form of bisimulation for
                such calculi, called context bisimulation, which
                yields a more satisfactory discriminanting power. A
                drawback of context bisimulation is the heavy use of
                universal quantification in its definition. A major
                goal of the paper is to find characterisations which
                make bisimilarities easier to verify.

                An important role in our theory is played by the
                factorisation theorem: When comparing the behaviour of
                two processes, it allows us to ``isolate''
                subcomponents which might cause differences, so that
                the analysis can be concentrated on them. ",
    annotate = "Introduces context bisimulation, triggered
               bisimulation, and normal bisimulation and proves that
               they coincide. Triggered bisimulation is the simplest
               of the bisimulations (instead of universal
               quantification it is enough to take a fresh trigger),
               but it is only defined over triggered processes. Normal
               bisimulation is not as simple as triggered
               bisimulation, but instead it is defined over all
               processes (extended to agents), and again requires not
               universal quantification over abstraction and
               concretions. The article also contains some good
               example proofs",
    folder = "HOBisimulation"
}

@InProceedings{Castagna:02:SealCaclRevisited,
  author = 	 {Castagna, Giuseppe and Nardelli, Francesco Zappa},
  title = 	 {The {S}eal Calculus Revisited: {C}ontextual Equivalence and Bisimilarity},
  booktitle =    "Proceedings of the 22nd Conference on the Foundations of Software Technology and Theoretical Computer Science (FSTTCS'02)",
  pages = 	 "85--96",
  year = 	 2002,
  editor = 	 "Agrawal, Manindra and Seth, Anil",
  OPTaddress =   "Kanpur, India",
  volume = 	 2556,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract =     "We present a new version of the Seal Calculus, a
                 calculus of mobile computation. We study
                 observational congruence and bisimulation theory, and
                 show how they are related.",
  annote = 	 {},
  folder =    "HOBisimulation"
}


@PhdThesis{Sangiorgi:92:ExpressMobProgAlgFirstAndHO,
  author = 	 "Sangiorgi, Davide",
  title = 	 {Expressing Mobility in Process Algebras: {F}irst-Order and Higher-Order Paradigms},
  school = 	 {Department of Computer Science, University of Edinburgh},
  year = 	 1992,
  OPTtype = 	 {{PhD} thesis  {CST}--99--93},
  OPTnote = 	 {},
  annote = 	 {},
  folder =    "HOBisimulation"
}

@Article{Sangiorgi:96:TheoryBisimPiCalc,
  author = "Sangiorgi, Davide",
  title  = "A Theory of Bisimulation for the $\pi$-calculus",
  journal= j-ACTA-INFORM,
  year   = 1996,
  volume = 33,
  number = 1,
  pages  = "69--97",
  abstract = "We study a new formulation of bisimulation for the
             pi-calculus, which we have called open bisimulation
             ($\sim$). In contrast with the previously known
             bisimilarity equivalences, $\sim$ is preserved by all
             pi-calculus operators, including input prefix. The
             differences among all these equivalences already appear
             in the sublanguage without name restrictions: Here the
             definition of $\sim$ can be factorised into a
             ``standard'' part which, modulo the different syntax of
             actions, is the CCS bisimulation, and a part specific to
             the pi-calculus , which requires name
             instantiation. Attractive features of $\sim$ are: A
             simple axiomatisation (of the finite terms), with a
             completeness proof which leads to the construction of
             minimal canonical representatives for the equivalence
             classes of $\sim$; an ``efficient'' characterisation,
             based on a modified transition system. This
             characterisation seems promising for the development of
             automated-verification tools and also shows the
             call-by-need flavour of $\sim$. Although in the paper we
             stick to the pi-calculus , the issues developed may be
             relevant to value-passing calculi in general.",
  annote = "Open bisimulation is a congruence. An efficient
              characterisation by constructing a transition system
              specialised for open bisimulation like done in
              \cite{Hennessy:92:SymbolicBisims} with no quantification
              over substitutions. Simple axiomatisation for finite
              terms. Canonical representatives of the equivalence
              classes of sim. Instantiation can be delayed. Can be
              split into two parts: a CCS bisim + name
              instantiation. Sim is the largest ground bisimulation
              which is closed under all substitutions. Sound and
              complete axiomatisation for sim on finite terms. An
              efficient characterisation of open bisimulation on a
              special transition system. Distinctions = permanent
              inequalities on names. Extending the theory to the full
              pi-calculus (including restriction).",
  folder =    "HOBisimulation"
}

@Article{Milner:93:ModalLogicsMobProcesses,
  author = 	 "Milner, Robin and Parrow, Joachim and Walker, David",
  title = 	 "Modal Logics for Mobile Processes",
  journal = 	 j-THEO-CS,
  year = 	 1993,
  volume = 	 114,
  number = 	 1,
  pages = 	 "149--171",
  annote = 	 {},
  abstract = "In process algebras, bisimulation equivalence is
             typically defined directly in terms of the operational
             rules of action; it also has an alternative
             characterisation in terms of a simple modal logic
             (sometimes called Hennessy-Milner logic. This paper first
             defines two forms of bisimulation equivalence for the
             pi-calculus, a process algebra which allows dynamic
             reconfiguration among processes; it then explores a
             family of logics with different modal operators. It is
             proven that two of these logics characterise the two
             bisimulation equivalences. Also, the relative expressive
             power of all the logics is exhibited as a lattice.",
  folder =    "Calculi 1"
}


@Article{Parrow:95:AlgebraTheoNamePassCalc,
  author = 	 "Parrow, Joachim and Sangiorgi, Davide",
  title = 	 "Algebraic Theories for Name-Passing Calculi",
  journal = 	 j-INFO-COMP,
  year = 	 1995,
  volume = 	 120,
  number = 	 2,
  pages = 	 "174--197",
  note = 	 "MANGLER UDSKRIFT",
  annote = 	 {},
  abstract = "In a theory of processes the \emph{names} are atomic
             data items which can be exchanged and tested for
             identity. A well-known example of a calculus for
             name-passing is the pi-calculus, where names additionally
             are used as communication ports. We provide complete
             axiomatisations of late and early bisimulation
             equivalences in such calculi. Since neither of the
             equivalences is a congruence we also axiomatise the
             corresponding largest congruences. We consider a few
             variations of the signature of the language; among these,
             a calculus of deterministic processes which is
             reminiscent of sequential functional programs with a
             conditional construct. Most of our axioms are shown to be
             independent. The axiom systems differ only by a few
             simple axioms and reveal the similarities and the
             symmetries of the calculi and the equivalences.",
  folder =    ""
}

@PhdThesis{Thomsen:90:CalcHOCommSys,
  author = 	 {Thomsen, Bent},
  title = 	 "Calculi for Higher Order Communicating Systems",
  school = 	 "Imperial College, London University",
  year = 	 1990,
  OPTtype = 	 {},
  note = 	 "MANGLER UDSKRIFT",
  annote = 	 {},
  folder =    ""
}

@InProceedings{Boudol:89:TowardsLambdCalcConcuCommSys,
  author =       "Boudol, G{\'e}rard",
  title =        "Towards a Lambda-Calculus for Concurrent and
                 Communicating Systems",
  editor =       "D{\'\i}az, Josep and Orejas, Fernando",
  booktitle =    "Proceedings of Theory and Practice of Software
                 Development (TAPSOFT '89)",
  year =         1989,
  publisher =    pub-SV,
  series =       ser-LNCS,
  volume =       351,
  pages =        "149--161",
  OPTnote = 	 "MANGLER UDSKRIFT",
  abstract = "A calculus is presented for concurrent and communicating
             processes, which is a direct and simple extension of the
             lambda -calculus. The communication mechanism used is
             that of R. Milner's calculus CCS (1980): to communicate
             consists in synchronously sending and receiving a value
             through a shared port. Then the calculus is parameterized
             on a given set of port names, which are used in the two
             primitives for sending and receiving a value-as in the
             lambda -calculus, a value can be any term. The author
             uses two parallel constructs: the first is interleaving,
             which does not allow communication between agents. The
             second, called cooperation, is a synchronizing construct
             which forces two agents to communicate on every port
             name. He shows that the lambda -calculus is a simple
             sub-calculus of his, i.e., lambda -abstraction is a
             particular case of reception (on a port named lambda ),
             and application is a particular case of cooperation",
  annote = {}, 
  folder = ""
}

@InProceedings{Amadio:93:RedCHOCSBisimToPiBisim,
  title =        "On the Reduction of {CHOCS} Bisimulation to
                 $\pi$-calculus Bisimulation",
  author =       "Amadio, Roberto M.",
  pages =        "112--126",
  booktitle =    "Proceedings of the 4th International Conference on
                 Concurrency Theory (CONCUR'93)",
  editor =       "Best, Eike",
  OPTaddress =      "Hildesheim, Germany",
  OPTmonth =        "Aug",
  year =         1993,
  series =       ser-LNCS,
  volume =       715,
  publisher =    pub-SV,
  annote = 	 "Like context bisimulation",

  abstract = "CHOCS and pi-calculus are two extensions of CCS where,
              respectively processes and channels are transmissible
              values. In previous work we have proposed a
              formalization of the notion of bisimulation for
              CHOCS. In this paper we suggest a more effective way to
              reason about this notion by means of a translation of
              CHOCS into a variant of the pi-calculus.",
  folder =    ""
}

@Article{Pitts:98:ProceCalcEvalCommiForm,
  title =        "Process Calculus Based upon Evaluation to Committed
                 Form",
  author =       "Pitts, Andrew M. and Ross, Joshua R. X.",
  journal = 	 j-THEO-CS,
  year = 	 1998,
  volume = 	 195,
  number = 	 2,
  pages = 	 "155--182",
  publisher =    pub-ESP,
  abstract = "An approach to the semantics of CCS-like communicating
             processes is proposed that is based upon evaluation of
             processes to input- or output-committed form, with no
             explicit mention of silent actions. This leads to a
             co-inductively defined notion of evaluation bisimilarity
             - a form of weak branching-time equivalence which is
             shown to be a congruence, even in the presence of
             summation. The relationship between this evaluation-based
             approach and the more traditional, labelled transition
             semantics is investigated. In particular, with some
             restriction on sums, CCS observation equivalence is
             characterised purely in terms of evaluation to committed
             form, and evaluation bisimilarity is characterised as a
             weak delay equivalence. These results are extended to the
             higher-order case, where evaluation bisimilarity
             coincides with Sangiorgi's weak context bisimilarity. An
             evaluation-based approach to pi-calculus and the
             relationship with Milner and Sangiorgi's reduction-based
             notion of barbed bisimulation are also examined.",
  annote = 	 "A characterisation of context bisimularity as an evaluation bisimularity",
  folder =    "Calculi 2"
}

@PhdThesis{Weijland:89:SyncAsyncProcAlg,
  author = 	 {Weijland, W. Peter},
  title = 	 "Synchrony and Asynchrony in Process Algebra",
  school = 	 {University of Amsterdam},
  year = 	 1989,
  OPTaddress = 	 {},
  note = 	 "MANGLER UDSKRIFT eller bare link til hjemmeside",
  annote = 	 "delay bisimulation in CCS-like language",
  folder =    ""
}

@InProceedings{Milner:92:BardbedBisim,
  title =        "Barbed Bisimulation",
  author =       "Milner, Robin and Sangiorgi, Davide",
  editor =       "Werner Kuich",
  booktitle =    "Proceedings of the 19th International Colloquium on 
                 Automata, Languages and Programming (ICALP'92)",
  OPTaddress =      "Vienna, Austria",
  OPTmonth =        "13--17~" # jul,
  year =         1992,
  series =       ser-LNCS,
  volume =       623,
  publisher =    pub-SV,
  pages =        "685--695",
  abstract = "We propose barbed bisimulation as a tool to describe
             bisimulation-based equivalence uniformly for any calculi
             possessing (a) a reduction relation and (b) a convergency
             predicate which simply detects the possibility of
             performing some observable action. This opens interesting
             perspectives for the adoption of a reduction semantics in
             process algebras. As a test-case we prove that strong
             bisimulation of CCS coincides with the congruence induced
             by barbed bisimulation.", 
  folder = "HOBisimulation"
}

@InProceedings{Sangiorgi:92:ProbWeakBisimUpTo,
  title =        "The Problem of ``Weak Bisimulation Up To''",
  author =       "Sangiorgi, Davide and Milner, Robin",
  pages =        "32--46",
  booktitle =    "Proceedings of the 3rd International Conference on
                 Concurrency Theory (CONCUR'92)",
  editor =       "Cleaveland, W. Rance",
  OPTaddress =      "Stony Brook, New York",
  OPTmonth =        "24--27" # aug,
  year =         1992,
  series =       ser-LNCS,
  volume =       630,
  abstract = "``Bisimulation up to'' is a technique for reducing the
             size of the relation needed to define a bisimulation. It
             works smoothly in the strong case, where it was first
             introduced by Milner. But this does not directly
             generalize to the weak case, as erroneously reported in
             Milner's book. To overcome this problem, two new
             ``up-to'' techniques are proposed: They are respectively
             based on the use of expansion and of almost-weak
             bisimulation. The second solution is more general than
             the first one, but expansion enjoys a nicer mathematical
             treatment. The usefulness and generality of the solutions
             is motivated with non-trivial examples: two different
             implementations of a sorting machine .",
  publisher =    pub-SV,
  OPTISBN =         "ISBN 3-540-55822-5 and 0-387-55822-5",
  annote = 	 "Introduction to the up-to techniques probem",
  folder =    "HOBisimulation"
}


@article{Groote:92:SOSBisimCongr,
  author = {Groote, Jan Friso and Vaandrager, Frits},
  title = {Structured Operational Semantics and Bisimulation as a Congruence},
  journal = j-INFO-COMP,
  volume = 100,
  number = 2,
  year = 1992,
  issn = {0890-5401},
  pages = {202--260},
  publisher = pub-AP,
  note = 	 "MANGLER UDSKRIFT",
  annote = 	 "tyft format => all contexts preserve bisimilarity",
  folder =    ""
}

@TechReport{Milner:91:PolyadicPiTutorial,
  author =       "Milner, Robin",
  title =        "The Polyadic $\pi$-Calculus: {A} Tutorial",
  institution =  "LFCS, Department of Computer Science, University of
                 Edinburgh",
  year =         1991,
  number =    "ECS-LFCS-91-180",
  OPTmonth =     oct,
  URL =          "http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-180/ECS-LFCS-91-180.ps",
  abstract = "The pi-calculus is a model of concurrent
              computation based upon the notion of naming. It is first
              presented in its simplest and original form, with the
              help of several illustrative applications. Then it is
              generalized from monadic to polyadic form. Semantics is
              done in terms of both a reduction system and a version
              of labelled transitions called commitment; the known
              algebraic axiomatization of strong bisimilarity is given
              in the new setting, and so also is a characterization in
              modal logic. Some theorems about the replication
              operator are proved.

              Justification for the polyadic form is provided by the
              concept of sort, sorting and sort discipline which it
              supports. Several illustrations of different sortings
              are given. One example is the presentation of data
              structures as processes which respect a particular
              sorting; another is the sorting for a known translation
              of the lambda-calculus in to pi-calculus. For this
              translation, the equational validity of beta-conversion
              is proved with the help of replication theorems. The
              paper ends with an extension of the pi-calculus to
              w-order processes, and a brief account of the
              demonstration by Davide Sangiorgi that higher-order
              processes may be faithfully encoded at first-order. This
              extends and strengthens the original result of this kind
              given by Bent Thomsen for second-order processes.",
  folder =    "Edinburgh 03"
}

@Book{Awodey:03:CategoEveryDraft,
  author = 	 "Awodey, Steve",
  title = 	 "Categories for Everybody",
  publisher =	 "Carnegie Mellon University",
  year = 	 2003,
  OPTmonth = 	 feb,
  note = 	 "Draft of February 5, 2003",
  annote = 	 {},
  folder =    "Books + Theses 1"
}



@Book{Katoen:99:ConcepAlgToolsMC,
  author =       "Katoen, Joost-Pieter",
  title =        "Concepts, Algorithms and Tools for Model Checking",
  publisher =    "Friedrich-Alexander-Universit{\"a}t Erlangen
                 N{\"u}rnberg",
  year =         1999,
  volume =       "32-1",
  series =       "Arbeitsberichte der Informatik",
  annote = 	 {},
  folder =    "Books + Theses 1"
}

@PhdThesis{Turner:95:PolymorPiTheoryImpl,
  author = 	 "Turner, David N.",
  title = 	 "The Polymorphic Pi-calculus: {T}heory and
                 Implementation",
  school = 	 {Department of Computer Science, University of Edinburgh},
  year = 	 1996,
  OPTtype = 	 {},
  annote = 	 {},
  folder =    "Books + Theses 1"
}


@TechReport{Jensen:03:BigraphsMobProce,
  author =	 {Jensen, Ole H{\o}gh and Milner, Robin},
  title = 	 "Bigraphs and Mobile Processes",
  year = 	 2003,
  OPTmonth = 	 jul,
  url = 	 {http://www.cl.cam.ac.uk/TechReports/UCAM-CL-TR-570.pdf},
  institution =  uni-CAM:cl,
  abstract = 	 {A bigraphical reactive system (BRS) involves bigraphs,
            	  in which the nesting of nodes represents locality,
            	  independently of the edges connecting them; it also
            	  allows bigraphs to reconfigure themselves. BRSs aim to
            	  provide a uniform way to model spatially distributed
            	  systems that both compute and communicate. In this
            	  memorandum we develop their static and dynamic theory.
            	  
            	  In Part~I we illustrate bigraphs in action, and show how
            	  they correspond to to process calculi. We then develop
            	  the abstract (non-graphical) notion of wide reactive
            	  system (WRS), of which BRSs are an instance. Starting
            	  from reaction rules ---often called rewriting rules--- we
            	  use the RPO theory of Leifer and Milner to derive
            	  (labelled) transition systems for WRSs, in a way that
            	  leads automatically to behavioural congruences.
            	  
            	  In Part~II we develop bigraphs and BRSs formally. The
            	  theory is based directly on graphs, not on syntax. Key
            	  results in the static theory are that sufficient RPOs
            	  exist (enabling the results of Part~I to be applied),
            	  that parallel combinators familiar from process calculi
            	  may be defined, and that a complete algebraic theory
            	  exists at least for pure bigraphs (those without
            	  binding). Key aspects in the dynamic theory ---the
            	  BRSs--- are the definition of parametric reaction rules
            	  that may replicate or discard parameters, and the full
            	  application of the behavioural theory of Part~I.
            	  
            	  In Part~III we introduce a special class: the simple
            	  BRSs. These admit encodings of many process calculi,
            	  including the $\pi$-calculus and the ambient calculus. A
            	  still narrower class, the basic BRSs, admits an easy
            	  characterisation of our derived transition systems. We
            	  exploit this in a case study for an asynchronous
            	  $\pi$-calculus. We show that structural congruence of
            	  process terms corresponds to equality of the representing
            	  bigraphs, and that classical strong bisimilarity
            	  corresponds to bisimilarity of bigraphs. At the end, we
            	  explore several directions for further work.},
  number = 	 {UCAM-CL-TR-570},
  annote = 	 {},
  folder =    "Bigraphs"
}


@TechReport{Milner:04:AxiomsBigraphicalStruc,
  author = 	 "Milner, Robin",
  title = 	 "Axioms for Bigraphical Structure",
  url = 	 {http://www.cl.cam.ac.uk/TechReports/UCAM-CL-TR-581.pdf},
  institution =  uni-CAM:cl,
  OPTmonth = 	 feb,
  year = 	 2004,
  number = 	 {UCAM-CL-TR-581},
  abstract = "This paper axiomatises the structure of bigraphs, and
             proves that the resulting theory is complete. Bigraphs
             are graphs with double structure, representing locality
             and connectivity. They have been shown to represent
             dynamic theories for the -calculus, mobile ambients and
             Petri nets, in a way that is faithful to each of those
             models of discrete behaviour. While the main purpose of
             bigraphs is to understand mobile systems, a prerequisite
             for this understanding is a well-behaved theory of the
             structure of states in such systems. The algebra of
             bigraph structure is surprisingly simple, as the paper
             demonstrates; this is because bigraphs treat locality and
             connectivity orthogonally.",
  annote = 	 "",
  folder =    "Bigraphs"
}

@TechReport{Jensen:04:BigraphsMobProceRevised,
  author =	 {Jensen, Ole H{\o}gh and Milner, Robin},
  title = 	 "Bigraphs and Mobile Processes (revised)",
  year = 	 2004,
  OPTmonth = 	 feb,
  url = 	 {http://www.cl.cam.ac.uk/TechReports/UCAM-CL-TR-580.pdf},
  institution =  uni-CAM:cl,
  number = 	 {UCAM-CL-TR-580},
  abstract =     "See \cite{Jensen:03:BigraphsMobProce}",
  annote = 	 {},
  folder =    "Bigraphs"
}

@Article{Thomsen:93:PlainCHOCS,
  author =       "Thomsen, Bent",
  title =        "Plain {CHOCS}: {A} Second Generation Calculus for
                 Higher Order Processes",
  journal =      j-ACTA-INFORM,
  volume =       30,
  number =       1,
  pages =        "1--59",
  OPTmonth =        jan,
  year =         1993,
  annote = 	 {},
  folder =    "Calculi 1"
}

@InCollection{Nielson:99:TypeAndEffectSystems,
  author =       "Nielson, Flemming and Nielson, Hanne Riis",
  title =        "Type and Effect Systems: {R}ecent Insights and Advances",
  booktitle =    "Correct System Design",
  publisher =    pub-SV,
  year =         1999,
  editor =       "Olderog, Ernst-Rüdiger and Steffen, Bernhard",
  number =       1710,
  series =       ser-LNCS,
  pages =        "114--136",
  abstract = "The design and implementation of a correct system can
              benefit from employing static techniques for ensuring
              that the dynamic behaviour satisfies the
              specification. Many programming languages incorporate
              types for ensuring that certain operations are only
              applied to data of the appropriate form. A natural
              extension of type checking techniques is to enrich the
              types with annotations and effects that further describe
              intensional aspects of the dynamic behaviour.",
  folder =	 "Div 1"
}

@InProceedings{Godskesen:02:MobileResources,
  author =       "Godskesen, Jens Christian and Hildebrandt, Thomas and
                 Sassone, Vladimiro",
  title =        "A Calculus of Mobile Resources",
  booktitle =    "Proceedings of the 13th International
                 Conference on Concurrency Theory (CONCUR'02)",
  OPTaddress =   "Brno, Czech Republic",
  editor =       "Brim, Lubos and Jancar, Petr and Kret\'{\i}nsk{\'y}, Mojm\'{\i}r and Kucera, Anton\'{\i}n",
  publisher =    pub-SV,
  series =       ser-LNCS,
  volume =       2421,
  year =         2002,
  OPTmonth =        aug,
  pages =        "272--287",
  annotation =   "",
  folder =	 "Calculi 2"  
}

@TechReport{Godskesen:02:CalcMobileResources,
  author = 	 "Godskesen, Jens Christian and Hildebrandt, Thomas and
                 Sassone, Vladimiro",
  title = 	 "A Calculus of Mobile Resources",
  institution =  "IT University of Copenhagen",
  year = 	 2002,
  OPTtype = 	 {},
  number = 	 "TR-2002-16",
  url = "http://www.itu.dk/Internet/graphics/ITU-library/Internet/Forskning/Technical_Reports/ITU-TR-2002-16.ps",
  abstract = "We introduce a calculus of Mobile Resources (MR) tailored
           for the design and analysis of systems containing mobile,
           possibly nested, computing devices that may have resource
           and access constraints, and which are not copyable nor
           modifiable per se. We provide a reduction as well as a
           labelled transition semantics and prove a correspondence
           between barbed bisimulation congruence and a higher-order
           bisimulation. We provide examples of the expressiveness of
           the calculus, and apply the theory to prove one of its
           characteristic properties.",
  folder =    "Calculi 2"
}

@inproceedings{Levi:00:ControlInterAmbients,
  author = {Levi. Francesca and Sangiorgi, Davide},
  title = "Controlling Interference in Ambients",
  booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'00)},
  year = 2000,
  isbn = {1-58113-125-9},
  pages = {352--364},
  location = {Boston, MA, USA},
  doi = {http://doi.acm.org/10.1145/325694.325741},
  publisher = pub-ACM,
  annotation =   "",
  abstract = "Two forms of interferences are individuated in Cardelli
             and Gordon's Mobile Ambients (MA): plain interferences,
             which are similar to the interferences one finds in CCS
             and $\pi$-calculus; and grave interferences, which are
             more dangerous and may be regarded as programming
             errors. To control interferences, the MA movement
             primitives are modified. On the new calculus, the Mobile
             Safe Ambients (SA), a type system is defined that:
             controls the mobility of ambients; removes all grave
             interferences. Other advantages of SA are: a useful
             algebraic theory; programs sometimes more robust (they
             require milder conditions for correctness) and/or
             simpler. These points are illustrated on several
             examples.",
  folder =	 "Calculi 1"
}



@inproceedings{Mitchell:85:AbstractTypesExistentialTypes,
  author = {Mitchell, John C. and Plotkin, Gordon D.},
  title = "Abstract Types have Existential Types",
  booktitle = {Proceedings of the 12th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'85)},
  year = 1985,
  isbn = {0-89791-147-4},
  pages = {37--51},
  location = {New Orleans, Louisiana, United States},
  doi = {http://doi.acm.org/10.1145/318593.318606},
  publisher = pub-ACM,
  annotation = "",
  folder = "Div 1"
}

@InCollection{Cardelli:99:AbstracMobCompu,
  author = 	 "Cardelli, Luca",
  title = 	 "Abstractions for Mobile Computation",
  booktitle = "Secure Internet Programming: Security Issues for Mobile and Distributed Objects",
  pages = 	 "51--94",
  year = 	 1999,
  publisher =    pub-SV,
  editor = 	 "Vitek, Jan and Jensen, Christian",
  volume = 	 1603,
  series = 	 ser-LNCS,
  OPTtype = 	 {},
  OPTchapter = 	 {},
  abstract = "We discuss the difficulties caused by mobile computing
              and mobile computation over wide-area networks. We
              propose a unified framework for overcoming such
              difficulties.",
  annote = 	 {},
  folder =    ""
}

@Article{Clarke:02:ProcteFreeExprOnlineFreenet,
  author = 	 "Clarke, Ian and Miller, Scott G. and Hong, Theodore W. and Sandberg, Oskar and Wiley, Brandon",
  title = "Protecting Free Expression Online with Freenet",
  journal = 	 "IEEE Internet Computing",
  year = 	 2002,
  volume = 	 6,
  number = 	 1,
  pages = 	 "40--49",
  annote = 	 {},
  abstract = "Freenet uses a decentralized P2P architecture to create
             an uncensorable and secure global information storage
             system.",
  url = "http://freenet.sourceforge.net/papers/freenet-ieee.pdf",
  folder =    "Edinburgh 2003"
}


@InProceedings{Clarke:01:FreenetDistAnonyInforStorRetrSyst,
  author = 	 "Clarke, Ian and Sandberg, Oskar and Wiley, Brandon and Hong, Theodore W.",
  title = 	 "Freenet: {A} Distributed Anonymous Information Storage and Retrieval System",
  booktitle =    "Designing Privacy Enhancing Technologies, International Workshop on Design Issues in Anonymity and Unobservability",
  pages = 	 "46--66",
  year = 	 2001,
  editor = 	 "Federrath, Hannes",
  volume = 	 2009,
  series = 	 ser-LNCS,
  OPTaddress = 	 {},
  publisher =    pub-SV,
  annote = 	 {},
  abstract = "We describe Freenet, an adaptive peer-to-peer network
             application that permits the publication, replication,
             and retrieval of data while protecting the anonymity of
             both authors and readers. Freenet operates as a network
             of identical nodes that collectively pool their storage
             space to store data les and cooperate to route requests
             to the most likely physical location of data. No
             broadcast search or centralized location index is
             employed. Files are referred to in a location-independent
             manner, and are dynamically replicated in locations near
             requestors and deleted from locations where there is no
             interest. It is infeasible to discover the true origin or
             destination of a le passing through the network, and di
             cult for a node operator to determine or be held
             responsible for the actual physical contents of her own
             node.",
  folder =    "Edinburgh 2003"
}

@TechReport{Gordon:01:AuthTypingSecurProto,
  author = 	 "Gordon, Andrew D. and Jeffrey, Alan",
  title = 	 "Authenticity by Typing for Security Protocols",
  institution =  "Microsoft Research",
  year = 	 2001,
  number = 	 "MSR-TR-2001-49",
  annote = 	 {},
  abstract = "We propose a new method to check authenticity properties
              of cryptographic protocols. First, code up the protocol
              in the spi-calculus of Abadi and Gordon. Second, specify
              authenticity properties by annotating the code with
              correspondence assertions in the style of Woo and
              Lam. Third, figure out types for the keys, nonces, and
              messages of the protocol. Fourth, check that the
              spi-calculus code is well-typed according to a novel
              type and effect system presented in this paper. Our main
              theorem guarantees that any well-typed protocol is
              robustly safe, that is, its correspondence assertions
              are true in the presence of any opponent expressible in
              spi. It is feasible to apply this method by hand to
              several well-known cryptographic protocols. It requires
              little human effort per protocol, puts no bound on the
              size of the opponent, and requires no state space
              enumeration. Moreover, the types for protocol data
              provide some intuitive explanation of how the protocol
              works. This paper describes our method and gives some
              simple examples. Our method has led us to the
              independent rediscovery of flaws in existing protocols
              and to the design of improved protocols.",
  url =       "ftp://ftp.research.microsoft.com/pub/tr/tr-2001-49.ps",
  folder =    "Edinburgh 2003"
}

@InProceedings{Bettini:03:KLAIMProjTheoPrac,
  author = 	 "Bettini, Lorenzo and Bono, Viviana and De Nicola, Rocco and Ferrari, Gianluigi and Gorla, Daniele and Loreti, Michele and Moggi, Eugenio and Pugliese, Rosario and Tuosto, Emilio and Venneri, Betti",
  title = 	 "The {KLAIM} Project: {T}heory and Practice",
  booktitle =    "Global Computing: Programming Environments, Languages, Security and Analysis of Systems",
  pages = 	 "88-150",
  year = 	 2003,
  editor = 	 "Priami, Corrado",
  volume = 	 2874,
  series = 	 ser-LNCS,
  publisher = pub-SV,
  abstract = "KLAIM (Kernel Language for Agents Interaction and
             Mobility) is an experimental language specifically
             designed to program distributed systems consisting of
             several mobile components that interact through multiple
             distributed tuple spaces. KLAIM primitives allow
             programmers to distribute and retrieve data and processes
             to and from the nodes of a net. Moreover, localities are
             first-class citizens that can be dynamically created and
             communicated over the network. Components, both
             stationary and mobile, can explicitly refer and control
             the spatial structures of the network.  This paper
             reports the experiences in the design and development of
             KLAIM. Its main purpose is to outline the theoretical
             foundations of the main features of KLAIM and its
             programming model. We also present a modal logic that
             permits reasoning about behavioural properties of systems
             and various type systems that help in controlling agents
             movements and actions. Extensions of the language in the
             direction of object oriented programming are also
             discussed together with the description of the
             implementation efforts which have lead to the current
             prototypes.",
  annote = 	 {},
  folder = "Edinburgh 2003"
}

@InProceedings{Kosiuczenko:03:SequenceDiaMob,
  author = 	 "Kosiuczenko, Piotr",
  title = 	 "Sequence Diagrams for Mobility",
  booktitle =    "Workshop on Conceptual Modelling Approaches to Mobile Information Systems Development",
  pages = 	 "147--155",
  year = 	 2003,
  OPTeditor = 	 {},
  volume = 	 2784,
  series = 	 ser-LNCS,
  publisher = pub-SV,
  annote = 	 {},
  abstract = "There are several kinds of UML diagrams for convenient
             modelling of behaviour, but these diagrams can be hardly
             used for modelling mobility. The situation is not very
             different in the case of agent languages. There exist
             already some proposals for modelling mobility of
             interacting agents by graphical notations, but these
             notations are rather not very intuitive and hard to read
             if the specification becomes a bit complex. In this paper
             we propose a new graphical notation for modelling
             interaction of mobile objects. The notation is based on
             UML sequence diagrams. We model behaviour of mobile
             objects using a generalized version of lifelines. For
             different kinds of actions like creating, entering or
             leaving a mobile object we use stereotyped messages. We
             provide also a zoom-out, zoom-in facility allowing us to
             abstract from specification details. We explain our
             notation in a series of examples, study its applicability
             and limits.",
  folder =    "Edinburgh 2003"
}

@InProceedings{Baumeister:03:ExtendActivityDiaModlMobSyst,
  author = 	 "Baumeister, Hubert and Koch, Nora and Kosiuczenko, Piotr and  Wirsing, Martin",
  title = 	 "Extending Activity Diagrams to Model Mobile Systems",
  booktitle = "Objects, Components, Architectures, Services, and Applications for a Networked World",
  pages = 	 "278--293",
  year = 	 2003,
  editor = 	 {Aksit, Mehmet and Mezini, Mira and Unland, Rainer},
  volume = 	 2591,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  annote = 	 {},
  abstract = "Mobile systems are gaining more and more importance,
             nevertheless the means for their specifications are still
             underdeveloped. Existing UML diagrams can be used to
             conveniently model behavior, but these diagrams can be
             hardly used to model mobility. In this paper we present
             an extension to UML class and activity diagrams to model
             mobile systems. We assume that mobile objects can migrate
             from one location to another. Locations can be nested and
             mobile too. We introduce stereotypes to model mobile
             objects, locations, and activities like moving or
             cloning. We introduce two notational variants of activity
             diagrams for modeling mobility. One variant is location
             centered and focuses on the topology of locations. The
             other one focuses on the actor responsible for an
             activity. We compare these two types of diagrams and
             define a metamodel for them.",
  folder =    "Edinburgh 2003"
}


@InCollection{Cardelli:99:MobilitySecurity,
  author = 	 "Cardelli, Luca",
  title = 	 "Mobility and Security",
  booktitle = 	 "Foundations of Secure Computation",
  pages = 	 "1--37",
  publisher =    pub-IOS,
  year = 	 2000,
  editor = 	 "Bauer, Friedrich L. and Steinbrueggen, Ralf",
  volume = 	 175,
  series = 	 ser-NATO,
  abstract = "We discuss the computational aspects of wide area
             networks, and we describe various facets of a process
             calculus devised to embody mobility, security, and wide
             area network semantics. These lecture notes are an
             abridged version of [8, 11, 27, 12, 13].",
  OPTtype = 	 {},
  OPTnote = 	 "Volume for the 20th International Summer School on Foundations of Secure Computation, held in Marktoberdorf, Germany (1999)",
  annote = 	 {},
  folder =    "Edinburgh 03, Models"
}

@PhdThesis{Tofte:88:OpSemanticsPolyTypeInfer,
  author = 	 "Tofte, Mads",
  title = 	 "Operational Semantics and Polymorphic Type Inference",
  school = 	 {Department of Computer Science, University of Edinburgh},
  year = 	 1988,
  OPTtype = 	 {},
  OPTnote = 	 "Available as Technical Report CST-52-88",
  annote = 	 {},
  abstract = "Three languages with polymorphic type disciplines are
             discussed, namely the lambda-calculus with Milner's
             polymorphic type discipline; a language with imperative
             features (polymorphic references); and a skeletal module
             language with structures, signatures and functors. In
             each of the two first cases we show that the type
             inference system is consistent with an operational
             dynamic semantics.

             On the module level, polymorphic types correspond to
             signatures. There is a notion of principal
             signature. So-called signature checking is the module
             level equivalent of type checking. In particular, there
             exists an algorithm which either fails or produces a
             principal signature.",
  folder =    "Books + Theses 1"
}


@inproceedings{Clement:86:SimpleAppLangMiniML,
 author = {Cl\'ement, Dominique and Despeyroux, Thierry and Kahn, Gilles and Despeyroux, Jo{\"e}lle},
 title = {A Simple Applicative Language: {M}ini-{ML}},
 booktitle = {Proceedings of the 1986 ACM conference on LISP and functional programming},
 year = 1986,
 isbn = {0-89791-200-4},
 pages = "13--27",
 location = {Cambridge, Massachusetts, United States},
 doi = {http://doi.acm.org/10.1145/319838.319847},
 publisher = pub-ACM,
  annote = 	 {},
  folder =    "ISKS"
}

@InProceedings{Tofte:96:EssentialSMLModules,
  author = {Tofte, Mads},
  title = {Essentials of Standard {ML} Modules},
  booktitle = {Advanced Functional Programming, Second International School-Tutorial Text},
  pages = "208--238",
  year = 1996,
  editor = 	 "Launchbury, John and Meijer, Erik and Sheard, Tim",
  volume = 	 1129,
  series = 	 ser-LNCS,
  publisher = pub-SV,
  isbn = {3-540-61628-4},
  annote = 	 {},
  folder =    "ISKS"
}


@inproceedings{Elsman:99:StaticInterpreModules317800,
 author = {Elsman, Martin},
 title = {Static Interpretation of Modules},
 booktitle = {Proceedings of the fourth ACM SIGPLAN international conference on Functional programming (ICFP'99)},
 year = 1999,
 isbn = {1-58113-111-9},
 pages = "208--219",
 location = {Paris, France},
 doi = {http://doi.acm.org/10.1145/317636.317800},
 publisher = pub-ACM,
 annote = 	 {},
 folder =    "ISKS"
}


@Article{Fuh:90:TypeInferSubtypes,
  title =        "Type Inference with Subtypes",
  author =       "Fuh, You-Chin and Mishra, Prateek",
  journal = 	 j-THEO-CS,
  year = 	 1990,
  volume = 	 73,
  number = 	 2,
  pages =        "155--175",
  abstract =  "We extend polymorphic type inference to include
                 subtypes. This paper describes the following results:
                 \begin{itemize} \item We prove the existence of (i)
                 principal type property and (ii) syntactic completeness
                 of the type checker, for type inference with subtypes.
                 This result is developed with only minmal assumptions
                 on the underlying theory of subtypes. \item For a
                 particular ``structured'' theory of subtypes, those
                 engendered by coercions between type constants only, we
                 prove that prinipal types are compactly expressibly.
                 This suggests that a practical type checker for the
                 structured theory of subtypes is feasible. \item We
                 develop efficient algorithms for such a type checker.
                 There are two main algorithms: MATCH and CONSISTENT.
                 The first can be thought of as an extension to the
                 unification algorithm. The secod, which has no analogue
                 in conventional type inference, determines whether a
                 set of coercions is consistent. \end{itemize} Thus, an
                 extension of polymorphic type inference that
                 incorporates the ``structured'' theory of subtypes is
                 practical and yields greater polymorphic flexibility.
                 We have begun to work on an implementation.",
  folder =    "ISKS"
}

@Article{Morrisett:02:StackBasedTypeAssemLang,
  author = 	 "Morrisett, Greg and Crary, Karl and Glew, Neal and  Walker, David",
  title = 	 "Stack-Based Typed Assembly Language",
  journal = 	 j-FUNC-PROG,
  year = 	 2002,
  volume = 	 12,
  number = 	 1,
  pages = 	 "43--88",
  abstract = "This paper presents STAL, a variant of Typed Assembly
                 Language with constructs and types to support a
                 limited form of stack allocation. As with other
                 statically-typed low-level languages, the type system
                 of STAL ensures that a wide class of errors cannot
                 occur at run time, and therefore the language can be
                 adapted for use in certifying compilers where
                 security is a concern. Like the Java Virtual Machine
                 Language (JVML), STAL supports stack allocation of
                 local variables and procedure activation records, but
                 unlike the JVML, STAL does not pre-suppose fixed
                 notions of procedures, exceptions, or calling
                 conventions. Rather, compiler writers can choose
                 encodings for these high-level constructs using the
                 more primitive RISC-like mechanisms of
                 STAL. Consequently, some important optimizations that
                 are impossible to perform within the JVML, such as
                 tail call elimination or callee-saves registers, can
                 be easily expressed within STAL.", 
  url = "http://www-2.cs.cmu.edu/~crary/papers/2002/stal/stal.ps",
  folder = "ISKS" 
}

@InProceedings{Crary:99:TypeStrucLowLevelProgLang,
  author = 	 "Crary, Karl and Morrisett, Greg",
  title = 	 "Type Structure for Low-Level Programming Languages",
  booktitle =    "Proceedings of the 26th International Colloquium on 
                 Automata, Languages and Programming (ICALP'99)",
  pages = 	 "40--54",
  year = 	 1999,
  editor = 	 "Wiedermann, Jir\'{\i} and Boas, Peter van Emde and Nielsen, Mogens",
  volume = 	 1644,
  series = 	 ser-LNCS,
  publisher = pub-SV,
  isbn      = {3-540-66224-3},
  annote = 	 {},
  abstract = "Providing type structure for extremely low-level
             programming languages, such as assembly language, yields
             a number of important benefits for compiler and systems
             projects, where reliability and security are crucial
             concerns.  We discuss some of the issues involved in
             designing type systems for low-level languages, and
             identify some general principles that simplify
             constructing a proof of soundness.",
  url = "http://www-2.cs.cmu.edu/~crary/papers/1999/tal-tutorial/tutorial.ps.gz",
  folder = "ISKS" 
}

@InCollection{Schneider:01:LangBasedApproSecu,
  author =       "Schneider, Fred B. and Morriset, Greg and Harper, Robert",
  title =        "A Language-Based Approach to Security",
  URL =          "http://link.springer.de/link/service/series/0558/papers/2000/20000086.pdf",
  annote =       "High-level (but interesting) view at language-based
                 enforcement of security properties (namely safety
                 properties) and how the different approaches: In-lined
                 reference monitor (IRM, code rewriting), type systems
                 (e.g., Java, Typed Assemler Language (TAL) and
                 certifying compilers (e.g., proof-carrying code (PCC))
                 play hand in hand.",
  pages =        "86--101",
  booktitle =    "Informatics -- 10 Years Back, 10 Years Ahead",
  volume =       2000,
  year =         2001,
  editor =       "Wilhelm, Reinhard",
  publisher =    pub-SV,
  series =       ser-LNCS,
  folder = "ISKS"
}

@InProceedings{Necula:97:ProofCarryingCode,
  author =       "Necula, George C.",
  title =        "Proof-Carrying Code",
  booktitle =  {Proceedings of the 24rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'97)},
  pages = 	 "106--119",
  year = 	 1997,
  OPTaddress =      "Paris, France",
  publisher =    pub-ACM,
  abstract =     "This paper describes proof-carrying code (PCC), a
                 mechanism by which a host system can determine with
                 certainty that it is safe to execute a program supplied
                 (possibly in binary form) by an untrusted source. For
                 this to be possible, the untrusted code producer must
                 supply with the code a safety proof that attests to the
                 code's adherence to a previously defined safety policy.
                 The host can then easily and quickly validate the proof
                 without using cryptography and without consulting any
                 external agents. \par In order to gain preliminary
                 experience with PCC, we have performed several case
                 studies. We show in this paper how proof-carrying code
                 might be used to develop safe assembly-language
                 extensions of ML programs. In the context of this case
                 study, we present and prove the adequacy of concrete
                 representations for the safety policy, the safety
                 proofs, and the proof validation. Fi- nally, we briefly
                 discuss how we use proof-carrying code to develop
                 network packet filters that are faster than similar
                 filters developed using other techniques and are
                 formally guaranteed to be safe with respect to a given
                 operating system safety policy.",
  annote = 	 {},
  folder = "ISKS"
}

@InProceedings{Lee:97:ResearchPCCMobCodeSecurity,
  author = 	 "Lee, Peter and Necula, George C.",
  title = 	 "Research on Proof-Carrying Code for Mobile-Code Security",
  booktitle = "DARPA Workshop on Foundations for Secure Mobile Code",
  year = 	 1997,
  annote = 	 {},
  folder = "ISKS"
}

@Article{Aiken:99:IntroSetConstraintBasedProgAnaly,
  author = 	 "Aiken, Alexander",
  title = 	 "Introduction to Set Constraint-Based Program Analysis",
  journal = 	 "Science of Computer Programming",
  year = 	 1999,
  volume = 	 35,
  number = 	 2,
  pages = 	 "79--111",
  annote = 	 {},
  url = "http://www.cs.berkeley.edu/~aiken/publications/papers/scp99.ps",
  folder = "ISKS"
}

@InProceedings{Aiken:98:ToolkitConstrTypeConstraBasedProgAnaly,
  author = 	 {Aiken, Alexander and F{\"a}hndrich, Manuel and Foster, Jeffrey S. and Su, Zhendong},
  title = 	 "A Toolkit for Constructing Type- and Constraint-Based Program Analyses",
  booktitle =    "Proceedings of the 2nd International Workshop on Types in Compilation",
  pages = 	 "78--96",
  year = 	 1998,
  editor = 	 "Leroy, Xavier and Ohori, Atsushi",
  volume = 	 1473,
  series = 	 ser-LNCS,
  OPTaddress = 	 "Kyoto, Japan",
  publisher =    pub-SV,
  annote = 	 {},
  abstract = "BANE (the Berkeley Analysis Engine) is a publically
             available toolkit for constructing type- and
             constraint-based program analyses. We describe the goals
             of the project, the rationale for BANE's overall design,
             some examples coded in BANE, and briefly compare BANE
             with other program analysis frameworks.",
  url = "http://theory.stanford.edu/~aiken/publications/papers/tic98.ps",
  folder = "ISKS"
}

@InProceedings{Guzman:94:ExtendedTypeSystExceptions,
  author = 	 {Guzm\'an, Juan C. and Su\'arez, Asc\'ander},
  title = 	 "An Extended Type System for Exceptions",
  booktitle = 	 {Record of the 5th ACM SIGPLAN Workshop on ML and its Applications},
  pages =	 "127--135",
  year =	 1994,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 "Orlando, USA",
  OPTpublisher = {},
  OPTnote = 	 "Published by INRIA, Rapport de Recherche No 2265",
  annote = 	 {},
  folder = "ISKS"
}

@inproceedings{Tofte:98:BriefIntroRegions,
 author = "Tofte, Mads",
 title = "A Brief Introduction to Regions",
 booktitle = {Proceedings of the First International Symposium on Memory Management (ISMM'98)},
 year = 1998,
 isbn = {1-58113-114-3},
 pages = "186--195",
 OPTlocation = {Vancouver, British Columbia, Canada},
 doi = {http://doi.acm.org/10.1145/286860.286882},
 publisher = pub-ACM,
 abstract = "The paper gives an overview of region-based memory
            management. The emphasis of the paper is on the dynamic
            aspects of execution, specifically memory management. We
            illustrate how three static program analyses can be used
            for inferring memory management directives. They are
            region inference, physical size inference, and storage
            mode analysis . We describe these analyses for a skeletal
            language inspired by Standard ML. We also describe a
            region-based runtime system for the skeletal language,
            based on the runtime system of the ML Kit with Regions.",
  folder = "ISKS"
}

@Manual{Tofte:02:ProgrammingRegionsMLKit4,
  title = 	 "Programming with Regions in the {ML} {K}it (for Version 4)",
  author = 	 {Tofte, Mads and Birkedal, Lars and Elsman, Martin and Hallenberg, Niels and Olesen, Tommy H{\o}jfeld and Sestoft, Peter},
  organization = "IT University of Copenhagen",
  year = 	 2002,
  OPTnote = 	 {},
  annote = 	 {},
  folder =    "ISKS"
}

@Article{Tofte:97:RegionBasedMemManage,
  author = 	 "Tofte, Mads and Talpin, Jean-Pierre",
  title = 	 "Region-Based Memory Management",
  journal = 	 j-INFO-COMP,
  year = 	 1997,
  volume = 	 132,
  number = 	 2,
  pages = 	 "109--176",
  OPTnote = 	 {},
  annote = 	 {},
  folder =    "ISKS"
}


@InProceedings{Grossman:02:RegionBasedMemoryManageCyclone,
  author = 	 "Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James",
  title = 	 "Region-Based Memory Management in Cyclone",
  booktitle =    "Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'02)",
  pages = 	 "282--293",
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 "Berlin, Germany",
  publisher = pub-ACM,
  annote = 	 {},
  abstract = "Cyclone is a type-safe programming language derived from
              C. The primary design goal of Cyclone is to let
              programmers control data representation and memory
              management without sacrificing type-safety. In this
              paper, we focus on the region-based memory management of
              Cyclone and its static typing discipline. The design
              incorporates several advancements, including support for
              region subtyping and a coherent integration with stack
              allocation and a garbage collector. To support separate
              compilation, Cyclone requires programmers to write some
              explicit region annotations, but a combination of
              default annotations, local type inference, and a novel
              treatment of region effects reduces this burden. As a
              result, we integrate C idioms in a region-based
              framework. In our experience, porting legacy C to
              Cyclone has required altering about 8\% of the code; of
              the changes, only 6\% (of the 8\%) were region
              annotations.",
  folder = "ISKS"
}

@Manual{Grossman:03:CycloneUsersManual,
  title = 	 "Cyclone User's Manual (Version 0.6, September 2003)",
  author = 	 "Grossman, Dan and Morrisett, Greg and Wang, Yanling and Jim, Trevor and Hicks, Michael and Cheney, James",
  organization = {Cornell University and AT\&T Labs Research},
  year = 	 2003,
  annote = 	 {},
  folder = "ISKS"
}

@TechReport{Cardelli:98:AbstracMobCompu,
  author = 	 "Cardelli, Luca",
  title = 	 "Abstractions for Mobile Computation",
  institution =  "Microsoft Research",
  year = 	 1998,
  number = 	 "MSR-TR-98-34",
  abstract = "We discuss the difficulties caused by mobile computing
            and mobile computation over wide-area networks. We propose
            a unified framework for overcoming such difficulties.",
  annote = 	 "Predecessor of \cite{Cardelli:99:AbstracMobCompu}",
  url =       "ftp://ftp.research.microsoft.com/pub/tr/tr-98-34.ps",
  folder =    "ISKS"
}

@TechReport{Hennessy:98:ResourceAccessControlSystMobAmb,
  author = 	 "Hennessy, Matthew and Riely, James",
  title = 	 "Resource Access Control in Systems of Mobile Agents",
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 1998,
  number = 	 "1998:02",
  annote = 	 {},
  abstract = "We describe a typing system for a distributed
             pi-calculus which guarantees that distributed agents
             cannot access the resources of a system without first
             being granted the capability to do so. The language
             studied allows agents to move between distributed
             locations and to augment their set of capabilities via
             communication with other agents. The type system is based
             on the novel notion of a location type, which describes
             the set of resources available to an agent at a
             location. Resources are themselves equipped with
             capabilities, and thus an agent may be given permission
             to send data along a channel at a particular location
             without being granted permission to read data along the
             same channel. We also describe a tagged version of the
             language, where the capabilities of agents are made
             explicit in the syntax. Using this tagged language we
             define access violations as runtime errors and prove that
             well-typed systems are incapable of such errors.",
  url =    "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs021998.ps.Z",
  folder = "ISKS"
}

@TechReport{Hennessy:03:SafeDpiLangContrMobCode,
  author = 	 "Hennessy, Matthew and Rathke, Julian and Yoshida, Nobuko",
  title = 	 "Safe{D}pi: a Language for Controlling Mobile Code",
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 2003,
  number = 	 "2003:02",
  annote = 	 {},
  abstract = "SafeDpi is a distributed version of the picalculus, in
             which processes are located at dynamically created
             sites. Parametrised code may be sent between sites using
             so-called ports, which are essentially higher-order
             versions of picalculus communication channels. A host
             location may protect itself by only accepting code which
             conforms to a given type associated to the incoming
             port. We define a sophisticated static type system for
             these ports, which restrict the capabilities and access
             rights of any processes launched by incoming
             code. Dependent and existential types are used to add
             flexibility, allowing the behaviour of these launched
             processes, encoded as process types, to depend on the
             host's instantiation of the incoming code. We also show
             that a natural contextually defined behavioural
             equivalence can be characterised coinductively, using
             bisimulations based on typed actions. The
             characterisation is based on the idea of knowledge
             acquisition by a testing environment and makes explicit
             some of the subtleties of determining equivalence in this
             language of highly constrained distributed code.",
  url =    "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs022003.ps.Z",
  folder = "ISKS"
}

@TechReport{Jeffrey:02:FullyAbstrMayTestSemanConcObj,
  author = 	 "Jeffrey, Alan and Rathke, Julian",
  title = 	 "A Fully Abstract May Testing Semantics for Concurrent Objects",
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 2002,
  number = 	 "2002:03",
  annote = 	 "Introduction of extra operators as points of interaction",
  abstract = "This paper provides a fully abstract semantics for a
             variant of the concurrent object calculus. We define may
             testing for concurrent object components and then
             characterise it using a trace semantics inspired by UML
             interaction diagrams. The main result of this paper is to
             show that the trace semantics is fully abstract for may
             testing. This is the first such result for a concurrent
             object language.",
  url =    "ftp://ftp.informatics.sussex.ac.uk/pub/reports/compsci/cs032002.ps.Z",
  folder = "HOBisimulation"
}


@article{VanGabbeek:96:BranchingTimeAbstraBisimSeman,
 author = {van Gabbeek, Rob J. and Weijland, W. Peter},
 title = "Branching Time and Abstraction in Bisimulation Semantics",
 journal = j-ACM,
 volume = 43,
 number = 3,
 year = 1996,
 issn = {0004-5411},
 pages = "555--600",
 doi = {http://doi.acm.org/10.1145/233551.233556},
 publisher = pub-ACM,
 annote = 	 "",
 abstract = "In comparative concurrency semantics, one usually
            distinguishes between linear time and branching time
            semantic equivalences. Milner's notion of observatin
            equivalence is often mentioned as the standard example of
            a branching time equivalence. In this paper we investigate
            whether observation equivalence really does respect the
            branching structure of processes, and find that in the
            presence of the unobservable action $\tau$ of CCS this is
            not the case. Therefore, the notion of branching
            bisimulation equivalence is introduced which strongly
            preserves the branching structure of processes, in the
            sense that it preserves computations together with the
            potentials in all intermediate states that are passed
            through, even if silent moves are involved. On closed
            CCS-terms branching bisimulation congruence can be
            completely axiomatized by the single axion scheme:
            \[
            a.(\tau.(y+z)+y)=a.(y+z) 
            \]
            (where a ranges over all
            actions) and the usual loaws for strong congruence. We
            also establish that for sequential processes observation
            equivalence is not preserved under refinement of actions,
            whereas branching bisimulation is.For a large class of
            processes, it turns out that branching bisimulation and
            observation equivalence are the same. As far as we know,
            all protocols that have been verified in the setting of
            observation equivalence happen to fit in this class, and
            hence are also valid in the stronger setting of branching
            bisimulation equivalence.",
  folder = "Calculi 2"
}

@TechReport{Mitchell:96:ModalObserEquivProces,
  author = 	 "Mitchell, William P.~R. and Carlisle, David P.",
  title = 	 "Modal Observation Equivalence of Processes",
  institution =  {University of Manchester},
  year = 	 1996,
  number = 	 "UMCS-96-1-1",
  annote = 	 {},
  abstract = "This paper shows that many simulation equivalences over
             processes can be characterised by a single parameterised
             modal logic formula. For many equivalences ~ there is a
             parameterised modal logic formula f(t) such that for
             every pair of processes P and Q, P ~ Q if and only if P
             models f(Q). For any specific P the formula f(P) becomes
             a fix point formula of the normal modal logic K.

             Strong bisimulation equivalence was shown by Milner to be
             characterised in this way. This paper shows that
             simulation, complete simulation, ready simulation,
             2-nested simulation, weak bisimulation and congruence can
             also be characterised in this way.

             The paper constructs a template which can be used to
             generate a parameterised modal formula which is
             guaranteed to characterise a `sensible' simulation
             equivalence. Two infinite families of simulation
             equivalences are characterised in this way, both of which
             converge to strong bisimulation equivalence. The paper
             defines a similar template for weak simulation
             equivalences. This template is used to construct an
             infinite family of equivalences which converges to weak
             bisimulation equivalence, and another infinite family
             which converges to congruence.

             Any equivalence relation which contains strong
             bisimulation equivalence can be characterised in a weaker
             sense by K. If ~ contains strong bisimulation
             equivalence, then for each P there is an F(P) in K such
             that P ~ Q iff F(P) => F(Q) is a valid formula.

             The paper proves this for arbitrary ~ via the axiom of
             choice. The paper gives a specific construction for such
             an F(P) for trace, complete trace, failure trace, ready
             trace and possible future equivalence.",
  folder = "Calculi 2"
}

@InProceedings{Cardelli:98:MobileAmbients,
  author = 	 "Cardelli, Luca and Gordon, Andrew D.",
  title = 	 "Mobile Ambients",
  booktitle =    "Proceedings of the First International Conference of Foundations of Software Science and Computation Structures (FOSSACS'98)",
  pages = 	 "140--155",
  year = 	 1998,
  editor = 	 "Nivat, Maurice",
  volume = 	 1378,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "We introduce a calculus describing the movement of
             processes and devices, including movement through
             administrative domains.",
  annote = 	 {},
  folder =    "Models"
}



@TechReport{Abadi:98:CalcCrypProtocolsSPI,
  author = 	 {Abadi, Mart\'{\i}n and Gordon, Andrew D.},
  title = 	 "A Calculus for Cryptographic Protocols: The Spi Calculus",
  institution =  "Digital Equipment Corporation Systems Research Center",
  year = 	 1998,
  type = 	 "Research Report",
  number = 	 149,
  annote = 	 {},
  abstract = "We introduce the spi calculus, an extension of the pi
             calculus designed for describing and analyzing
             cryptographic protocols. We show how to use the spi
             calculus, particularly for studying authentication
             protocols. The pi calculus (without extension) suffices
             for some abstract protocols; the spi calculus enables us
             to consider cryptographic issues in more detail. We
             represent protocols as processes in the spi calculus and
             state their security properties in terms of
             coarse-grained notions of protocol equivalence.",
  url =          "ftp://gatekeeper.research.compaq.com/pub/DEC/SRC/research-reports/SRC-149.ps.gz",
  folder =    "Calculi 1"
}

@inproceedings{Pierce:93:TypingSubtypForMobProcesses,
  author = "Pierce, Benjamin C. and Sangiorgi, Davide",
  title = "Typing and Subtyping for Mobile Processes",
  booktitle = "Proceedings of the 8th {IEEE} Symposium on Logic in Computer Science (LICS'93)",
  OPTaddress = "Montreal, Canada",
  pages = "376--385",
  year = 1993,
  abstract = "The pi-calculus is a process algebra that supports
             process mobility by focusing on the communication of
             channels.

             Milner's presentation of the pi-calculus includes a type
             system assigning arities to channels and enforcing a
             corresponding discipline in their use. We extend Milner's
             language of types by distinguishing between the ability
             to read from a channel, the ability to write to a
             channel, and the ability both to read and to write. This
             refinement gives rise to a natural subtype relation
             similar to those studied in typed lambda-calculi.

             The greater precision of our type discipline yields
             stronger versions of some standard theorems about the
             pi-calculus. These can be used, for example, to obtain
             the validity of beta-reduction for the more efficient of
             Milner's encodings of the call-by-value lambda-calculus,
             for which beta-reduction does not hold in the ordinary
             pi-calculus.
 
             We define the syntax, typing, subtyping, and operational
             semantics of our calculus, prove that the typing rules
             are sound, apply the system to Milner's lambda-calculus
             encodings, and sketch extensions to higher-order process
             calculi and polymorphic typing.",
  annote = "Uses a mismatch operator to prove the equational theories
           for strong late bisimilarity complete over finite
           processes. The mismatch operator gives the axiom system
           great flexibility and generality. ????",
  url = "http://www.cis.upenn.edu/~bcpierce/papers/pi.ps",
  folder =    "Calculi 2"
}

@InCollection{Pitts:98:OperatReasoningFuncLocalState,
  author =       {Pitts, Andrew M. and Stark, Ian},
  title =        {Operational Reasoning for Functions with Local
                  State}, 
  booktitle =    {Higher Order Operational Techniques in Semantics},
  editor =       {Gordon, Andrew D. and Pitts, Andrew M.},
  year =         1998,
  pages =        {227--273},
  publisher =    {Publications of the Newton Institute, Cambridge
                  University Press}, 
  url =          {http://www.ed.ac.uk/~stark/operfl.html},
  abstract = "Languages such as ML or Lisp permit the use of
              recursively defined function expressions with locally
              declared storage locations. Although this can be very
              convenient from a programming point of view it severely
              complicates the properties of program equivalence even
              for relatively simple fragments of such languages - such
              as the simply typed fragment of Standard ML with
              integer-valued references considered here. This paper
              presents a method for reasoning about \emph{contextual
              equivalence} of programs involving this combination of
              functional and procedural features. The method is based
              upon the use of a certain kind of \emph{logical relation}
              parameterised by relations between program states. The
              form of this logical relation is novel, in as much as it
              involves relations not only between program expressions,
              but also between program continuations (also known as
              \emph{evaluation contexts}). The authors found this approach
              necessary in order to establish the `Fundamental
              Property of logical relations' in the presence of both
              dynamically allocated local state and recursion. The
              logical relation characterises contextual equivalence
              and yields a proof of the best known context lemma for
              this kind of language - the Mason-Talcott `ciu'
              theorem. Moreover, it is shown that the method can prove
              examples where such a context lemma is not much help and
              which involve representation independence, higher order
              memoising functions, and profiling functions.",
  annote = 	 "",
  folder =    "HOBisimulation"
}

@techreport{Pitts:94:NotesInducCoinducTechSemanFuncProg,
  author = 	 "Pitts, Andrew M.",
  title = 	 "Some Notes on Inductive and Co-Inductive
                  Techniques in the Semantics of Functional
                  Programs, {\em DRAFT VERSION}",
  institution =  uni-BRICS,
  year = 	 1994,
  type = 	 "Notes Series",
  number = 	 "NS-94-5",
  address = 	 addr-daimi,
  note = 	 "vi+135 pp",
  abstract = 	 "These notes were handed out at a course on
                  {\em Inductive and Co-Inductive Techniques in
                  the Semantics of Functional Programs} given by
                  Andrew Pitts, The Computer Laboratory,
                  Cambridge University, while visiting BRICS 21
                  November -- 2 December 1994. The course
                  material included these notes, the report {\em
                  Relational Properties of Domains} and
                  slides.\\
                  {\bf Course Description}\\
                  The aim of the course is to describe recent
                  advances in formal techniques for establishing
                  observational equivalence of functional
                  programs. It considers both operational and
                  denotational methods and the relationship
                  between them. One goal is to give an exposition
                  of Howe's method for characterizing
                  observational equivalence as a co-inductively
                  defined ``applicative bisimulation''. Another
                  goal is to describe Freyd's analysis of
                  recursively defined domains in terms of a
                  property of mixed initiality/finality.
                  Applications of this are given to proving
                  correspondence of operational and denotational
                  semantics and to inductive and co-inductive
                  reasoning about ``user-declared'' datatypes.",
  annote = 	 "Handwritten notes",
  folder =    "Div 2"
}




%%% IMDD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@Manual{Victor:95:MobilityWorkbenchUserGuide,
  title = 	 "The Mobility Workbench User's Guide: Polyadic version 3.122",
  author = 	 "Victor, Bj{\"o}rn",
  organization = {Department of Information Technology, Uppsala University},
  year = 	 1995,
  annote = 	 {},
  folder =    "Teaching 1"
}

@Manual{Moller:99:EdinbConcurrencyWBUserManual,
  title =	 {Edinburgh Concurrency Workbench User Manual (Version 7.1)}, 
  author =	 {Moller, Faron and Stevens, Perdita},
  organization = "Laboratory for Foundations of Computer Science, University of Edinburgh",
  year = 	 1999,
  note = {Available from http://www.dcs.ed.ac.uk/home/cwb/},
  annote = 	 {},
  folder =    "Teaching 1"
}

@MastersThesis{Beste:1998:ModelProver,
  author = 	 "Beste, Fredrick B.",
  title = 	 "The Model Prover --- a sequent-calculus based modal $\mu$-calculus model checker tool for finite control $\pi$-calculus agents",
  school = 	 "Department of Computer Systems, Uppsala University",
  year = 	 1998,
  note = 	 "Available as report {DoCS 98/97}",
  annote = 	 "The model checker in MWB.",
  abstract = "The $\pi$-calculus offers some very good properites for
             describing dynamic, distributed communicating
             systems. The modal $\mu$-calculus offers ways of
             describing properties for infinite processes and their
             behaviour. The Mobility Workbench (MWB) is equipped with
             methods of deciding bisimulation equivalences for
             $\pi$-calculus agents. We present a sequent-calculus
             based model checker tool for the MWB. We also introduce
             the basic theory therefore, the $\lambda$-calculus and
             CCS for algebraic description of processes, and modal and
             temporal logics for expressing properties of process
             behaviour, and also the classic sequent-calculus
             originating from the 1930's. Model checkers and
             bisimulation checkers are fundamental tools for the
             research area of Formal Methods, a branch of Computer
             Science that deals with verification of computer software
             by mathematical and automated reasoning as a way for
             designing and verifying software.",
  folder =    "Teaching 1"
}

@PhdThesis{Victor:94:VerificationToolPolyPiCalc,
  author = 	 "Victor, Bj{\"o}rn",
  title = 	 "A Verification Tool for the Polyadic $\pi$-Calculus",
  school = 	 "Department of Computer Systems, Uppsala University",
  year = 	 1994,
  type =	 "Licentiate thesis",
  note =	 "Available as report {DoCS 94/50}",
  annote =    "",
  abstrct = "This thesis describes the polyadic version of the
            Mobility Workbench (MWB), an automated tool for
            manipulating and analyzing mobile concurrent systems
            (those with evolving connectivity structures) described in
            the polyadic pi-calculus. The main feature of this version
            of the MWB is checking open bisimulation equivalences, and
            doing so with efficiency in mind.

            The open bisimulation equivalences are described in a
            polyadic setting, and efficient characterisations of both
            the strong and the weak equivalences are presented and
            proven to coincide with their standard formulations.

            The equivalence checking algorithm, which by necessity
            generates the state space ``on-the-fly'', is presented in
            detail and proven correct. Aspects of the implementation
            of the tool are described in some detail, for example the
            representation of pi-calculus agents using de Bruijn
            indices.

            We illustrate the MWB with an example automated analysis
            of a handover protocol for a mobile telephone system.",
  folder =    "Teaching 1"
}

@TechReport{Victor:94:MobilityWorkbenchToolPiCalc,
  author = 	 "Victor, Bj{\"o}rn and Moller, Faron",
  title = 	 "The Mobility Workbench --- A Tool for the $\pi$-Calculus",
  institution =  "Department of Computer Systems, Uppsala University",
  year = 	 1994,
  number =	 "DoCS 94/45",
  note =	 "Also available as Technical Report ECS-LFCS-94-285, 
		  Laboratory for Foundations of Computer Science, 
		  Department of Computer Science, University of Edinburgh",
  annote = 	 "",
  abstract = "In this paper we describe the first prototype version of
             the Mobility Workbench (MWB), an automated tool for
             manipulating and analyzing mobile concurrent systems
             (those with evolving connectivity structures) described
             in the pi-calculus. The main feature of this version of
             the MWB is checking open bisimulation equivalences. We
             illustrate the MWB with an example automated analysis of
             a handover protocol for a mobile telephone system.",
  folder =    "Teaching 1"

}

@InCollection{Cleaveland:99:ProcessAlgebra,
  author =    "Cleaveland, Rance and Smolka, Scott",
  title =        "Process Algebra",
  booktitle =    "Encyclopedia of Electrical Engineering",
  OPTpages =     {},
  publisher = pub-WILEY,
  year =      1999,
  editor =    "Webster, John G.",
  OPTtype =      {},
  OPTchapter =   {},
  OPTaddress =   {},
  OPTedition =   {},
  OPTmonth =     {},
  url = "http://www.cs.sunysb.edu/~rance/publications/papers/ee99.ps.gz",
  annote =    {},
  abstract = "Process algebra represents a mathematically rigorous
             framework for modeling concurrent systems of interacting
             processes. The process-algebraic approach relies on
             equational and inequational reasoning as the basis for
             analyzing the behavior of such systems. This chapter
             surveys some of the key results obtained in the area
             within the setting of a particular process-algebraic
             notation, the Calculus of Communicating Systems (CCS) of
             Milner. In particular, the Structural Operational
             Semantics approach to defining operational behavior of
             languages is illustrated via CCS, and several operational
             equivalences and refinement orderings are
             discussed. Mechanisms are presented for deducing that
             systems are related by the equivalence relations and
             refinement orderings, and different process-algebraic
             modeling formalisms are briefly surveyed.", 
  folder = "Teaching 1"
}



@PhdThesis{Zappa:03:SemanHOProcesses,
  author = 	 "Nardelli, Francesco Zappa",
  title = 	 "Semantics of Higher-Order Processes",
  school = 	 {Universit\'e Paris 7 Denis Diderot, UFR D'Informatique},
  year = 	 2003,
  abstract = "This PhD dissertation addresses the theories underlying
             the mobile computation, with the aim to develop
             mathematical tools to express and reason about mobile
             systems.

            We studied the impact that mobility of active computations
            has on the observational congruence, and in general on the
            equational theory of a process language. In particular, we
            focused on two process calculi, namely the Seal Calculus
            and the Ambient Calculus, that offer two opposite models
            of mobile computation. In both cases, we found a
            coinductive characterisation of observational congruence:
            these results not only originate powerful proof methods to
            prove the equivalence of two systems, but also highlight
            peculiarities of the two models of mobility. In the case
            of the Ambient Calculus, the characterisation is complete:
            this important result required the development of
            techniques to deal with asynchronous mobility and
            ``stuttering'' phenomena. Also, we showed the soundness of
            up-to proof techniques in the presence of higher-order
            computation.

            We also studied presheaf categories as a general model of
            concurrency. We gave an operational reading of a presheaf
            category suitable to describe higher-order process and
            name generation. This led us to a compact but expressive
            language, called new-HOPLA, that directly encodes a rich
            variety of process languages. The language is typed, and
            the type of a term describes the shape of the computation
            paths it can perform. The operational theory of the
            metalanguage has also been developed, and the resulting
            operational equivalence theory has been investigated. The
            metalanguage has been used to give semantics to rich
            process algebras like pi-calculus and Mobile Ambients.",
  annote = 	 {},
  url = "ftp://ftp.di.ens.fr/pub/users/zappa/readings/fzn_phd.pdf",
  folder =    "Books + Theses 1"
}


@Article{Milner:92:FuncAsProcesses,
  author = 	 "Milner, Robin",
  title = 	 "Functions as Processes",
  journal = 	 j-MAT-STRUCT,
  year = 	 1992,
  volume = 	 2,
  number = 	 2,
  pages = 	 "119--141",
  abstract = "Exhibits accurate encodings of the lambda-calculus in
             the pi-calculus. The former is canonical for calculation
             with functions, while the latter is a recent step towards
             a canonical treatment of concurrent processes. With quite
             simple encodings, two lambda-calculus reduction
             strategies are simulated very closely; each reduction in
             lambda-calculus is mimicked by a short sequence of
             reductions in pi-calculus. Abramsky's precongruence of
             applicative simulation over lambda-calculus is compared
             with that induced by the encoding of the lazy
             lambda-calculus into pi-calculus; a similar comparison is
             made for call-by-value lambda-calculus.

             The part of pi-calculus which is needed for the encoding
             is formulated in a new way, inspired by Berry's and
             Boudol's Chemical Abstract Machine (1990)",
  annote = 	 "A guideline for definition of reduction systems",
  folder =	 "Calculi 1"
}

@InProceedings{Park:81:ConcurAutomataInfiniteSeq,
  author =       "Park, David",
  title =        "Concurrency and Automata on Infinite Sequences",
  booktitle =    "Proceedings of the 5th {GI}-Conference on Theoretical Computer Science",
  editor =       "Deussen, Peter",
  year =         1981,
  OPTmonth =        mar,
  publisher =    pub-SV,
  series =       ser-LNCS,
  volume =       104,
  pages =        "167--183",
  annotate =     "",
  folder =    "HOBisimulation"
}

@Article{Milner:96:CalcForInteraction,
  author = 	 "Milner, Robin",
  title = 	 "Calculi for Interaction",
  journal = 	 j-ACTA-INFORM,
  year = 	 1996,
  volume = 	 33,
  number = 	 8,
  pages = 	 "707--737",
  annote = 	 {},
  abstract = "Action structures have previously been proposed as an
             algebra for both the syntax and the semantics of
             interactive computation. Here, a class of concrete action
             structures called action calculi is identified, which can
             serve as a non-linear syntax for a wide variety of models
             of interactive behaviour. Each action in an action
             calculus is represented as an assembly of molecules; the
             syntactic binding of names is the means by which
             molecules are bound together. A graphical form, action
             graphs, is used to aid presentation. One action calculus
             differs from another only in its generators, called
             controls.

             Action calculi generalise a previously defined action
             structure PIC for the ss-calculus. Several extensions to
             PIC are given as action calculi , giving essentially the
             same power as the ss- calculus. An action calculus is
             also given for the typed *-calculus, and for Petri nets
             parametrized on their places and transitions.

             An equational characterization of action calculi is
             given: each action calculus A is the quotient of a term
             algebra by certain equations. The terms are generated by
             a set of operators, including those basic to all action
             structures as well as the controls specific to A; the
             equations are the basic axioms of action structures
             together with four additional axiom schemata.",
  folder =    "Bigraphs"
}


@TechReport{Leifer:02:SyntheLabelTransOperCongReacSystPart1,
  author = 	 "Leifer, James J.",
  title = 	 "Synthesising Labelled Transitions and Operational Congruences in Reactive Systems, Part 1",
  institution =  "INRIA",
  year = 	 2002,
  type = 	 "Research Report",
  number = 	 4394,
  abstract = "The dynamics of process calculi, e.g. CCS, have often
             been defined using a labelled transition system
             (LTS). More recently it has become common when defining
             dynamics to use reaction rules ---i.e. unlabelled
             transition rules--- together with a structural
             congruence. This form, which I call a reactive system, is
             highly expressive but is limited in an important way:
             LTSs lead more naturally to operational equivalences and
             preorders. This paper shows how to synthesise an LTS for
             a wide range of reactive systems. A label for an agent
             (process) `a' is defined to be any context `F' which
             intuitively is just large enough so that the agent `Fa'
             (`a' in context `F') is able to perform a reaction
             step. The key contribution of my work is the precise
             definition of ``just large enough'' in terms of the
             categorical notion of relative pushout (RPO). I then
             prove that several operational equivalences and preorders
             (strong bisimulation, weak bisimulation, the traces
             preorder, and the failures preorder) are congruences when
             sufficient RPOs exist.",
  annote = 	 {},
  folder =    "Bigraphs"
}


@TechReport{Leifer:02:SyntheLabelTransOperCongReacSystPart2,
  author = 	 "Leifer, James J.",
  title = 	 "Synthesising Labelled Transitions and Operational Congruences in Reactive Systems, Part 2",
  institution =  "INRIA",
  year = 	 2002,
  type = 	 "Research Report",
  number = 	 4395,
  abstract = "This paper is the second in a series of two. It relies
             on its companion, Part 1, to motivate the central problem
             addressed by the series, namely: how to synthesise
             labelled transitions for reactive systems and how to
             prove congruence results for operational equivalences and
             preorders defined above those transitions. The purpose of
             this paper is (i) to show that the hypotheses required of
             functorial reactive systems from Part 1, for example the
             sliding properties of IPO (idem pushout) squares, are
             indeed satisfied for functors of a general form; (ii) to
             illustrate an example of a functorial reactive system
             based on Milner's action calculi, which satisfy the RPO
             (relative pushout) hypothesis required in the proofs of
             congruence from Part 1.",
  annote = 	 {},
  folder =    "Bigraphs"
}


@Article{Hennessy:85:AlgebraLawsNondetermConcu,
  author = 	 "Hennessy, Matthew and Milner, Robin",
  title = 	 "Algebraic Laws for Nondeterminism and Concurrency",
  journal = 	 j-ACM,
  year = 	 1985,
  volume = 	 32,
  number = 	 1,
  pages = 	 "137--161",
  doi = {http://doi.acm.org/10.1145/2455.2460},
  abstract = "Since a nondeterministic and concurrent program may, in
             general, communicate repeatedly with its environment, its
             meaning cannot be presented naturally as an input/output
             function (as is often done in the denotational approach
             to semantics). In this paper, an alternative is put
             forth. First, a definition is given of what it is for two
             programs or program parts to be equivalent for all
             observers; then two program parts are said to be
             observation congruent iff they are, in all program
             contexts, equivalent. The behavior of a program part,
             that is, its meaning, is defined to be its observation
             congruence class. 

             The paper demonstrates, for a sequence of simple
             languages expressing finite (terminating) behaviors, that
             in each case observation congruence can be axiomatized
             algebraically. Moreover, with the addition of recursion
             and another simple extension, the algebraic language
             described here becomes a calculus for writing and
             specifying concurrent programs and for proving their
             properties.",
  annote = 	 {},
  folder =    "Calculi 1"
}

@incollection{Abramsky:90:LazyLambdaCalc,
  author = "Abramsky, Samson",
  title = "The Lazy Lambda Calculus",
  booktitle = "Research Topics in Functional Programming",
  publisher = pub-AW,
  OPTaddress = "Reading, MA",
  editor = "Turner, David A.",
  isbn = "0-201-17236-4",
  pages = "65--117",
  year = 1990,
  url = "citeseer.nj.nec.com/abramsky90lazy.html",
  annote = "",
  folder =	"HOBisimulation"
}


@TechReport{Kobayashi:99:QuasilinearTypes,
  author = "Kobayashi, Naoki",
  title = "Quasi-Linear Types",
  institution =  "Department of Information Science, University of Tokyo",
  year = 	 1998,
  number = 	 "TR98-02",
  OPTaddress = 	 {},
  note = 	 "revised version",
  abstract = "Linear types (types of values that can be used just
             once) have been drawing a great deal of attention because
             they are useful for memory management, in-place update of
             data structures, etc.: an obvious advantage is that a
             value of a linear type can be immediately deallocated
             after being used. However, the linear types have not been
             applied so widely in practice, probably because linear
             values (values of linear types) in the traditional sense
             do not so often appear in actual programs. In order to
             increase the applicability of linear types, we relax the
             condition of linearity by extending the types with
             information on an evaluation order and simple dataflow
             information. The extended type system, called a
             quasi-linear type system, is formalized and its
             correctness is proved. We have implemented a prototype
             type inference system for the core-ML that can
             automatically find out which value is linear in the
             relaxed sense. Promising results were obtained from
             preliminary experiments with the prototype system.",
  annote = 	 {},
  folder =    "Div 1"
}


@Unpublished{Boudol:02:ModelsDistMobStateOfTheArt,
  author = {Boudol, G{\'e}rard and Castellani, Ilaria and Germain, Florence and Lacoste, Marc},
  title = {Distributed calculi and languages for mobility: State of the Art},
  abstract = "This document presents a comparative analysis of various
             models and languages for mobile code, incorporating some
             notion of site or more generally of domain. These models
             and languages will be referred to as distributed mobile
             calculi. Our study will focus on three aspects of these
             calculi: distribution, mobility and security. Moreover,
             it will emphasize the notion of domain as a primitive
             programming concept and illustrate its semantics in the
             various calculi.",
  year = 2002, 
  note = {Mikado Deliverable D1.1.1}, 
  url = {http://mikado.di.fc.ul.pt/repository/D1.1.1v1.0.pdf},
  OPTannotate = "",
  folder = "Models"
}


@Article{Fournet:01:BisimulationsJoinCalc,
  author = 	 "Fournet, C{\'e}dric and Laneve, Cosimo",
  title = 	 "Bisimulations in the Join-Calculus",
  journal = 	 j-THEO-CS,
  year = 	 2001,
  volume = 	 266,
  number = 	 "1--2",
  pages = 	 "569--603",
  url = 	 "http://research.microsoft.com/~fournet/papers/bisimulations-in-the-join-calculus.ps",
  abstract = "We develop a theory of bisimulations in the join
              calculus. We introduce a refined operational model that
              makes interactions with the environment explicit, and
              discuss the impact of the lexical scope discipline of
              the join calculus on its extensional semantics. We
              propose several formulations of bisimulation and
              establish that all formulations yield the same
              equivalence. We prove that this equivalence is finer
              than barbed congruence, but that both relations coincide
              in the presence of name matching.",
  OPTnote = 	 {},
  annote = 	 {},
  folder =    ""
}

@Article{Milner:83:CalcSyncAsync,
  author = 	 "Milner, Robin",
  title = 	 "Calculi for Synchrony and Asynchrony",
  journal = 	 j-THEO-CS,
  year = 	 1983,
  volume = 	 25,
  number = 	 3,
  pages = 	 "267--310",
  abstract = "A calculus for distributed computation is studied, based
             upon four combinators. A central idea is an Abelian group
             of actions which models the interfaces between components
             of a distributed computing agent. Using a notion of
             bisimulation, congruence relations are defined over
             computing agents, and thence an algebraic theory is
             derived. The calculus models both synchronous and
             asynchronous computation. In particular, it is shown that
             the author's Calculus of Communicating Systems (1980),
             which is an asynchronous model, is derivable from the
             calculus presented here.",
  annote = 	 "Sangiogi references this wrt. bisimulation, also reference wrt. maximal fixed points",
  folder = "Calculi 1"
}


@Article{Milner:91:CoInducRelatSeman,
  author = 	 "Milner, Robin and Tofte, Mads",
  title = 	 "Co-induction in Relational Semantics",
  journal = 	 j-THEO-CS,
  year = 	 1991,
  volume = 	 87,
  number = 	 1,
  pages = 	 "209--220",
  abstract = "An application of the mathematical theory of maximum
             fixed points of monotonic set operators to relational
             semantics is presented. It is shown how an important
             proof method which we call co-induction , a variant of
             Park's (1969) principle of fixpoint induction, can be
             used to prove the consistency of the static and the
             dynamic relational semantics of a small functional
             programming language with recursive functions.",
  annote = 	 {},
  folder = "Div 1"
}



@InProceedings{Milner:94:HOActionCalculi,
  author = 	 {Milner, Robin},
  title = 	 "Higher-Order Action Calculi",
  booktitle =    "Proceedings of the 7th Workshop on Computer Science Logic (CSL'93), Selected Papers",
  pages = 	 "238--260",
  year = 	 1994,
  editor = 	 {Egon B{\"o}rger and Yuri Gurevich and Karl Meinke},
  volume =       832,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  annote = 	 {},
  folder =    "Bigraphs"
}



@InProceedings{Milner:93:ActionStructuresAndPiCalc,
  author = 	 {Milner, Robin},
  title = 	 {Action Structures and the Pi-Calculus},
  booktitle =    "Proceedings of the {NATO} Summer School on Logic and 
                 Computation",
  OPTpages = 	 {},
  year = 	 1993,
  address =      "Marktoberdorf",
  OPTnote = 	 {},
  annote = 	 {},
  abstract = "In a previous paper, action structures were proposed as
             a variety of algebra to underlie concrete models of
             concurrent computation and interaction. That work is
             summarised here, to make the paper self-contained. In
             particular, the uniform construction of a process
             calculus upon an arbitrary action structure is
             reviewed. Another relevant concept from the previous
             paper is recalled, namely the notion of incident set. Its
             importance is that, in the process calculus uniformly
             constructed upon any action structure, a bisimulation
             equivalence which rests upon an incident set is
             guaranteed to be a congruence for the calculus.

             The main purpose of this paper is to give a family of
             action structures for the Pi-calculus. Using one of
             these, the original Pi-calculus is obtained by the
             uniform construction. The most substantial technical
             element here is the construction of an appropriate
             incident set for this action structure, yielding a
             bisimulation congruence for the Pi-calculus.

             Another action structure is used to provide (again via
             the uniform construction) a synchronous version of the
             Pi-calculus, in the sense that MEIJE or SCCS is a
             synchronous version of CCS. The natural version of this
             action structure contains an anomaly which appears to
             prevent the existence of the appropriate incident
             set. However, a so-called reflexive version of the action
             structure does indeed yield a natural incident set, and
             thereby again a bisimulation congruence.

             Two innovations are noteworthy. One is the definition of
             reflexive substitution. With this new kind of
             substitution, restricting a port-name x (in the sense of
             CCS) amounts to ``making x denote itself'' --
             i.e. reflexively substituting x for itself. This notion
             simplifies the action structure for the synchronous
             Pi-calculus. The second innovation is that the action
             structures are presented graphically, giving a new
             perspective on the Pi-calculus. Indeed, both definition
             and proof of the incident set for the reflexive
             Pi-calculus are in terms of a simple graph-theoretic
             notion of reachability.",
  folder =    "Bigraphs"
}


@InCollection{Castellani:01:ProcessAlgLocalities,
  author = 	 "Ilaria Castellani",
  title = 	 "Process Algebras with Localities",
  booktitle = 	 "Handbook of Process Algebra",
  pages = 	 "945--1045",
  publisher =    pub-ESP,
  year = 	 2001,
  editor = 	 "Bergstra, Jan A. and Ponse, Alban and Smolka, Scott",
  chapter = 	 15,
  annote = "",
  abstract = "Process algebras can be enriched with localities that
             explicitly describe the distribution of
             processes. Localities may represent physical machines, or
             more generally distribution units where processes are
             grouped according to some criterion like the sharing of
             resources. In a concurrent process, localities are
             naturally associated with (groups of) parallel
             components. These localities then intervene in the
             semantics of processes and become part, to some extent,
             of their observable behaviour. In a first line of
             research, initiated in the early nineties, localities
             have been used to give noninterleaving semantics for
             process algebras, and particularly for Milner's calculus
             CCS. Here localities are used to differentiate parallel
             components. The resulting semantics, taking into account
             distribution, is more discriminating than the standard
             interleaving semantics of the calculus. It is also
             incomparable with other noninterleaving semantics
             proposed for CCS, based on the notion of causality. More
             recently, localities have appeared in a number of new
             calculi for describing mobile processes. The idea here is
             that some ``network awareness'' is required to model
             wide-area distributed mobile computation. In these
             calculi localities are more than simple units of
             distribution. According to the case, they become units of
             failure, of communication, of migration or of
             security. This chapter reviews in some detail the first
             body of work, and tries to delineate the main ideas of
             the more recent studies, which are still, for the most
             part, at an early stage of development.",
  folder = "Locations"
}


@InProceedings{Sangiorgi:01:ExtenIntenAmbientLogics,
  author = 	 "Sangiorgi, Davide",
  title = "Extensionality and Intensionality of the Ambient Logics",
  booktitle = "Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL' 01)",
  pages = "4--13", 
  year = 	 2001,
  location = {London, United Kingdom},
  doi = {http://doi.acm.org/10.1145/360204.375707},
  publisher = pub-ACM,
  abstract = "The ambient logic has been proposed for expressing
             properties of process mobility in the calculus of Mobile
             Ambients (MA), and as a basis for query languages on
             semistructured data.

             To understand the extensionality and the intensionality
             of the logic, the equivalence on MA processes induced by
             the logic (=L) is compared with the standard MA
             behavioural equivalence and with structural congruence
             (an intensional equivalence, used as an auxiliary
             relation in the definition of satisfaction of the
             logic). The main contributions include a co-inductive
             characterisation of <=L as a form of labelled
             bisimilarity, and axiomatisations of <=L on the
             synchronous and asynchronous (finite) calculus.

             The study shows that, surprisingly, the logic allows us
             to observe the internal structure of the processes at a
             very fine-grained detail, much in the same way as
             structural congruence does. A spin-off of the study is a
             better understanding of behavioural equivalence in
             Ambient-like calculi. For instance, behavioural
             equivalence is shown to be insensitive to stuttering
             phenomena originated by processes that may repeatedly
             enter and exit an ambient.",
  annote = "",
  folder = "Calculi 2"
}

@InCollection{Glabbeek:01:LinearBranchingTimeSpectrum,
  author = 	 "Glabbeek, Rob J. van",
  title = 	 "The Linear Time - Branching Time Spectrum {I}",
  booktitle = 	 "Handbook of Process Algebra",
  pages = 	 "3--99",
  publisher =    pub-ESP,
  year = 	 2001,
  editor = 	 "Bergstra, Jan A. and Ponse, Alban and Smolka, Scott",
  chapter = 	 1,
  annote = 	 {},
  abstract = "In this paper various semantics in the linear time --
             branching time spectrum are presented in a uniform,
             model-independent way. Restricted to the class of
             finitely branching, concrete, sequential processes, only
             fifteen of them turn out to be different, and most
             semantics found in the literature that can be defined
             uniformly in terms of action relations coincide with one
             of these fifteen. Several testing scenarios, motivating
             these semantics, are presented, phrased in terms of
             `button pushing experiments' on generative and reactive
             machines. Finally twelve of these semantics are applied
             to a simple language for finite, concrete, sequential,
             nondeterministic processes, and for each of them a
             complete axiomatization is provided.

             Keywords: Concurrency, Labelled transition systems,
             Nondeterminism, Semantic equivalences, Linear time,
             Branching time, Generative and reactive systems, Button
             pushing experiments, Modal Characterizations, Relational
             Characterizations, Trace semantics, Failures semantics,
             Failure trace, Ready trace, Simulation, Ready simulation,
             Bisimulation, Complete axiomatizations, Compositionality,
             Full abstraction, Renaming, Deadlock, Termination,
             Sequencing, Recursive Specification Principle,
             Non-well-founded sets.",
  folder =    "Calculi 1"
}


@InCollection{Parrow:01:IntroToPiCalc,
  author = 	 "Parrow, Joachim",
  title = 	 "An Introduction to the $\pi$-Calculus",
  booktitle = 	 "Handbook of Process Algebra",
  pages = 	 "479--543",
  publisher =    pub-ESP,
  year = 	 2001,
  editor = 	 "Bergstra, Jan A. and Ponse, Alban and Smolka, Scott",
  chapter = 	 8,
  annote = 	 {},
  abstract = "The $\pi$-calculus is a process algebra where processes
             interact by sending communication links to each
             other. This paper is an overview of and introduction to
             its basic theory. We explore the syntax, semantics,
             equivalences and axiomatisations of the most common
             variants.",
  folder =    "Teaching 1"
}


@TechReport{Hennessy:92:SymbolicBisims,
  author = 	 "Hennessy, Matthew and Lin, Huimin",
  title = 	 "Symbolic Bisimulations",
  institution =  {University of Sussex},
  type =         {Computer Science Report},
  number =       "1992:01",
  year = 	 1992,
  annote = "Inspiration to Sangiorgi in constructing a transition
              system specialised for open bisimulation",
  abstract = "We re-examine bisimulation equivalence for value-passing
             process languages in which actions have associated with
             them values from a possibly infinite value set. Using
             symbolic actions we generalise the standard notion of
             labelled transition graph to that of symbolic transition
             graph. The advantage of the latter is that the
             operational semantics of many value-passing processes may
             be expressed in terms of finite symbolic transition
             graphs although the underlying (standard) labelled
             transitions graph is infinite.",
  folder =    "Calculi 2"
}


@techreport{Jeffrey:02:TheoryBisimFragConcMLLocalNames,
  author = {Jeffrey, Alan and Rathke, Julian},
  title = "A Theory of Bisimulation for a Fragment of Concurrent {ML} with Local Names",
  year = 2002,
  institution = {University of Sussex},
  type = {Computer Science Report},
  number = "2002:02",
  note = "revised version",
  abstract = "Concurrent ML is an extension of Standard ML with
              pi-calculus like primitives for multi-threaded
              programming. CML has a reduction semantics, but to date
              there has been no labelled transitions semantics
              provided for the entire language. In this paper, we
              present a labelled transition semantics for a fragment
              of CML called mnCML which includes features not covered
              before: dynamically generated local channels and thread
              identifiers. We show that weak bisimilarity for mnCML is
              a congruence, and coincides with barbed bisimulation
              congruence. We also provide a variant of Sangiorgi's
              normal bisimulation for mnCML, and show that this too
              coincides with bisimilarity.",
  annotation = "This paper provides the first characterisation of
               program equivalence for the lambda-calculus together
               with $\pi$-style concurrency.",
  folder =	 "HOBisimulation"
}

@InProceedings{Gardner:00:ProcCalcToProcFrameworks,
  author = 	 "Gardner, Philippa",
  title = 	 "From Process Calculi to Process Frameworks",
  booktitle = "Proceedings of the 11th International Conference on Concurrency Theory (CONCUR'00)", 
  pages = "69--88",
  year = 	 2000,
  isbn = {3-540-67897-2},
  publisher = pub-SV,
  editor = 	 "Palamidessi, Catuscia",
  volume = 	 1877,
  series = 	 ser-LNCS,
  annote = 	 "Milner gives this as reference to Action Calculi. A must read",
  abstract = "We present two process frameworks: the action calculi of
             Milner, and the fusion systems of Gardner and
             Wischik. The action calculus framework is based on
             process constructs arising from the $\pi$-calculus. We
             give a non-standard presentation of the $\pi$-calculus,
             to emphasise the similarities between the calculus and
             the framework. The fusion system framework generalises a
             new process calculus called the $\pi_f $-calculus. We
             describe the $\pi_f $-calculus, which is based on
             different process constructs to those of the
             $\pi$-calculus, and show that the generalisation from the
             calculus to the framework is simple. we compare the
             frameworks by studying examples.",
  url = "http://www.doc.ic.ac.uk/~pg/papers/framework.ps.gz",
  folder =    "Calculi 1"
}

@Article{Sewell:02:RewriteRulesBisimCong,
  author = 	 "Sewell, Peter",
  title = 	 "From Rewrite Rules to Bisimulation Congruences",
  journal = 	 j-THEO-CS,
  year = 	 2002,
  volume = 	 274,
  number = 	 "1-2",
  pages =        "183--230",
  abstract = "The dynamics of many calculi can be most clearly defined
             by a reduction semantics. To work with a calculus,
             however, an understanding of operational congruences is
             fundamental; these can often be given tractable
             definitions or characterisations using a labelled
             transition semantics. This paper considers calculi with
             arbitrary reduction semantics of three simple classes,
             firstly ground term rewriting, then left-linear term
             rewriting, and then a class which is essentially the
             action calculi lacking substantive name binding. General
             definitions of labelled transitions are given in each
             case, uniformly in the set of rewrite rules, and without
             requiring the prescription of additional notions of
             observation. They give rise to bisimulation
             congruences. As a test of the theory it is shown that
             bisimulation for a fragment of CCS is recovered. The
             transitions generated for a fragment of the Ambient
             Calculus of Cardelli and Gordon, and for SKI combinators,
             are also discussed briefly.",
  annote = 	 {},
  folder =    ""
}
 

@TechReport{Sangiorgi:95:LazyFuncMobProce,
  author = 	 "Sangiorgi, Davide",
  title = 	 "Lazy Functions and Mobile Processes",
  institution =  "INRIA",
  year = 	 1995,
  type = 	 "Research Report",
  number = 	 2515,
  abstract = "This paper continues the study of Milner's encoding of
             the lazy $\lambda$-calculus into the $\pi$-calculus
             \cite{Milner:92:FuncAsProcesses}. The encoding is shown
             to give rise to a $\lambda$-model in which, in accordance
             with the theory of the lazy $\lambda$-calculus,
             conditional extensionality holds. However, the model is
             not fully abstract. To obtain full abstraction, the
             operational equivalence on $\lambda$-terms ({\em
             applicative bisimulation}) is refined. The new relation,
             called {\em open applicative bisimulation}, allows us to
             observe some internal structure of $\lambda$-terms, and
             coincides with the {\em Levy-Longo Tree}
             equality. Milner's encoding is presented on a sublanguage
             of the $\pi$-calculus similar to those proposed by Boudol
             (Bou92), Honda and Tokoro (HoTo91). Some
             properties of bisimulation on this sublanguage are
             demonstrated and used to simplify a few proofs in the
             paper. For instance, {\em ground bisimulation}, a form of
             bisimulation where no name instantiation on input actions
             is required, is proved to be a congruence relation; as a
             corollary, various $\pi$-calculus bisimilarity
             equivalences (ground, late, early, open) are shown to
             coincide on this sublanguage.",
  annote = "Mentions ground bisimulation: a form of bisimulation
              where no name instantiation on input actions is required
              Vs. Quaglia",
  folder =    "Calculi 2"
}


@Article{Pistore:01:PartitionRefinementAlgForPiCalc,
  author = 	 "Pistore, Marco and Sangiorgi, Davide",
  title = 	 "A Partition Refinement Algorithm for the $\pi$-Calculus",
  journal = 	 j-INFO-COMP,
  year = 	 2001,
  volume = 	 164,
  number = 	 2,
  pages = 	 "264--321",
  abstract = "The partition refinement algorithm is the basis for most
             of the tools for checking bisimulation equivalences and
             for computing minimal realisations of CCS-like finite
             state processes.

             In this paper, we present a partition refinement
             algorithm for the pi-calculus, a development of CCS where
             channel names can be communicated. It can be used to
             check bisimilarity and to compute minimal realisations of
             finite control processes -- the pi-calculus counterpart
             of CCS finite state processes. The algorithm is developed
             for strong open bisimulation, and can be adapted to late
             and early bisimulations, as well as to weak
             bisimulations. To arrive at the algorithm, a few laws,
             proof techniques, and four characterizations of open
             bisimulation are proved.", 
  annote = {},
  folder = "Calculi 2" 
}

@InProceedings{Barendregt:88:IntroLambdaCalc,
  author = 	 "Barendregt, Henk and  Barendsen, Erik",
  title = 	 "Introduction to Lambda Calculus",
  year = 	 1988,
  booktitle = "Aspenæs Workshop on Implementation of Functional Languages, G{\"o}teborg",
  publisher = "Programming Methodology Group, University of G{\"o}teborg and Chalmers University of Technology",
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  note = 	 "Revised edition October 1994",
  url = "citeseer.ist.psu.edu/barendregt94introduction.html",
  annote = 	 {},
  folder =    "Div 2"
}



@Article{Cousot:79:ConstructiveVerTarskiFixedPointThm,
  author = 	 "Cousot, P. and Cousot, R.",
  title = 	 "Constructive Versions of {T}arski's Fixed Point Theorems",
  journal = 	 "Pacific Journal of Mathematics",
  pages =        "43--57",
  year =         1979,
  volume = 	 82,
  number = 	 1,
  annote = 	 {},
  abstract = "Let F be a monotone operator on the complete lattice L
             into itself. Tarski's lattice theoretical fixed point
             theorem states that the set of fixed points of F is a
             nonempty complete lattice for the ordering of L. We give
             a constructive proof of this theorem showing that the set
             of fixed points of F is the image of L by a lower and an
             upper preclosure operator. The preclosure operators are
             the composition of lower and upper closure operators
             which are defined by means of limits of stationary
             transfinite itertion sequences for F. In the same way we
             give a constructive characterization of the set of common
             fixed points of a family of commuting operators. Finally
             we examine some consequences of additional
             semi-continuity hypotheses.",
  folder =    ""
}


@Article{BenAri:98:HowToSolveSantaClaus,
  author = 	 "Ben-Ari, Mordechai",
  title = 	 "How to Solve the {S}anta {C}laus Problem",
  journal = 	 "Concurrency - Practice and Experience",
  year = 	 1998,
  volume = 	 10,
  number = 	 6,
  pages = 	 "485--496",
  annote = 	 {},
  folder =    "Stud 1"
}



@Unpublished{Benton:03:JingleBellsSantaCPolyCSharp,
  author = 	 "Benton, Nick",
  title = 	 "Jingle Bells: Solving the {S}anta {C}laus Problem in {P}olyphonic {C}$^{\#}$",
  institution =  "Microsoft Research",
  year = 	 2003,
  note = 	 "Submitted 2003",
  annote = 	 {},
  abstract = "The Santa Claus problem is an interesting exercise in
             concurrent programming which has been used in a
             comparison of the concurrency mechanisms of Ada and
             Java. We present a simple solution to the problem in
             Polyphonic C$^{\#}$ , an extension of C$^{\#}$ with new
             concurrency constructs based on the Join calculus.",
  folder =    "Stud 1"
}


@InCollection{Gunter:90:SemanticDomains,
  author = 	 "Gunter, Carl A. and Scott, Dana S.",
  title = 	 "Semantic Domains",
  booktitle = 	 "Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics (B)",
  pages = 	 "633--674",
  publisher =    pub-NH,
  year = 	 1990,
  editor = 	 "Leeuwen, Jan van",
  url = "citeseer.ist.psu.edu/gunter90semantic.html",
  OPTnote = 	 {},
  annote = 	 {},
  folder =    "Div 1"
}

@TechReport{Aceto:03:FavouriteResClassProcAlg,
  author = 	 "Aceto, Luca",
  title = 	 "Some of My Favourite Results in Classic Process Algebra",
  institution =  uni-BRICS,
  year = 	 2003,
  type = 	 "Notes Series",
  number = 	 "NS-03-2",
  address = 	 addr-daimi,
  note =	 "21~pp. To appear in the {\em Bulletin of the EATCS},
                  volume 81, October 2003",
  abstract =     "This note collects some of the author's favourite
                 results in classic process algebra, broadly
                 construed, and points to some open problems in the
                 field. It is hoped that this piece will offer a
                 modest contribution to the healthy development of
                 this area of research.",
  annote = 	 {},
  folder =     "Calculi 1"
}

@TechReport{Brauner:96:IntroToLinearLogic,
  author = 	 "Bra{\"u}ner, Torben",
  title = 	 "Introduction to Linear Logic",
  institution =  uni-BRICS,
  year = 	 1996,
  type = 	 "Lecture Series",
  number = 	 "LS-96-6",
  address = 	 addr-daimi,
  note =	 "iiiv+55~pp",
  abstract =	 "The main concern of this report is to give an
		  introduction to Linear Logic. For pedagogical purposes we
		  shall also have a look at Classical Logic as well as
		  Intuitionistic Logic. Linear Logic was introduced by
		  J.-Y. Girard in 1987 and it has attracted much attention
		  from computer scientists, as it is a logical way of
		  coping with resources and resource control.  The focus of
		  this technical report will be on proof-theory and
		  computational interpretation of proofs, that is, we will
		  focus on the question of how to interpret proofs as
		  programs and reduction (cut-elimination) as
		  evaluation. We first introduce Classical Logic. This is
		  the fundamental idea of the proofs-as-programs
		  paradigm. Cut-elimination for Classical Logic is highly
		  non-deterministic; it is shown how this can be remedied
		  either by moving to Intuitionistic Logic or to Linear
		  Logic.  In the case on Linear Logic we consider
		  Intuitionistic Linear Logic as well as Classical Linear
		  Logic. Furthermore, we take a look at the Girard
		  Translation translating Intuitionistic Logic into
		  Intuitionistic Linear Logic. Also, we give a brief
		  introduction to some concrete models of Intuitionistic
		  Linear Logic. No proofs will be given except that a proof
		  of cut-elimination for the multiplicative fragment of
		  Classical Linear Logic is included in an appendix
		  \subsubsection*{Contents}		  
		  \begin{itemize}
	     	  \item[1] Classical and Intuitionistic Logic
	     	    \begin{itemize}
	     	    \item[1.1] Classical Logic
	     	    \item[1.2] Intuitionistic Logic
	     	    \item[1.3] The $\lambda $-Calculus
	     	    \end{itemize}
	     	  \item[1.4] The Curry-Howard Isomorphism
	     	  \item[2] Linear Logic
	     	    \begin{itemize}
	     	    \item[2.1] Classical Linear Logic
	     	    \item[2.2] Intuitionistic Linear Logic
	     	    \item[2.3] A Digression - Russell's Paradox and Linear
		        Logic
	     	    \item[2.4] The Linear $\lambda $-Calculus
	     	    \item[2.5] The Curry-Howard Isomorphism
	     	    \item[2.6] The Girard Translation
	     	    \item[2.7] Concrete Models
	     	    \end{itemize}
	     	  \item[A] Logics
	     	    \begin{itemize}
	     	    \item[A.1] Classical Logic
	     	    \item[A.2] Intuitionistic Logic
	     	    \item[A.3] Classical Linear Logic
	     	    \item[A.4] Intuitionistic Linear Logic
	     	    \end{itemize}
	     	  \item[B] Cut-Elimination for Classical Linear Logic
	     	    \begin{itemize}
	     	    \item[B.1]
	     	    \item[B.2] Putting the Proof Together
	     	    \end{itemize}
	     	  \end{itemize}",
  folder = "Div 1"
}

@Article{Cardelli:85:OnUnderstTypesDataAbsPoly,
  author = 	 "Cardelli, Luca and Wegner, Peter",
  title = 	 "On Understanding Types, Data Abstraction, and Polymorphism",
  journal = 	 j-CSUR,
  year = 	 1985,
  volume = 	 17,
  number = 	 4,
  pages = 	 "471--522",
  abstract = "Our objective is to understand the notion of type in
             programming languages, present a model of typed,
             polymorphic programming languages that reflects recent
             research in type theory, and examine the relevance of
             recent research to the design of practical programming
             languages. Object-oriented languages provide both a
             framework and a motivation for exploring the interaction
             among the concepts of type, data abstraction, and
             polymorphism, since they extend the notion of type to
             data abstraction and since type inheritance is an
             important form of polymorphism. We develop a
             lambda-calculus-based model for type systems that allows
             us to explore these interactions in a simple setting,
             unencumbered by complexities of production programming
             languages. The evolution of languages from untyped
             universes to monomorphic and then polymorphic type
             systems is reviewed. Mechanisms for polymorphism such as
             overloading, coercion, subtyping, and parameterization
             are examined. A unifying framework for polymorphic type
             systems is developed in terms of the typed
             lambda-calculus augmented to include binding of types by
             quantification as well as binding of values by
             abstraction. The typed lambda-calculus is augmented by
             universal quantification to model generic functions with
             type parameters, existential quantification and packaging
             (information hiding) to model abstract data types, and
             bounded quantification to model subtypes and type
             inheritance. In this way we obtain a simple and precise
             characterization of a powerful type system that includes
             abstract data types, parametric polymorphism, and
             multiple inheritance in a single consistent
             framework. The mechanisms for type checking for the
             augmented lambda-calculus are discussed. The augmented
             typed lambda-calculus is used as a programming language
             for a variety of illustrative examples. We christen this
             language Fun because fun instead of lambda is the
             functional abstraction keyword and because it is pleasant
             to deal with. Fun is mathematically simple and can serve
             as a basis for the design and implementation of real
             programming languages with type facilities that are more
             powerful and expressive than those of existing
             programming languages. In particular, it provides a basis
             for the design of strongly typed object-oriented
             languages.",
  annote = 	 {},
  folder =    "Div 1"
}

@book{Huth:00:LogicInCompSciModlReasAboutSyst,
  author = {Huth, Michael R. A. and Ryan, Mark},
  title = {Logic in Computer Science: Modelling and Reasoning about Systems},
  year = {2000},
  isbn = {0-521-65602-8},
  publisher = pub-CUP,
  about = "In recent years, powerful tools for verifying hardware and
          software systems have been developed. Major companies, such
          as Intel, Siemens, BT, AT\&T, and IBM have increasingly
          become interested in that technology. Students need a basic
          formal training that allows them to gain sufficient
          proficiency in using logic-based verification methods. This
          book addresses these needs by providing a sound basis in
          logic and an introduction to the logical frameworks used in
          modeling, specifying and verifying computer
          systems. Coverage provides a simple and clear presentation,
          detailing propositional and predicate logic as well as some
          specialized logics used for reasoning about the correctness
          of computer systems. The authors introduce a carefully
          chosen core of essential terminology; further technicalities
          are introduced only where they are required by the
          applications. Numerous examples are given, as well as a full
          exposition of a fast-growing technique for modeling and
          verifying computer systems, known as symbolic model
          checking. It will be an ideal introduction for undergraduate
          students. A worldwide web tutorial that supports the course
          activities and provides solutions to the sample exercises is
          available to instructors.",
  annote = 	 {},
  folder =    ""
}


@InProceedings{Braione:04:CalcContexAwareCoord,
  author = 	 "Braione, Pietro and Picco, Gian Pietro",
  title = 	 "On Calculi for Context-Aware Coordination",
  booktitle = "Proceedings of the 7th International Conference on
                  Coordination Models and Languages (COORDINATION'04)",
  pages = 	 "38--54",
  year = 	 2004,
  editor = 	 "De Nicola, Rocco and Ferrari, Gianluigi and Meredith, Greg",
  volume = 	 2949,
  OPTnumber = 	 {},
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "Modern distributed computing demands unprecedented
             levels of dynamicity and reconfiguration. Mobile
             computing, peer-to-peer networks, computational grids,
             multi-agent systems, are examples of domains exhibiting a
             continuously changing system configuration. In these
             settings, the context where computation occurs is not
             only dynamically changing, but also a ecting the
             components behavior in a fundamental way, by enabling or
             inhibiting some of their actions. 

             This paper is a first step in laying the formal
             foundation for a process calculi specification style
             that: i) fosters a coordination approach by sharply
             separating the process behavior from the computational
             context defined by system changes; ii) enables the
             specifier to define her notion of context and the rules
             governing how it a ects the application process
             behavior.",
  annote = 	 {},
  folder =    "Calculi 2"
}


@PhdThesis{Braione:04:CalcContexAwareSyst,
  author = 	 {Braione, Pietro},
  title = 	 "On Calculi for Context-Aware Systems",
  school = 	 "Dipartimento di Elettronica e Informazione, Politecnico di Milano",
  year = 	 2004,
  OPTtype = 	 {},
  address = 	 {P.zza Leonardo da Vinci 32, 20133 Milano, Italy},
  annote = 	 {},

  url = "http://www.elet.polimi.it/upload/braione/phdthesis.ps.gz",
  folder =    "Books + Theses 2"
}




@PhdThesis{Reppy:HigherOrderConcurrency,
  author = 	 "Reppy, John Hamilton",
  title = 	 "Higher-order Concurrency",
  school = 	 "Department of Computer Science Cornell University",
  year = 	 1992,
  abstract = "Concurrent programming is a useful technique for
             structuring many important classes of applications such
             as interactive systems. This dissertation presents an
             approach to concurrent language design that provides a
             new form of linguistic support for constructing
             concurrent applications. This new approach treats
             synchronous operations as first-class values in a way
             that is analogous to the treatment of functions as
             first-class values in languages such as ML. The mechanism
             is set in the framework of the language Concurrent ML
             (CML), which is a concurrent ex tension of Standard
             ML. CML has a domain of first-class values, called
             events, that represent synchronous operations.
             Synchronous message passing operations are provided as
             the base-event values, and combinators are provided for
             constructing more complex events from other event
             values. This mechanism allows programmers to define new
             synchronization and communication abstractions that are
             first-class citizens, which gives programmers the
             flexibility to tailor their concurrency abstractions to
             their applications.

             The dissertation is organized into three technical
             parts. The first part describes the design and rationale
             of CML and shows how first-class synchronous operations
             can be used to implement many of the communication
             mechanisms found in other concurrent languages. The
             second part presents the formal operational semantics of
             first-class synchronous operations and proves that the
             polymorphic type system used by CML is sound. The third
             part addresses practical issues. It describes the use of
             CML in non-trivial applications, describes the
             implementation and performance of CML on a
             single-processor computer, and discusses issues related
             to the use and implementation of CML on a shared-memory
             multiprocessor.",
  annote = 	 "Also published as TR-92-1852",
  url = "http://people.cs.uchicago.edu/~jhr/papers/1992/phd-thesis.ps.gz",
  folder =    "Books + Theses 2"
}

@InProceedings{Magee:95:SpecDistSoftArchitec,
    author = "Magee, Jeff and Dulay, Naranker and Eisenbach, Susan and Kramer, Jeff",
    title = "Specifying Distributed Software Architectures",
    booktitle = "Proceedings of the 5th European Software Engineering Conference ({ESEC}'95)",
    volume = 989,
    publisher = pub-SV,
    OPTaddress = "Sitges, Spain",
    editor    = "Sch{\"a}fer, Wilhelm and Botella, Pere",
    series    = ser-LNCS,
    pages = "137--153",
    year = 1995,
    url = "citeseer.ist.psu.edu/article/magee95specifying.html",
    OPTnote = 	{},
    annote = "",
    folder = "Teaching 1"
}

@article{Wright:95:SimpleImperativePoly,
  author = {Wright, Andrew K.},
  title = {Simple Imperative Polymorphism},
  journal = "LISP and Symbolic Computation",
  volume = 8,
  number = 4,
  year = 1995,
  editor = "Mason, Ian A.",
  issn = {0892-4635},
  pages = {343--355},
  publisher = pub-KLUWER,
  abstract = "This paper describes a simple extension of the
             Hindley-Milner polymorphic type discipline to
             call-by-value languages that incorporate imperative
             features like references, exceptions, and
             continuations. This extension sacrifices the ability to
             type every purely functional expression that is typable
             in the Hindley-Milner system. In return, it assigns the
             same type to functional and imperative implementations of
             the same abstraction. Hence with a module system that
             separates specifications from implementations, imperative
             features can be freely used to implement polymorphic
             specifications. A study of a number of ML programs shows
             that the inability to type all Hindley-Milner typable
             expressions seldom impacts realistic
             programs. Furthermore, most programs that are rendered
             untypable by the new system can be easily repaired.",
  keywords = "Continuations, functional programming, polymorphism, references, state",
  annote = "",
  folder = "Div 1"
}

@Article{Mitchell:91:TypeInferSimpleSubType,
  author = 	 "Mitchell, John C.",
  title = 	 "Type Inference with Simple Subtypes",
  journal = 	 j-FUNC-PROG,
  year = 	 1991,
  volume = 	 1,
  number = 	 3,
  pages = 	 "245--285",
  annote = 	 {},
  folder = "Div 1"
}



@TechReport{Sangiorgi:95:PiCalcInternMobAgentPassCalc,
  author = 	 "Sangiorgi, Davide",
  title = 	 "Pi-calculus, Internal Mobility, and Agent-passing Calculi",
  institution =  "INRIA",
  year = 	 1995,
  type = 	 "Research Report",
  number = 	 "2539",
  abstract = "The $\pi$-calculus is a process algebra which originates
             from CCS and permits a natural modelling of mobility
             (i.e., dynamic reconfigurations of the process linkage)
             using communication of names. Previous research has shown
             that the $\pi$-calculus has much greater expressiveness
             than CCS, but also a much more complex mathematical
             theory. The primary goal of this work is to understand
             the reasons of this gap. Another goal is to compare the
             expressiveness of {\em name-passing} calculi, i.e.,
             calculi like $\pi$-calculus where mobility is achieved
             via exchange of names, and that of {\em agent-passing
             calculi}, i.e., calculi where mobility is achieved via
             exchange of agents. 

             We separate the mobility mechanisms of the $\pi$-calculus
             into two, respectively called {\em internal mobility} and
             {\em external mobility}. The study of the subcalculus
             which only uses internal mobility, called $\pi$I,
             suggests that internal mobility is responsible for {much}
             of the expressiveness of the $\pi$-calculus, whereas
             external mobility is responsible for {much} of the
             semantic complications. A pleasant property of $\pi$I is
             the full symmetry between input and output constructs.

             Internal mobility is strongly related to agent-passing
             mobility. By imposing bounds on the order of the types of
             $\pi$I and of the Higher-Order $\pi$-calculus
             \cite{Sangiorgi:92:ExpressMobProgAlgFirstAndHO} we define
             a hierarchy of name-passing calculi based on internal
             mobility and one of agent-passing calculi. We show that
             there is an exact correspondence, in terms of
             expressiveness, between the two hierarchies.",
  annote = 	 {},
  folder ="Calculi 1"
}


@Article{McKenney:96:SelectingLockingPrimParalProg,
  author = 	 "McKenney, Paul E.",
  title = 	 "Selecting Locking Primitives for Parallel Programming",
  journal = 	 j-CACM,
  year = 	 1996,
  volume = 	 39,
  number = 	 10,
  pages = 	 "75--82",
  issn = {0001-0782},
  doi = {http://doi.acm.org/10.1145/236156.236174},
  publisher = pub-ACM,
  annote = 	 {},
  folder =    "Stud 1"
}

@InCollection{McKenney:96:SelectLockDesgnParaProg,
  author = 	 "McKenney, Paul E.",
  title = 	 "Selecting Locking Designs for Parallel Programs",
  booktitle = 	 "Pattern Languages of Program Design 2",
  isbn = {0-201-895277},
  pages = "501--531",
  publisher = pub-AW,
  year = 	 1996,
  annote = 	 {},
  folder =    "Stud 1"
}

@Article{Trono:94:NewExerciseConcurrency,
  author = 	 "Trono, John A.",
  title = 	 "A New Exercise in Concurrency",
  journal = 	 "{SIGCSE} Bulletin",
  year = 	 1994,
  volume = 	 26,
  number = 	 3,
  pages = 	 "8--10",
  OPTnote = 	 "Corrigndum: 26(4):63",
  annote = 	 {},
  folder =    "Stud 1"
}


@Article{Buhr:95:MonitorClassification,
  author = 	 "Buhr, Peter A. and Fortier, Michel and Coffin, Michael H.",
  title = 	 "Monitor Classification",
  journal = 	 j-CSUR,
  year = 	 1995,
  volume = 	 27,
  number = 	 1,
  pages = 	 "63--107",
  publisher =    pub-ACM,
  annote = "A comparative survey of how concurrency constructs are
           defined and supported across different languages and
           systems ",
  url = "ftp://plg.uwaterloo.ca/pub/uSystem/MonitorClassification.ps.gz",
  folder =    "Stud 1"
}


@article{Andrews:83:ConcNotatConcProg,
  author = "Andrews, Gregory R. and Schneider, Fred B.",
  title = {Concepts and Notations for Concurrent Programming},
  journal = j-CSUR,
  volume = 15,
  number = 1,
  year = 1983,
  issn = {0360-0300},
  pages = "3--43",
  doi = {http://doi.acm.org/10.1145/356901.356903},
  publisher =    pub-ACM,
  abstract = "Much has been learned in the last decade about
             concurrent programming. This paper identifies the major
             concepts of concurrent programming and describes some of
             the more important language notations for writing
             concurrent programs. The roles of processes,
             communication, and synchronization are
             discussed. Language notations for expressing concurrent
             execution and for specifying process interaction are
             surveyed. Synchronization primitives based on shared
             variables and on message passing are described. Finally,
             three general classes of concurrent programming languages
             are identified and compared.",

  annote = "A good overview of all the mechanisms used in
              coordinating or synchronizing threads, including
              monitors",
  folder =    "Stud 1"
}

@InProceedings{Hirschkoff:99:HandSubstExplicitPiCalc,
  author = 	 "Hirschkoff, Daniel",
  title = 	 "Handling Substitutions Explicitely in the $\pi$-Calculus",
  booktitle = "Proceedings of Second International Workshop on
              Explicit Substitutions: Theory and Applications to
              Programs and Proofs (WESTAPP'99)",
  pages = 	 "28--43",
  year = 	 1999,
  annote = 	 "",
  abstract = "We present two calculi aimed at describing the mechanism
             of name manipulation in the $\pi$-calculus. Following the
             ideas underlying the introduction of the $\lambda s$ and
             $\lambda \sigma$ calculi, we define $\pi$s and
             $\pi\sigma$. The former calculus includes operators on De
             Bruijn indices, and is first introduced to give an
             intuitive description of the De Bruijn representation of
             $\pi$-calculus terms. The latter is a calculus of
             explicit substitutions, where the computations pertaining
             to name manipulation are described by a Term Rewrite
             System. We introduce the two corresponding notions of
             bisimulation, and show that they can be put in
             correspondence; in doing this, we establish a relation
             with what could be considered ``usual'' (early)
             bisimulation on ss-calculus terms in De Bruijn
             notation. These results shed light on the mechanism of
             name-passing, which can be of interest both for the
             implementation and the formal treatment (e.g. in a
             logical framework) of related calculi.",
  url = "http://cermics.enpc.fr/~dh/sigma/full.ps.gz",
  folder =    "Calculi 1"
}

@Article{Ferrari:96:PiCaclExplicitSubstitutions,
  author = 	 "Ferrari, Gianluigi and Montanari, Ugo and Quaglia, Paola",
  title = 	 "A $\pi$-calculus with Explicit Substitutions",
  journal = 	 j-THEO-CS,
  year = 	 1996,
  volume = 	 168,
  number = 	 1,
  pages = 	 "53--103",
  OPTmonth = 	 now,
  abstract = "A new formulation of the $\pi$-calculus, where name
             instantiation is handled explicitly via the introduction
             of a suitable combinator, is presented. The bisimulation
             semantics originally developed for the $\pi$-calculus are
             retrieved by giving the description of the corresponding
             strategies for name instantiation. The explicit handling
             of name instantiation allows us to reduce the
             $\pi$-calculus transitional semantics to a standard SOS
             framework. Hence, $\pi$-calculus bisimulation models can
             take fully advantage of the SOS meta-theory developed for
             'static' process calculi. For instance, complete
             axiomatic characterizations of $\pi$-calculus
             bisimulation equivalences can be automatically derived by
             turning SOS rules into equations. This formulation of the
             $\pi$-calculus is very promising for the development of
             semantic-based automatic verification tools.",
  annote = 	 "",
  folder =    "Calculi 1"
}


@article{Peterson:77:PetriNets,
  author = "Peterson, James L.",
  title =  "Petri Nets",
  journal = j-CSUR,
  volume = 9,
  number = 3,
  year = 1977,
  issn = {0360-0300},
  pages = "223--252",
  doi = {http://doi.acm.org/10.1145/356698.356702},
  publisher = pub-ACM,
  abstract = "Over the last decade, the Petri net has gained increased
             usage and acceptance as a basic model of systems of
             asynchronous concurrent computation. This paper surveys
             the basic concepts and uses of Petri nets. The structure
             of Petri nets, their markings and execution, several
             examples of Petri net models of computer hardware and
             software, and research into the analysis of Petri nets are
             presented, as are the use of the reachability tree and
             the decidability and complexity of some Petri net
             problems. Petri net languages, models of computation
             related to Petri nets, and some extensions and subclasses
             of the Petri net model are also briefly discussed.",
  annote = "",
  folder = "Calculi 1"
}

@article{Cleaveland:96:StratDirConcurResearch,
  author = "Cleaveland, Rance and Smolka, Scott A.",
  title =  "Strategic Directions in Concurrency Research",
  journal = j-CSUR,
  volume = 28,
  number = 4,
  year = 1996,
  issn = {0360-0300},
  pages = {607--625},
  doi = {http://doi.acm.org/10.1145/242223.242252},
  publisher = pub-ACM,
  OPTnote = 	 {},
  annote = "",
  folder = "Calculi 1"
}


@InProceedings{Honda:04:ProcessesAndGames,
  author = 	 "Honda, Kohei",
  title = 	 "Processes and Games",
  booktitle = "Proceedings of 4th International Workshop on Rewriting logic and Its Applications (WRLA'02)",
  OPTpages = 	 {},
  year = 	 2004,
  editor = 	 "Gadducci, Fabio and Montanari, Ugo",
  volume = 	 71,
  series = 	 ser-ENTCS,
  publisher =    pub-ELS,
  abstract = "A general theory of computing is important, if we wish
             to have a common mathematical footing based on which
             diverse scientific and engineering efforts in computing
             are uniformly understood and integrated. A quest for such
             a general theory may take different paths. As a case for
             one of the possible paths towards a general theory, this
             paper establishes a precise connection between a
             game-based model of sequential functions by Hyland and
             Ong on the one hand, and a typed version of the
             ?-calculus on the other. This connection has been
             instrumental in our recent efforts to use the ?-calculus
             as a basic mathematical tool for representing diverse
             classes of behaviours, even though the exact form of the
             correspondence has not been presented in a published
             form. By redeeming this correspondence we try to make
             explicit a convergence of ideas and structures between
             two distinct threads of Theoretical Computer
             Science. This convergence indicates a methodology for
             organising our understanding on computation and that
             methodology, we argue, suggests one of the promising
             paths to a general theory.",
  annote = "Could be interesting to read together with the
           accompanying notes: ``Program Logics from Process Logics''
           from
           \url{http://www.dcs.qmul.ac.uk/~kohei/logics/index.html}",
  folder =    ""
}

@Unpublished{Honda:04:SeqProcessLogicNotesOrigins,
  author = 	 "Honda, Kohei",
  title = 	 "Sequential Process Logics: Notes on Origins",
  note = 	 "Bakground material for \cite{Honda:04:ProcesLogicDuality}",
  year = 	 2004,
  url = "http://www.dcs.qmul.ac.uk/%7Ekohei/logics/origins.ps.gz",
  annote = "Fits together with \cite{Honda:04:ProcessesAndGames} as
              background material for
              \cite{Honda:04:ProcesLogicDuality}",
  folder =    ""
}


@InProceedings{Honda:04:ProcesLogicDuality,
  author = 	 "Honda, Kohei",
  title = 	 "Process Logic and Duality",
  booktitle =    {Proceedings of the 9th ACM SIGPLAN international conference on Functional programming (ICFP'04)},
  OPTpages = 	 {},
  year = 	 2004,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  publisher =    pub-ACM,
  note = 	 "To Appear",
  annote = "which gives a brief introduction to the key technical
              ideas. Treats call-by-value PCF."
}
 
@InProceedings{Honda:04:ComposProgLogicPolyHOFunction,
  author = 	 "Honda, Kohei and Yoshida, Nobuko",
  title = 	 "A Compositional Program Logic for Polymorphic Higher-Order Functions",
  booktitle = {Proceedings of the 6th ACM SIGPLAN international conference on Principles and Practice of Declarative Programming (PPDP'04)},
  OPTpages = 	 {},
  year = 	 2004,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  publisher =    pub-ACM,
  note = 	 "To Appear",
  annote = 	 "if you are interested in universals and existentials"
}

@Article{Abadi:91:ExplicitSubstitutions,
  author = 	 "Abadi, Martin and Cardelli, Luca and Curien, Pierre-Louis and Levy, Jean-Jacques",
  title = 	 "Explicit Substitutions",
  journal = 	 j-FUNC-PROG,
  year = 	 1991,
  volume = 	 1,
  number = 	 4,
  pages = 	 "375--416",
  abstract = "The $\lambda\sigma$-calculus is a refinement of the
             $\lambda$-calculus where substitutions are manipulated
             explicitly. The $\lambda\sigma$-calculus provides a
             setting for studying the theory of substitutions, with
             pleasant mathematical properties. It is also a useful
             bridge between the classical $\lambda$-calculus and
             concrete implementations.",
  annote = "The foundations of reduction using 'environments'
           (explicit substitutions) instead of substitutions.",
  folder =    "Div 2"
}

@Article{Riely:01:DistProcessesLocatFailures,
  author = 	 "Riely, James and Hennessy, Matthew",
  title = 	 "Distributed Processes and Location Failures",
  journal = 	 j-THEO-CS,
  year = 	 2001,
  volume = 	 266,
  pages = 	 "693-735",
  abstract = "Site failure is an essential aspect of distributed
             systems; nonetheless its effect on programming language
             semantics remains poorly understood. To model such
             systems, we define a process calculus in which processes
             are run at distributed locations. The language provides
             operators to kill locations, to test the status (dead or
             alive) of locations, and to spawn processes at remote
             locations. Using a variation of bisimulation, we provide
             alternative characterizations of strong and weak barbed
             congruence for this language, based on an operational
             semantics that uses congurations to record the status of
             locations. 

             We then derive a second, symbolic characterization in
             which configurations are replaced by logical formulae. In
             the strong case the formulae come from a standard
             propositional logic, while in the weak case a temporal
             logic with past time modalities is required. The symbolic
             characterization establishes that, in principle, barbed
             congruence for such languages can be checked using
             existing symbolic techniques.",
  annote = 	 "Error on homepage",
  folder =    "Locations"
}




@InProceedings{Gardner:03:LinearForwarders,
  author = "Gardner, Philippa and Laneve, Cosimo and Wischik, Lucian",
  title  = "Linear Forwarders",
  booktitle = "Proceedings of the 14th International Conference on
               Concurrency Theory (CONCUR'03)",
  year   = 2003,
  editor = "Amadio, Roberto M. and Lugiez, Denis",
  volume = 2761,
  pages  = "415--430",
  series = ser-LNCS,
  publisher = pub-SV,
  annote = 	 {},
  abstract = "A \emph{linear forwarder} is a processes which receives
             one message on a channel and sends it on a different
             channel. Such a process allows for a simple
             implementation of the asynchronous pi calculus, by means
             of a direct encoding of the pi calculus' \emph{input
             capability} (i.e. where a received name is used as the
             subject of subsequent input). This encoding is fully
             abstract with respect to barbed congruence.

             Linear forwarders are actually the basic mechanism of an
             earlier implementation of the pi calculus, the
             \emph{fusion machine}. We modify the machine, replacing
             fusions by forwarders. The result is more robust in the
             presence of failures, and more fundamental.",
  folder =    ""
}



@InProceedings{Gardner:02:FusionMachine,
  author =       "Gardner, Philippa and Laneve, Cosimo and Wischik, Lucian ",
  title =        "The Fusion Machine (extended abstract)",
  booktitle =    "Proceedings of the 13th International
                 Conference on Concurrency Theory (CONCUR'02)",
  OPTaddress =   "Brno, Czech Republic",
  editor =       "Brim, Lubos and Jancar, Petr and Kret\'{\i}nsk{\'y}, Mojm\'{\i}r and Kucera, Anton\'{\i}n",
  publisher =    pub-SV,
  series =       ser-LNCS,
  volume =       2421,
  year =         2002,
  OPTmonth =        aug,
  pages =        "418--433",
  abstract = "We present a new model for the distributed
             implementation of pi-like calculi, which permits strong
             correctness results that are simple to prove. We describe
             the \emph{distributed channel machine} - a distributed
             version of a machine proposed by Cardelli. The
             distributed channel machine groups pi processes at their
             channels (or locations), in contrast with the more common
             approach of incorporating additional location information
             within pi processes. We go on to describe the
             \emph{fusion machine}. It uses a form of concurrent
             constraints called \emph{fusions} - equations on channel
             names - to distribute fragments of these processes
             between remote channels. This fragmentation avoids the
             movement of large continuations between locations, and
             leads to a more efficient implementation model.",
  OPTannotation =   "",
  folder =	 "Calculi 2"  
}



@InProceedings{Zimmer:00:SubtypTypAlgMobileAmbients,
  author = 	 "Zimmer, Pascal",
  title = 	 "Subtyping and Typing Algorithms for Mobile Ambients",
  booktitle =    "Proceedings of the Third International Conference of Foundations of Software Science and Computation Structures (FOSSACS'00)",
  pages = 	 "375--390",
  year = 	 2000,
  editor = 	 "Tiuryn, Jerzy",
  volume = 	 1784,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "The ambient calculus was designed to model mobile
             processes and study their properties. A first type system
             was proposed by Cardelli-Gordon-Ghelli to prevent
             run-time faults. We extend it by introducing subtyping
             and present a type-checking algorithm which returns a
             minimal type relatively to this system. By the way, we
             also add two new constructs to the language. Finally, we
             remove the type annotations from the syntax and give a
             type-inference algorithm for the original type system.",
  annote = 	 {},
  folder =     "Calculi 2"
}


@Article{Sangiorgi:01:AsyncProcCalcFirstHigherParad,
  author = 	 "Sangiorgi, Davide",
  title = 	 "Asynchronous Process Calculi: the First- and Higher-order Paradigms (Tutorial)",
  journal = 	 j-THEO-CS,
  year = 	 2001,
  volume = 	 253,
  number = 	 2,
  pages = 	 "311--350",
  annote = 	 "Full abstraction proof of compilation",
  abstract = "We compare the first- and the higher-order paradigms for
             the representation of mobility in process calculi. The
             prototypical calculus in the first-order paradigm is the
             pi-calculus. Here, we focus on an asynchronous
             pi-calculus (Lpi) that may be regarded as the basis of
             some experimental programming languages (or proposal of
             programming languages) like Pict, Join, Blue. We extend
             Lpi so to allow the communication of higher-order values,
             that is values that may contain processes, and show that
             the extension does not add expressiveness: the resulting
             higher-order calculus can be compiled down into Lpi. This
             paper is mostly a tutorial. It also contains original
             contributions. The main one is the full abstraction
             proof, which, with respect to previous proofs, is simpler
             and does not rely on certain non-finitary features of the
             languages such as infinite summation. Another
             contribution is the study of optimisations of the
             compilation, with which we are able to handle recursive
             types and to prove full abstraction also for strong
             behavioural equivalences.",
  folder =    ""
}


@Article{Glabbeek:94:WhatIsBrancingTime,
  author =       "Glabbeek, Rob J. van",
  title =        "What is branching time and why to use it?",
  journal =      "The Concurrency Column, Bulletin of the EATCS",
  year =         1994,
  volume =       53,
  editor =       "Nielsen, Mogens",
  OPTnumber =    {},
  pages =        "190--198",
  abstract = "The concept of branching time in the semantics of
             concurrent systems is well known and well
             understood. Still a formal definition of what it means
             for a model or equivalence to respect branching time has
             never explicitly be given. This note proposes such a
             definition. Additionally the opportunity is taken to
             voice an old but poorly understood argument for using
             branching time semantics instead of models or
             equivalences that are fully abstract with respect to some
             notion of observability.",
  annote = "Proposes a definition of branching time, and what it
              means to respect it. A semantic equivalence respects the
              branching structure of processes iff it is finer than or
              equal to branching bisimulation equivalence.

              If we look at the strict branching structure tree
              equivalence would be a preferred option.",
  folder =    "Calculi 2"
}


@InProceedings{Jeffrey:99:TowardsTheoBisimLocalNames,
  author =       "Jeffrey, Alan and Rathke, Julian",
  title =        "Towards a Theory of Bisimulation for Local Names",
  booktitle =    "Proceedings of the 14th {IEEE} Symposium on Logic in Computer Science (LICS'99)",
  pages =        "56--66",
  year =         1999,
  OPTeditor =    {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  publisher = pub-IEEE,
  abstract = "Pitts and Stark have proposed the nu-calculus as a
             language for investigating the interaction of unique name
             generation and higher-order functions. They developed a
             sound model based on logical relations, but left
             completeness as an open problem. In this paper, we
             develop a complete model based on bisimulation for a
             labelled transition system semantics. We show that
             bisimulation is complete, but not sound, for the
             nu-calculus. We also show that by adding assignment to
             the nu-calculus, bisimulation becomes sound and
             complete. The analysis used to obtain this result
             illuminates the difficulties involved in finding fully
             abstract models for nu-calculus proper.",
  annote =    "A predecessor to \cite{Jeffrey:02:TheoryBisimFragConcMLLocalNames}",
  folder =    ""
}


@InProceedings{Germain:02:AbstrMachHODistProcCalc,
  author = 	 "Germain, Florence and Lacoste, Marc and Stefani, Jean-Bernard",
  title = 	 "An Abstract Machine for a Higher-Order Distributed Process Calculus",
  booktitle =    "Proceedings of EATCS International Workshop of Foundations of Wide Area Network Computing (F-WAN'02)",
  OPTpages = 	 {},
  year = 	 2002,
  editor =       "Sassone, Vladimiro",
  volume = 	 66,
  issue =        3,
  series =       ser-ENTCS,
  publisher =    pub-ELS,
  abstract = "This paper presents the formal specification of an
             abstract machine for the M-calculus, a new distributed
             process calculus. The M-calculus can be understood as an
             extension of the Join calculus that realizes an original
             combination of the following features: programmable
             localities, higher-order functions and processes, process
             mobility, and dynamic binding. Our abstract machine
             covers these different features and presents a modular
             structure that clearly separates the sequential
             (functional) evaluation mechanism from the execution
             core, and the latter from basic marshalling, location and
             routing mechanisms.",
  annote = 	 "Why did I download this article ???. Maybe it is related to the Fusion Machine",
  folder =    "Calculi 2"
}


@TechReport{Ferreira:95:TheoryWeakBisimCoreCML,
  author = 	 "Ferreira, William and Hennessy, Matthew and Jeffrey, Alan",
  title = 	 "A Theory of Weak Bisimulation for Core CML",
  institution =  {University of Sussex},
  type = {Computer Science Report},
  year = 	 1995,
  number = 	 "1995:05",
  abstract = "Concurrent ML is an extension of Standard ML of New
             Jersey with concurrent features similar to those of
             process algebra. Reppy has given it an operational
             semantics based on reductions of configurations, using
             entire programs rather than program fragments. The
             existing semantics are not, therefore compositional, and
             do not support compositional reasoning (for example
             equational reasoning about program fragments). We present
             a compositional operational semantics for a fragment of
             CML, based on higher-order process algebra, and use this
             to define weak bisimulation for CML. We give some small
             examples of proofs about CML expressions and show that
             our semantics corresponds to Reppy's up to weak
             first-order bisimulation."
}

@InProceedings{Abramsky:98:,
  author = 	 "Abramsky, Samson and McCusker, Guy",
  title = 	 "Game Semantics",
  booktitle = "Logic and Computation: Proceedings of the 1997 Marktoberdorf Summer School",
  OPTpages = 	 {},
  year = 	 1998,
  editor = 	 "Schwichtenberg, Helmut and Berger, Ulrich", 
  volume = 	 165,
  series = 	 ser-SERS-f,
  publisher =    pub-SV,
  OPTnote = 	 {},
  annote = "These notes contain an informal introduction to some of
              the ideas in game semantics, and an account of full
              abstraction results for functional languages and
              extensions with state and control.",
  folder =    "Div 2"
}

@Article{Miller:99:FoundaAspecSyntax,
  author = 	 "Miller, Dale and Palamidessi, Catuscia",
  title = 	 "Foundational Aspects of Syntax",
  journal = 	 j-CSUR,
  year = 	 1999,
  volume = 	 31,
  number = 	 "3es",
  pages = 	 "11",
  annote = "Variable binders complicates formal specification and
              symbolic processing. Solution: Higher-order abstract syntax. ",

  folder =    "Div 2"
}


@InCollection{Aceto:01:StructOperatSeman,
  author = 	 "Aceto, Luca and Fokkink, Wan J. and Verhoef, Chris",
  title = 	 "Structural Operational Semantics",
  booktitle = 	 "Handbook of Process Algebra",
  pages = 	 "197--292",
  publisher =    pub-ESP,
  year = 	 2001,
  editor = 	 "Bergstra, Jan A. and Ponse, Alban and Smolka, Scott",
  chapter = 	 3,
  annote = "Comprehensive introduction to Structural Operational
           Semantics. Explains most of the underlying theory and
           contains lots of pointer to literature. Contains: LTS, TSS,
           conservative extensions, congruence formats, higher-order
           language, and denotational semantics.",
  folder =    "Div 2"
}


@Article{Verhoef:95:CongTheoSOSPrediNegaPrem,
  author = 	 "Verhoef, Chris",
  title = 	 "A Congruence Theorem for Structured Operational Semantics with Predicates and Negative Premises",
  journal = 	 j-NOR-COMP,
  year = 	 1995,
  volume = 	 2,
  number = 	 2,
  pages = 	 "274--302",
  abstract = "We proposed a syntactic format, the \emph{panth} format,
             for structured operational semantics in which besides
             ordinary transitions also predicates, negated predicates,
             and negative transitions may occur such that if the rules
             are stratifiable, strong bisimulation equivalence is a
             congruence for all the operators that can be defined
             within the panth format. To show that this format is
             useful we took some examples from the literature
             satisfying the \emph{panth} format but no formats
             proposed by others. The examples touch upon issues such
             as priorities, termination, convergence, discrete time,
             recursion, (infinitary) Hennessy-Milner logic, and
             universal quantification.",
  annote = "Panth format to ensure that bisimilarity is a
              congruence. Relevant wrt. bisimulation congruences",
  folder =    ""
}



@Book{Girard:90:ProofsAndTypes,
  author = 	 "Girard, Jean-Yves and Lafont, Yves and Taylor, Paul",
  title = 	 "Proofs and Types",
  publisher = 	 pub-CUP,
  year = 	 1990,
  annote = 	 "Proof theory with a computer science slant",
  url = "http://www.dcs.qmw.ac.uk/~pt/stable/prot.ps.gz",
  about = "This little book comes from a short graduate course on
          typed $\lambda$-calculus given at the Universit{\'e} Paris
          VII in the autumn term of 1986--7. It is not intended to be
          encyclopedic --- the Church-Rosser theorem, for instance, is
          not proved --- and the selection of topics was really quite
          haphazard. Some very basic knowledge of logic is needed, but
          we will never go into tedious details. Some book in proof
          theory may be useful afterwards to complete the information
          on those points which are lacking.",
  folder =     ""
}

@Article{Barendregt:97ImpactLambdaCalc:,
  author = 	 "Barendregt, Henk",
  title = 	 "The Impact of the Lambda Calculus",
  journal = 	 "Bulletin of Symbolic Logic",
  year = 	 1997,
  volume = 	 3,
  number = 	 2,
  pages = 	 "181--215",
  abstract = "One of the most important contributions of A. Church to
             logic is his invention of the lambda calculus. We present
             the genesis of this theory and its two major areas of
             application: the representation of computations and the
             resulting functional programming languages on the one
             hand and the representation of reasoning and the
             resulting systems of computer mathematics on the other
             hand.",
  annote = 	 {},
  folder =    ""
}


@InProceedings{Wischik:04:StrongBisimExpliFusionCalc,
  author = 	 "Wischik, Lucian and Gardner, Philippa",
  title = 	 "Strong Bisimulation for the Explicit Fusion Calculus",
  booktitle = "Proceedings of the 7th International Conference of Foundations of Software Science and Computation Structures (FOSSACS'04)",
  pages = 	 "484--498",
  year = 	 2004,
  editor = 	 "Walukiewicz, Igor",
  volume = 	 2987,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "The pi calculus holds the promise of compile-time checks
             for whether a given program will have the correct
             interactive behaviour. The theory behind such checks is
             bisimulation. In the synchronous pi calculus, it is
             well-known that the various natural definitions of
             (strong) bisimulation yield different relations. In
             contrast, for the asynchronous pi calculus, they collapse
             to a single relation. We show that the definitions
             transfer naturally from the pi calculus to the explicit
             fusion calculus (a symmetric variant of the synchronous
             pi calculus), where they also collapse, and yield a
             simpler theory.

             The important property of explicit fusions is that an
             explicit fusion in parallel with a term allows fused
             names to be substituted for each other. This means that
             parallel contexts become as discriminating as arbitrary
             contexts, and that open bisimilarity is more natural for
             the explicit fusion calculus than it was for the pi
             calculus. This is significant because [lsquo] open
             [rsquo] is the principle behind automated
             bisimilarity-checkers.",
  annote = 	 "Relevant for bisimulation tech.rep",
  folder =    ""
}

@Misc{BPLproject,
  author = 	 "{Lars Birkedal (principal investigator)}",
  title = 	 "{Bigraphical Programming Languages (BPL) Project}",
  year = 	 "2004-2008",
    folder =    "http://www.itu.dk/research/theory/bpl
"
}



@Misc{Apt:01:LogicProgParadigmAndProlog,
  author = 	 "Apt, Krzysztof R.",
  title = 	 "The Logic Programming Paradigm and Prolog",
  howpublished = "Computing Research Repository (CoRR), cs.PL/0107013",
  year = 	 2001,
  abstract = "This is a tutorial on logic programming and Prolog
             appropriate for a course on programming languages for
             students familiar with imperative programming.",
  annote = 	 "Just to brush up my Prolog",
  folder =    "Div 2"
}


@Book{Nielson:92:SemanticsWithApplications,
  author = 	 "Nielson, Hanne Riis and Nielson, Flemming",
  title = 	 "Semantics with Applications: A Formal Introduction",
  publisher = 	 pub-WILEY,
  year = 	 1992,
  note = 	 "Revised edition, 1999",
  annote = 	 {},
  url = "http://www.daimi.au.dk/~bra8130/Wiley_book/wiley.ps.gz",
  folder =    "Books + Theses 2"
}


@Article{Apt:81:TenYearsHoareLogic,
  author = 	 "Apt, Krzysztof R.",
  title = 	 "Ten Years of Hoare's Logic: A Survey\--Part {I}",
  journal = 	 "ACM Transactions on Programming Languages and Systems (TOPLAS)",
  year = 	 1981,
  volume = 	 3,
  number = 	 4,
  pages = 	 "431--483",
  doi = {http://doi.acm.org/10.1145/357146.357150},
  OPTnote = 	 {},
  annote = 	 {},
  folder =    ""
}


@Article{Glabbeek:97:NotesMethodoCCSandCSP,
  author = 	 "Glabbeek, Rob J. van",
  title = 	 "Notes on the Methodology of {CCS} and {CSP}",
  journal = 	 j-THEO-CS,
  year = 	 1997,
  volume = 	 177,
  number = 	 2,
  pages = 	 "329--349",
  annote = 	 "Comparison of CCS and CSP. Just read for fun.",
  abstract = "In this paper the methodology of some theories of
             concurrency (mainly CCS and CSP) is analysed, focusing on
             the following topics: the representation of processes,
             the identification issue, and the treatment of
             nondeterminism, communication, recursion, abstraction,
             divergence and deadlock behaviour. Process algebra turns
             out to be a useful instrument for comparing the various
             theories.",
  folder =    "Calculi 2"
}






@PhdThesis{Dennis:98:ProofPlanningCoinduction,
  author = 	 "Dennis, Louise A.",
  title =        "Proof Planning Coinduction",
  school = 	 "Department of Artificial Intelligence, University of Edinburgh",
  year = 	 1998,
  OPTtype = 	 {},
  OPTnote = 	 "Unpublished ????",
  annote = "This thesis contains some relevant introductory
              chapters: Non-well founded sets, coinductive principles
              and definitions, fixed points, and coinduction and
              functional languages.",
  folder =    "Books + Theses 2"
}



@TechReport{Godskesen:02:AnImpleMRCalculus,
  author = 	 "Godskesen, Jens Christian and Hildebrandt, Thomas and
                 S{\o}ren Eduard Jacobsen ",
  title = 	 "An Implementation of the {MR} Calculus",
  institution =  "IT University of Copenhagen",
  year = 	 2002,
  OPTtype = 	 {},
  number = 	 "TR-2002-14",
  abstract = "We demonstrate a simulator for the Mobile Resource
             Calculus (MR), called MRsim. First, an overview of the
             syntax and semantics of MR is given, along with an
             explanation of how the calculus is implemented. The
             second part of the paper gives an example of how the
             simulator is used.",
  annote = 	 {},
  url = "http://www.itu.dk/Internet/graphics/ITU-library/Internet/Forskning/Technical_Reports/ITU-TR-2002-14.ps.gz",
  folder =    ""
}

@MastersThesis{XMLstoremsc:02,
  author = 	 "Thorn, Tine and Fennestad, Mikkel and Baumann, Anders",
  title = 	 "A distributed, value oriented XML Store",
  school = 	 "IT University of Copenhagen",
  year = 	 2002,
  }

@MastersThesis{XMLstoremscPedersen:02,
  author = 	 "Pedersen, Kasper B. and Pedersen, Jesper T.",
  title = 	 "Value-oriented XML Store",
  school = 	 "IT University of Copenhagen",
  year = 	 2002,
  }

@MastersThesis{XMLstoremsc:04,
  author = 	 "Ambus, Thomas",
  title = 	 "Multiset Discrimination for Internal and External Data",
  school = 	 "Dept. of Computer Science Copenhagen University (DIKU)",
  year = 	 2004,
  }
@MastersThesis{ReactiveXML:04,
  author = 	 "Winther, Jacob W.",
  title = 	 "Reactive XML",
  school = 	 "IT University of Copenhagen",
  year = 	 2004,
  }



@Unpublished{XMLstoreintro:03,
  author = 	 "Thorn, Tine and Fennestad, Mikkel and Baumann, Anders and Sestoft, Peter",
  title = 	 "A peer-to-peer, value oriented XML Store",
  note = "Short introduction to the first version of XML Store",
  year = 	 2003,
  institution = "IT University of Copenhagen",
  annote = 	 "unpulished draft"
}


@Unpublished{Wadler:00:ProofsArePrograms,
  author = 	 "Wadler, Philip",
  title = 	 "Proofs are Programs: 19th Century Logic and 21st Century Computing",
  note = "This is a variant of New Languages, Old Logic, which
         appeared in Dr Dobbs Journal, special supplement on Software
         in the 21st century, December 2000",
  year = 	 2000,
  abstract = "As the 19th century drew to a close, logicians
             formalized an ideal notion of proof. They were driven by
             nothing other than an abiding interest in truth, and
             their proofs were as ethereal as the mind of God. Yet
             within decades these mathematical abstractions were
             realized by the hand of man, in the digital
             stored-program computer. How it came to be recognized
             that proofs and programs are the same thing is a story
             that spans a century, a chase with as many twists and
             turns as a thriller. At the end of the story is a new
             principle for designing programming languages that will
             guide computers into the 21st century.",
  annote = 	 "Curry-Howard isomorphi for dummies"
}


@InCollection{Bradfield:01:ModalLogicsAndMuCalculi,
  author = 	 "Bradfield, Julian C. and Stirling, Colin",
  title = 	 "Modal logics and mu-calculi: an introduction",
  pages = 	 "293--330",
  booktitle = 	 "Handbook of Process Algebra",
  publisher =    pub-ESP,
  year = 	 2001,
  editor = 	 "Bergstra, Jan A. and Ponse, Alban and Smolka, Scott",
  chapter = 	 4,
  abstract = "We briefly survey the background and history of modal
             and temporal logics. We then concentrate on the modal
             mu-calculus, a modal logic which subsumes most other
             commonly used logics. We provide an informal
             introduction, followed by a summary of the main
             theoretical issues. We then look at model-checking, and
             finally at the relationship of modal logics to other
             formalisms.",
  annote = 	 {},
  folder =    "",
}


@TechReport{Winskel:94:ModelsForConcurrency,
  author = 	 "Winskel, Glynn and Nielsen, Mogens",
  title = 	 "Models for Concurrency",
  institution =  uni-BRICS,
  year = 	 1994,
  type = 	 "Report Series",
  number = 	 "RS-94-12",
  address = 	 addr-daimi,
  abstract = "This report surveys a range of models for parallel
             computation to include interleaving models like
             transition systems, synchronisation trees and languages
             (often called Hoare traces in this context), and models
             like Petri nets, asynchronous transition systems, event
             structures, pomsets and Mazurkiewicz traces where
             concurrency is represented more explicitly by a form of
             causal independence. The presentation is unified by
             casting the models in a category-theoretic framework. One
             aim is to use category theory to provide abstract
             characterisations of constructions like parallel
             composition valid throughout a range of different models
             and to provide formal means for translating between
             different models.

             A knowledge of basic category theory is assumed, up to an
             acquaintance with the notion of adjunction.",
  OPTnote = 	 "144 pp. Appears as a chapter in the {\em
                  Handbook of Logic and the Foundations of
                  Computer Science}, vol.\ 4, pages 1--148,
                  Oxford University Press, 1995.",
  annote = 	 {},
  folder =    ""
}



@Article{Alstrup:00:OptimalPointerAlgNCADynamicTrees,
  author = "Alstrup, Stephen and Thorup,  Mikkel",
  title = {Optimal pointer algorithms for finding nearest common ancestors in dynamic trees},
  journal = 	 "Journal of Algorithms",
  year = 	 2000,
  volume = 	 35,
  number = 	 2,
  pages = 	 "169--188",
  publisher = pub-AP,
  doi = {http://dx.doi.org/10.1006/jagm.2000.1079},
  annote = 	 {},
  folder = "AD"
}


@Article{Alstrup:97:OptiOnlineDecrementalConnectivityTrees,
  author = 	 "Alstrup, Stephen and Secher, Jens Peter and Spork, Maz",
  title = 	 "Optimal On-line Decremental Connectivity in Trees",
  journal = 	 "Information Processing Letters",
  year = 	 1997,
  volume = 	 64,
  number = 	 4,
  pages = 	 "161--164",
  annote = 	 {},
  folder = "AD"
}


@InProceedings{Alstrup:00:WordEncodingTreeConnectivityWorks,
  author = 	 "Alstrup, Stephen and Secher, Jens Peter and Thorup, Mikkel",
  title = 	 "Word encoding tree connectivity works",
  booktitle =    "Proceedings of the 11th annual ACM-SIAM symposium on Discrete algorithms (SODA'00)",
  pages = 	 "498--499",
  year = 	 2000,
  OPTlocation = {San Francisco, California, United States},
  publisher = {Society for Industrial and Applied Mathematics},
  annote = 	 {},
  folder = "AD"
}




@Unpublished{Miltersen:98:UniversalHashing,
  author = 	 "Miltersen, Peter Bro",
  title = 	 "Universal Hashing",
  note = 	 "Lecture note for 'Pearls of Theory' at University of Aarhus",
  year = 	 1998,
  abstract = "Hashing began as a purely heuristic method for
             implementing symbol tables. It moved into the hardcore
             theory of algorithms with Carter and Wegman's analysis of
             the concept of universality. It went on to play an
             important role in several of the most important
             constructions in abstract complexity theory and
             cryptography. And now, having matured in this manner, it
             gets used in practice in ways the original symbol table
             implementors could not have dreamed of! We shall track
             this exciting career of the hash function.",
  annote = 	 {},
  folder =    "AD"
}



@Unpublished{Gudmund:00:vanEmdeBoasTraeer,
  author = 	 "Gudmund Skovbjerg Frandsen",
  title = 	 "van {E}mde {B}oas Tr\ae er",
  note = 	 "Noter",
  year = 	 2000,
  annote = 	 {},
  folder =    "AD"
}


@InProceedings{Alstrup:02:NCASurveyAndNewDistributedAlg,
  author = 	 "Alstrup, Stephen and Gavoille, Cyril and Kaplan, Haim and Rauhe, Theis",
  title = 	 "Nearest Common Ancestors: {A} Survey and a new Distributed Algorithm",
  booktitle =    "Proceedings of the 14th annual ACM symposium on Parallel algorithms and architectures (SPAA'02)",
  pages =        "258--264",
  year = 	 2002,
  OPTlocation =  {Winnipeg, Manitoba, Canada},
  doi =          {http://doi.acm.org/10.1145/564870.564914},
  publisher =    pub-ACM,
  abstract = "Several papers describe linear time algorithms to
             preprocess a tree, such that one can answer subsequent
             nearest common ancestor queries in constant time. Here,
             we survey these algorithms and related results. A common
             idea used by all the algorithms for the problem is that a
             solution for complete binary trees is
             straightforward. Furthermore, for complete binary trees
             we can easily solve the problem in a distributed way by
             labeling the nodes of the tree such that from the labels
             of two nodes alone one can compute the label of their
             nearest common ancestor. Whether it is possible to
             distribute the data structure into short labels
             associated with the nodes is important for several
             applications such as routing. Therefore, related labeling
             problems have received a lot of attention
             recently.Previous optimal algorithms for nearest common
             ancestor queries work using some mapping from a general
             tree to a complete binary tree. However, it is not clear
             how to distribute the data structures obtained using
             these mappings. We conclude our survey with a new simple
             algorithm that labels the nodes of a rooted tree such
             that from the labels of two nodes alone one can compute
             in constant time the label of their nearest common
             ancestor. The labels assigned by our algorithm are of
             size $O(\log n)$ bits where $n$ is the number of nodes in
             the tree. The algorithm runs in $O(n)$ time.",
  annote = {},
  folder = "AD"
}


@InProceedings{Alstrup:02:SmallInduced-UniversalGraphs,
  author =       "Alstrup, Stephen and Rauhe, Theis",
  title =        "Small Induced-Universal Graphs and Compact Implicit Graph Representations",
  booktitle =    "Proceedings of the 43rd Symposium on Foundations of Computer Science (FOCS'02)",
  pages =        "53--62",
  year = 	 2002,
  publisher =    {IEEE Computer Society},
  abstract = "We show that there exists a graph $G$ with $n \cdot
             2^{0(\log* n)}$ nodes, where any forest with $n$ nodes is a
             node-induced subgraph of $G$. Furthermore, the result
             implies existence of a graph with $n^k 2^{0(\log* n)}$ nodes
             that contains all $n$-node graphs of fixed arboricity $k$ as
             node-induced subgraphs. We provide a lower bound of
             $\Omega (n^k)$ for the size of such a graph. The upper
             bound is obtained through a simple labeling scheme for
             parent queries in rooted trees.",
  annote = 	 {},
  folder = "AD"
}


@Unpublished{Alstrup:02:MaintainingDiameterCenterMedianFullyDynamic,
  author = 	 "Alstrup, Stephen and Holm, Jacob and de Lichtenberg, Kristian and Thorup, Mikkel",
  title = 	 "Maintaining Diameter, Center, and Median of Fully-Dynamic Trees with Top Trees",
  note = 	 "Working draft",
  year = 	 2002,
  annote = 	 {},
  folder =    "AD",
}



@TechReport{Holm:97:Poly-logarithmicDeterministicFully-dynamicConnectivityAndMST,
  author = 	 "Holm, Jacob and de Lichtenberg, Kristian and Thorup, Mikkel",
  title = 	 "Poly-Logarithmic Deterministic Fully-Dynamic Graph Algorithms {I}: Connectivity and Minimum Spanning Tree",
  institution =  "University of Copenhagen, Department of Computer Science",
  year = 	 1997,
  number = 	 "DIKU-TR-97/17",
  annote = 	 {},
  url = "http://www.diku.dk/publikationer/tekniske.rapporter/1997/97-17.ps.gz",
  folder =    "AD"
}


@InProceedings{Holm:98:Poly-logarithmicDeterministicFully-dynamicGraphAlg,
  author = 	 "Holm, Jacob and de Lichtenberg, Kristian and Thorup, Mikkel",
  title = 	 "Poly-logarithmic deterministic fully-dynamic graph algorithms for connectivity, minimum spanning tree, 2-edge, and biconnectivity",
  booktitle =    "Proceedings of the 30th Symposium on Theory of Computing (STOC'98)",
  pages = 	 "79--89",
  year = 	 1998,
  publisher = pub-ACM,
  annote = 	 {},
  folder =    "AD"
}


@InProceedings{Alstrup:01:OptimalStaticRangeReportingInOneDimension,
  author =       "Alstrup, Stephen and Brodal, Gerth St\o{}lting and Rauhe, Theis",
  title =        "Optimal Static Range Reporting in One Dimension",
  booktitle =    "Proceedings of the 33th Symposium on Theory of Computing (STOC'01)",
  pages = 	 "476--482",
  year = 	 2001,
  isbn = {1-58113-349-9},
  OPTlocation = {Hersonissos, Greece},
  doi = {http://doi.acm.org/10.1145/380752.380842},
  publisher = pub-ACM,
  annote = 	 {},
  folder =    "AD"
}


@InProceedings{Alstrup:98:MarkedAncestorProblems,
  author = 	 "Alstrup, Stephen and Husfeldt, Thore and Rauhe, Theis",
  title = 	 "Marked Ancestor Problems (Extended Abstract)",
  booktitle =    "Proceedings of the 39th Symposium on Foundations of Computer Science (FOCS'98)",
  pages = 	 "534--543",
  year = 	 1998,
  publisher = {IEEE Computer Society},
  abstract = "Consider a rooted tree whose nodes can be in two states:
             marked or unmarked. The marked ancestor problem is to
             maintain a data structure with the following operations:
             Mark(v) marks node v; unmark(v) removes any marks from
             node v; findfirst(v) returns the first marked node on the
             path from v to the root.We show tight upper and lower
             bounds for the marked ancestor problem. The lower bounds
             are proved in the cell probe model, the algorithms run on
             a unit-cost RAM.As easy corollaries we prove (often
             optimal) lower bounds on a number of problems. These
             include planar range searching, including the existential
             or emptiness problem, priority search trees, static tree
             union--find, and several problems from dynamic
             computational geometry, including segment intersection,
             interval maintenance, and ray shooting in the plane. Our
             upper bounds improve algorithms from various fields,
             including coloured ancestor problems and maintenance of
             balanced parentheses.",
  annote = 	 {},
  folder =    "AD"
}


@InProceedings{Alstrup:01:ACellProbeLowerBoundForDynamicNearest-NeighbourSearching,
  author = 	 "Alstrup, Stephen and Husfeldt, Thore and Rauhe, Theis",
  title = 	 "A Cell Probe Lower Bound for Dynamic Nearest-Neighbour Searching",
  booktitle = "Proceedings of the 12th annual ACM-SIAM symposium on Discrete algorithms (SODA'01)",
  pages = 	 "779--780",
  year = 	 2001,
  publisher = {Society for Industrial and Applied Mathematics},
  annote = 	 {},
  folder =    "AD"
}


@InProceedings{Alstrup:00:NewDataStructureForOrthogonalRangeSearching,
  author = 	 "Alstrup, Stephen and Brodal, Gerth St\o{}lting and Rauhe, Theis",
  title = 	 "New Data Structures for Orthogonal Range Searching",
  booktitle =    "Proceedings of the 41st Symposium on Foundations of Computer Science (FOCS'00)",
  pages = 	 "198--207",
  year = 	 2000,
  publisher = {IEEE Computer Society},
  annote = 	 {},
  folder =    "AD"
}





@Article{Vianu:03:AWebOdysseyFromCoddToXML,
  author =       "Vianu, Victor",
  title =        {A Web Odyssey: from {C}odd to {XML}},
  journal = 	 "ACM SIGMOD Record",
  year = 	 2003,
  volume = 	 32,
  number = 	 3,
  pages =        "68--77",
  issn = {0163-5808},
  doi = {http://doi.acm.org/10.1145/776985.776999},
  publisher = pub-ACM,
  annote = 	 {},
  abstract = "What does the age of the Web mean for database theory?
             It is a challenge and an opportunity, an exciting journey
             of rediscovery. These are some notes from the road.",
  folder =    "AXML"
}


@Misc{Bosak:97:XMLJavaFutureOfTheWeb,
  author = 	 "Bosak, Jon",
  title = 	 "{XML}, {J}ava, and the future of the {W}eb",
  howpublished = "\url{http://www.ibiblio.org/pub/sun-info/standards/xml/why/xmlapps.htm}",
  year = 	 1997,
  annote = 	 {},

  abstract = "The extraordinary growth of the World Wide Web has been
             fueled by the ability it gives authors to easily and
             cheaply distribute electronic documents to an
             international audience. As Web documents have become
             larger and more complex, however, Web content providers
             have begun to experience the limitations of a medium that
             does not provide the extensibility, structure, and data
             checking needed for large-scale commercial
             publishing. The ability of Java applets to embed powerful
             data manipulation capabilities in Web clients makes even
             clearer the limitations of current methods for the
             transmittal of document data.

             To address the requirements of commercial Web publishing
             and enable the further expansion of Web technology into
             new domains of distributed document processing, the World
             Wide Web Consortium has developed an Extensible Markup
             Language (XML) for applications that require
             functionality beyond the current Hypertext Markup
             Language (HTML). This paper [0] describes the XML effort
             and discusses new kinds of Java-based Web applications
             made possible by XML.",
  folder =    "AXML"
}


@Unpublished{Wadler:00:AFormalSemanticsOfPatternsXSLT,
  author = 	 "Wadler, Philip",
  title = 	 "A formal semantics of patterns in {XSLT}",
  note = 	 {Markup Technologies'99},
  year = 	 {2000},
  abstract = "This note presents a formal semantics of the pattern
             language from the 16 December 1998 draft of XSLT. The
             semantics is clear and concise, summarizing in one page
             of formulas what required about ten pages of prose to
             describe. With the aid of the semantics one can
             rigorously state and prove properties of the language;
             these properties helped to guide future development of
             the XSLT design. The semantics was developed using
             standard techniques from the programming language
             community, and this article provides a tutorial
             introduction to these techniques. While little here will
             be new to the language theorist, some of what is here may
             be of use to the markup technologist.",
  annote = 	 {},
  folder =    "AXML"
}


@Misc{Deutsch:02:AQueryLanguageForXML,
  author = 	 "Deutsch, Alin and Fernandez, Mary and Florescu, Daniela and Levy, Alon and Suciu, Dan",
  title = 	 "A Query Language for {XML}",
  howpublished = "\url{http://www8.org/w8-papers/1c-xml/query/query.html}",
  year = 	 2002,
  abstract = "An important application of XML is the interchange of
             electronic data (EDI) between multiple data sources on
             the Web. As XML data proliferates on the Web,
             applications will need to integrate and aggregate data
             from multiple source and clean and transform data to
             facilitate exchange. Data extraction, conversion,
             transformation, and integration are all well-understood
             database problems, and their solutions rely on a query
             language. We present a query language for XML, called
             XML-QL, which we argue is suitable for performing the
             above tasks. XML-QL is a declarative, ``relational
             complete'' query language and is simple enough that it
             can be optimized. XML-QL can extract data from existing
             XML documents and construct new XML documents.",
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Kuper:01:SubsumptionForXMLTypes,
  author = "Kuper, Gabriel M. and  Sim{\'e}on, J{\'e}r{\^o}me",
  title = {Subsumption for {XML} Types},
  booktitle = "Proceedings of the 8th International Conference on Database Theory (ICDT'01)",
  pages = 	 "331--345",
  year = 	 2001,
  volume = 	 1973,
  editor    = {Bussche, Jan Van den and Vianu, Victor},
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  annote = 	 {},
  abstract = "XML data is often used (validated, stored, queried, etc)
             with respect to different types. Understanding the
             relationship between these types can provide important
             information for manipulating this data. We propose a
             notion of subsumption for XML to capture such
             relationships. Subsumption relies on a syntactic mapping
             between types, and can be used for facilitating
             validation and query processing. We study the properties
             of subsumption, in particular the notion of the greatest
             lower bound of two schemas, and show how this can be used
             as a guide for selecting a storage structure. While less
             powerful than inclusion, subsumption generalizes several
             other mechanisms for reusing types, notably extension and
             refinement from XML Schema, and subtyping.",
  folder =    "AXML"
}



@InProceedings{Nestorov:98:ExtractingSchemaFromSemistructuredData,
  author =       "Nestorov, Svetlozar and Abiteboul, Serge and Motwani, Rajeev",
  title =        "Extracting Schema from Semistructured Data",
  booktitle =    "Proceedings of the 1998 ACM SIGMOD International Conference on Management of Data",
  year =         1998,
  pages = 	 "295--306",
  OPTeditor = 	 {},
  OPTlocation = {Seattle, Washington, United States},
  doi = {http://doi.acm.org/10.1145/276304.276331},
  publisher =    pub-ACM,
  abstract = "Semistructured data is characterized by the lack of any
             fixed and rigid schema, although typically the data has
             some implicit structure. While the lack of fixed schema
             makes extracting semistructured data fairly easy and an
             attractive goal, presenting and querying such data is
             greatly impaired. Thus, a critical problem is the
             discovery of the structure implicit in semistructured
             data and, subsequently, the recasting of the raw data in
             terms of this structure. In this paper, we consider a
             very general form of semistructured data based on
             labeled, directed graphs. We show that such data can be
             typed using the greatest fixpoint semantics of monadic
             datalog programs. We present an algorithm for approximate
             typing of semistructured data. We establish that the
             general problem of finding an optimal such typing is
             NP-hard, but present some heuristics and techniques based
             on clustering that allow efficient and near-optimal
             treatment of the problem. We also present some
             preliminary experimental results.",
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Klarlund:00:DSDASchemaLanguageForXML,
  author =       "Klarlund, Nils and M\o{}ller, Anders and Schwartzbach, Michael I.",
  title =        "{DSD}: {A} schema language for {XML}",
  booktitle =    {Proceedings of the third workshop on Formal methods in software practice},
  pages = 	 "101--111",
  year = 	 2000,
  OPTlocation = {Portland, Oregon, United States},
  doi = {http://doi.acm.org/10.1145/349360.351158},
  publisher =    pub-ACM,
  abstract = "XML (eXtensible Markup Language) is a linear syntax for
             trees, which has gathered a remarkable amount of interest
             in industry. The acceptance of XML opens new venues for
             the application of formal methods such as specification
             of abstract syntax tree sets and tree transformations. 

             A notation for defining a set of XML trees is called a
             schema language. Such trees correspond to a specific user
             domain, such as XHTML, the class of XML documents that
             make sense as HTML. A useful schema notation must:
             identify most of the syntactic requirements that the
             documents in the user domain follow; allow efficient
             parsing; be readable to the user; allow limited tree
             transformations corresponding to the insertion of
             defaults; be modular and extensible to support evolving
             classes of XML documents.

             In the present paper, we introduce the DSD (Document
             Structure Description) notation as our bid on how to meet
             the requirements above.",
  annote = 	 {},
  folder = "AXML"
}


@InProceedings{Simeon:02:EssenceOfXML,
  author =       {Sim{\'e}on, J{\'e}r{\^o}me and Philip Wadler},
  title =        "The Essence of {XML} (Preliminary Version)",
  booktitle =    "Proceedings of the 6th International Symposium on Functional and Logic Programming (FLOPS'02)",
  pages = 	 "21--46",
  year = 	 2002,
  editor = 	 "Zhenjiang Hu and Mario Rodr\'{\i}guez-Artalejo",
  volume = 	 2441,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "The World-Wide Web Consortium (W3C) promotes XML and
             related standards, including XML Schema, XQuery, and
             XPath. This paper describes a formalization XML Schema. A
             formal semantics based on these ideas is part of the
             official XQuery and XPath specification, one of the first
             uses of formal methods by a standards body. XML Schema
             features both named and structural types, with structure
             based on tree grammars. While structural types and
             matching have been studied in other work (notably XDuce,
             Relax NG, and previous formalizations of XML Schema),
             this is the first work to study the relation between
             named types and structural types, and the relation
             between matching and validation.",
  annote = 	 {},
  folder = "AXML"
}


@Article{Hosoya:03:RegularExpressionPatternMatchingForXML,
  author = 	 "Hosoya, Haruo and Pierce, Benjamin C.",
  title = 	 "Regular Expression Pattern Matching for {XML}",
  journal = 	 "Journal of Functional Programming",
  year = 	 2003,
  volume = 	 13,
  number = 	 6,
  pages = 	 "961--1004",
  url =          "http://journals.cambridge.org/bin/bladerunner?30REQEVENT=&REQAUTH=0&500000REQSUB=&REQSTR1=S0956796802004410",
  abstract = "We propose regular expression pattern matching as a core
             feature of programming languages for manipulating XML. We
             extend conventional pattern-matching facilities (as in
             ML) with regular expression operators such as repetition
             (*), alternation (|), etc., that can match arbitrarily
             long sequences of subtrees, allowing a compact pattern to
             extract data from the middle of a complex sequence. We
             then show how to check standard notions of exhaustiveness
             and redundancy for these patterns. Regular expression
             patterns are intended to be used in languages with type
             systems based on regular expression types. To avoid
             excessive type annotations, we develop a type inference
             scheme that propagates type constraints to pattern
             variables from the type of input values. The type
             inference algorithm translates types and patterns into
             regular tree automata, and then works in terms of
             standard closure operations (union, intersection, and
             difference) on tree automata. The main technical
             challenge is dealing with the interaction of repetition
             and alternation patterns with the first-match policy,
             which gives rise to subtleties concerning both the
             termination and precision of the analysis. We address
             these issues by introducing a data structure representing
             these closure operations lazily.",
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Hosoya:00:XDuceATypedXMLProcessingLanguagePrelimReport,
  author =       "Hosoya, Haruo and Pierce, Benjamin C.",
  title =        "{XDuce}: A Typed {XML} Processing Language (Preliminary Report)",
  booktitle =    "Proceedings of the Third International Workshop on the Web and Databases (WebDB'00)",
  pages = 	 "226--244",
  year = 	 2000,
  editor =       "Suciu, Dan and Vossen, Gottfried",
  volume = 	 1997,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  note  =        "Selected Papers",
  annote = 	 {},
  url = "http://www.cis.upenn.edu/~bcpierce/papers/xduce-prelim.ps",
  folder =    "AXML"
}


@InProceedings{Hosoya:00:RegularExpressionTypesForXML,
  author = 	 "Hosoya, Haruo and Vouillon, J{\'e}r{\^o}me and Pierce, Benjamin C.",
  title = 	 "Regular Expression Types for {XML}",
  booktitle =    "Proceedings of the 5th ACM SIGPLAN International Conference on Functional programming (ICFP'00)",
  pages = 	 "11--22",
  year = 	 2000,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  doi =          {http://doi.acm.org/10.1145/351240.351242},
  PTpublisher =  pub-ACM,
  OPTnote = 	 {},
  abstract = "We propose regular expression types as a foundation for
             XML processing languages. Regular expression types are a
             natural generalization of Document Type Definitions
             (DTDs), describing structures in XML documents using
             regular expression operators (i.e., *, ?, |, etc.) and
             supporting a simple but powerful notion of subtyping.The
             decision problem for the subtype relation is
             EXPTIME-hard, but it can be checked quite efficiently in
             many cases of practical interest. The subtyping algorithm
             developed here is a variant of Aiken and Murphy's
             set-inclusion constraint solver, to which are added
             several optimizations and two new properties: (1) our
             algorithm is provably complete, and (2) it allows a
             useful 'subtagging' relation between nodes with different
             labels in XML trees.",
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Hosoya:02:ValidationBooleanAttributeElementConstraints,
  author = 	 "Hosoya, Haruo and Murata, Makoto",
  title = 	 "Validation and Boolean operations for Attribute-Element Constraints",
  booktitle =    "Proceedings of the Workshop on Programming Languages Technologies for XML (PLAN-X'02)",
  OPTpages = 	 {},
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTseries = 	 {},
  OPTpublisher = {},
  abstract = "Algorithms for validation and boolean operations play a
             crucial role in developing XML processing systems
             involving schemas.  Although much effort has previously
             been made for treating {\em elements}, very few studies
             have paid attention to {\em attributes}.  This paper
             presents a validation and boolean algorithms for Clark's
             attribute-element constraints.  Although his mechanism
             has a prominent expressiveness and generality among other
             proposals, treating this is algorithmically challenging
             since naive approaches easily blow up even for typical
             inputs.  To overcome this difficulty, we have developed
             (1) a two-phase validation algorithm that uses what we
             call {\em attribute-element automata} and (2)
             intersection and difference algorithms that proceed by a
             ``divide-and-conquer'' strategy.",
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Avila-Campillo:,
  author = 	 "Avila-Campillo, Iliana and Green, Todd J. and Gupta, Ashish and Onizuka, Makoto and Raven, Demian and Suciu, Dan",
  title = 	 "{XMLTK}: An {XML} Toolkit for Scalable {XML} Stream Processing",
  booktitle =    "Proceedings of the Workshop on Programming Languages Technologies for XML (PLAN-X'02)",
  OPTpages = 	 {},
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTpublisher = {},
  abstract = "We describe a toolkit for highly scalable XML data
             processing, consisting of two components. The first is a
             collection of stand-alone XML tools, s.a. sorting,
             aggregation, nesting, and unnesting, that can be chained
             to express more complex restructurings. The second is a
             highly scalable XPath processor for XML streams that can
             be used to develop scalable solutions for XML stream
             applications. In this paper we discuss the tools, and
             some of the techniques we used to achieve high
             scalability. The toolkit is freely available as an
             open-source project.",
  annote = 	 {},
  folder =    "AXML"
}




@InProceedings{Benzaken:02:CDuceAWhitePaper,
  author = 	 "Benzaken, Veronique and Castagna, Giuseppe and Frisch, Alain",  
  title = 	 "CDuce: a white paper (working document)",
  booktitle =    "Proceedings of the Workshop on Programming Languages Technologies for XML (PLAN-X'02)",
  OPTpages = 	 {},
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTseries = 	 {},
  OPTpublisher = {},
  annote = 	 {},
  abstract = "In this paper, we present the functional language CDuce,
             discuss some design issues, and show its adequacy for
             working with XML documents. Peculiar features of CDuce
             are a powerful pattern matching, first class functions,
             overloaded functions, a very rich type system (arrows,
             sequences, pairs, records, intersections, unions,
             differences), precise type inference and a natural
             interpretation of types as sets of values. We also
             discuss how to add constructs for programming XML queries
             in a declarative (and, thus, optimizable) way and finally
             sketch a dispatch algorithm to demonstrate how static
             type information can be used in efficient compilation
             schemas.",
  url = "http://xml.coverpages.org/cduce-wp.pdf",
  folder =    "AXML",
}


@InProceedings{Connor:02:ProjectorPartiallyTypedLangQueryingXML,
  author = 	 "Connor, Richard and Lievens, David and Simeoni, Fabio and Neely, Steve and Russell, George",
  title = 	 "Projector: a partially typed language for querying {XML}",
  booktitle =    "Proceedings of the Workshop on Programming Languages Technologies for XML (PLAN-X'02)",
  OPTpages = 	 {},
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTseries = 	 {},
  OPTpublisher = {},
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Neven:02:AutomataLogicAndXML,
  author = 	 "Neven, Frank",
  title = 	 "Automata, Logic, and XML",
  booktitle =    "Proceedings of the 16th International Workshop on Computer Science Logic (CSL'02), Invited Lecture",
  pages = 	 "2--26",
  year = 	 2002,
  editor = 	 "Bradfield, Julian C.",
  volume = 	 2471,
  series = 	 ser-LNCS,
  OPTaddress = 	 "Edinburgh, Scotland, UK",
  publisher =    pub-SV,
  abstract = "We survey some recent developments in the broad area of
             automata and logic which are motivated by the advent of
             XML. In particular, we consider unranked tree automata,
             tree-walking automata, and automata over infinite
             alphabets. We focus on their connection with logic and on
             questions imposed by XML.",
  annote = 	 "See also \cite{Bradfield:02:ComputerScienceLogic}",
  folder =    "AXML"
}


@Article{Neven:02:AutomataTheoryForXMLResearchers,
  author = 	 "Neven, Frank",
  title = 	 "Automata Theory for {XML} Researchers",
  journal = 	 "ACM SIGMOD Record",
  year = 	 2002,
  volume = 	 31,
  number = 	 3,
  pages = 	 "39--46",
  publisher =    pub-ACM,
  annote = 	 {},
  folder =    "AXML"
}


@InProceedings{Neven:01:AutomataLogicBasedPatternLanguagesTreeStructuredData,
  author = 	 "Neven, Frank and Schwentick, Thomas",
  title = 	 "Automata- and Logic-Based Pattern Languages for Tree-Structured Data",
  booktitle =    "Proceedings of the Second International Workshop on Semantics in Databases, Revised Papers ('01)",
  pages = 	 "160--178",
  year = 	 2003,
  editor = 	 "Bertossi, Leopoldo E. and
                  Katona, Gyula O. H. and
                  Schewe, Klaus-Dieter and
                  Thalheim, Bernhard",
  volume = 	 2582,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "This paper surveys work of the authors on pattern
             languages for tree-structured data with XML as the main
             application in mind. The main focus is on formalisms from
             formal language theory and logic. In particular, it
             considers attribute grammars, query automata, treewalking
             automata, extensions of first-order logic, and monadic
             second-order logic. It investigates expressiveness as well
             as the complexity of query evaluation and some
             optimization problems. Finally, formalisms that allow
             comparison of attribute values are considered.",
  annote = 	 {},
  folder =    "AXML"
}
@inproceedings{ciancarini02coordination,
    author = "P. Ciancarini and R. Tolksdorf and F. Zambonelli",
    title = "{Coordination Middleware for {XML}-centric Applications}",
    booktitle = "Proc. {ACM}/{SIGAPP} Symp. on Applied Computing ({SAC})",
    publisher = "ACM Press",
    year = "2002",
    url = "citeseer.ist.psu.edu/ciancarini02coordination.html" }


@InProceedings{Abiteboul:04:PosActiveXML,
  author = 	 "Serge Abiteboul and Omar Benjelloun and Tova Milo",
  title = 	 "Positive Active {XML}",
  OPTcrossref =  {},
  OPTkey = 	 {},
  booktitle =    "Proceedings of PODS 2004",
  OPTpages = 	 {},
  year = 	 2004,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 {},
  OPTmonth = 	 {},
  OPTorganization = {},
  OPTpublisher = {},
  OPTnote = 	 {},
  OPTannote = 	 {}
}

@InProceedings{Abiteboul:02:ActiveXML,
  author = 	 "Serge Abiteboul and Omar Benjelloun and Ioana Manolescu and Tova Milo and Roger Weber",
  title = 	 "Active {XML}:Peer-to-Peer Data and Web Serivces Integration (Demo)",
  OPTcrossref =  {},
  OPTkey = 	 {},
  booktitle =    "Proceedings of the international VLDB Conference",
  OPTpages = 	 {},
  year = 	 2002,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 {},
  OPTmonth = 	 {},
  OPTorganization = {},
  OPTpublisher = {},
  OPTnote = 	 {},
  OPTannote = 	 {}
}

@InProceedings{Cardelli:00:SemistructuredComputation,
  author = 	 "Cardelli, Luca",
  title = 	 "Semistructured Computation",
  booktitle =    "Research Issues in Structured and Semistructured Database Programming. Proceedings of the 7th International Workshop on Database Programming Languages (DBPL'99), Invited Paper",
  pages = 	 "1--16",
  year = 	 2000,
  editor = 	 "Connor, Richard C. H. and
                 Mendelzon, Alberto O.",
  volume = 	 1949,
  series = 	 ser-LNCS,
  OPTaddress =   "Kinloch Rannoch, Scotland, UK",
  publisher =    pub-SV,
  abstract = "This paper is based on the observation that the areas of
             semistructured databases and mobile computation have some
             surprising similarities at the technical level. Both
             areas are inspired by the need to make better use of the
             Internet. Despite this common motivation, the technical
             similarities that arise seem largely accidental, but they
             should still permit the transfer of some techniques
             between the two areas. Moreover, if we can take advantage
             of the similarities and generalize them, we may obtain a
             broader model of data and computation on the Internet.",
  annote = 	 {},
  folder =    "AXML"
}


@Article{Cardelli:04:TQLQueryLangSemistrucDataBasedAmbientLogic,
  author = 	 "Cardelli, Luca and Ghelli, Giorgio",
  title = 	 "{TQL}: A Query Language for Semistructured Data Based on the Ambient Logic",
  journal = 	 j-MAT-STRUCT,
  year = 	 2004,
  volume = 	 14,
  pages = 	 "285--327",
  publisher =    pub-CUP,
  abstract = "The ambient logic is a modal logic proposed to describe
             the structural and computational properties of
             distributed and mobile computation. The structural part
             of the ambient logic is, essentially, a logic of labeled
             trees, hence it turns out to be a good foundation for
             query languages for semistructured data, much in the same
             way as first order logic is a fitting foundation for
             relational query languages. We define here a query
             language for semistructured data that is based on the
             ambient logic, and we outline an execution model for this
             language. The language turns out to be quite
             expressive. Its strong foundations and the equivalences
             that hold in the ambient logic are helpful in the
             definition of the language semantics and execution
             model.",
  annote = 	 {},
  folder = "AXML"
}


@InProceedings{Muller-Olm:99:ModelCheckingATutorialIntroduction,
  author = 	 "M{\"u}ller-Olm, Markus and Schmidt, David A. and Steffen, Bernhard",
  title = 	 "Model-Checking: A Tutorial Introduction",
  booktitle =    "Proceedings of the 6th International Symposium on Static Analysis (SAS'99)",
  pages = 	 "330--354",
  year = 	 1999,
  editor = 	 "Cortesi, Agostino and File, Gilberto",
  volume = 	 1694,
  series = 	 ser-LNCS,
  OPTaddress =   "Venice, Italy,",
  publisher =    pub-SV,
  abstract = "In the past two decades, model-checking has emerged as a
             promising and powerful approach to fully automatic
             verification of hardware systems. But model checking
             technology can be usefully applied to other application
             areas, and this article provides fundamentals that a
             practitioner can use to translate verification problems
             into model-checking questions. A taxonomy of the notions
             of ``model'', ``property'', and ``model checking'' are
             presented, and three standard model-checking approaches
             are described and applied to examples.",

  annote = 	 {},
  folder =    ""
}


@InProceedings{Castagna:01:TypingMobilityInSeal,
  author = 	 "Castagna, Giuseppe and Ghelli, Giorgio and Nardelli, Francesco Zappa",
  title = 	 "Typing Mobility in the {S}eal Calculus",
  booktitle =    "Proceedings of the 12th International Conference on
                 Concurrency Theory (CONCUR'01)",
  pages = 	 "82--101",
  year = 	 2001,
  editor = 	 "Larsen, Kim Guldstrand and Nielsen, Mogens",
  volume = 	 2154,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "The issue of this work is how to type mobility, in the
             sense that we tackle the problem of typing not only
             mobile agents but also their movement. This yields
             higher-order types for agents. To that end we first
             provide a new definition of the Seal Calculus that gets
             rid of existing inessential features while preserving the
             distinctive characteristics of the Seal model. Then we
             discuss the use of interfaces to type agents and define
             the type system. This type system induces a new
             interpretation of the types: interfaces describe
             interaction effects rather than, as it is customary,
             provided services. We discuss at length the difference of
             the two interpretations and justify our choice of the
             former.",
  annote = 	 {},
  folder =    "Models"
}



@Article{Caires:03:SpatialLogicForConcurrencyI,
  author = 	 "Caires, Lu{\'i}s  and Cardelli, Luca",
  title = 	 "A Spatial Logic for Concurrency ({P}art {I})",
  journal = 	 j-INFO-COMP,
  year = 	 2003,
  volume = 	 186,
  number = 	 2,
  pages = 	 "194--235",
  doi = {http://dx.doi.org/10.1016/S0890-5401(03)00137-8},
  publisher =    pub-AP,
  abstract = "We present a logic that can express properties of
             freshness, secrecy, structure, and behavior of concurrent
             systems. In addition to standard logical and temporal
             operators, our logic includes spatial operations
             corresponding to composition, local name restriction, and
             a primitive fresh name quantifier. Properties can also be
             defined by recursion; a central aim of this paper is then
             the combination of a logical notion of freshness with
             inductive and coinductive definitions of properties.",
  annote = "Introduces a mature semantic model for a spatial logic for
            concurrent systems modeled in the pi-calculus, presenting
            freshness and hidden name quantifiers and recursion as
            properly defined logical primitives.",
  folder = "Models"
}


@InProceedings{Caires:02:SpatialLogicForConcurrencyII,
  author = 	 "Caires, Lu{\'i}s  and Cardelli, Luca",
  title = 	 "A Spatial Logic for Concurrency ({P}art {II})",
  booktitle =    "Proceedings of the 13th International Conference on
                 Concurrency Theory (CONCUR'02)",
  OPTaddress =   "Brno, Czech Republic",
  editor =       "Brim, Lubos and Jancar, Petr and Kret\'{\i}nsk{\'y}, Mojm\'{\i}r and Kucera, Anton\'{\i}n",
  pages = 	 "209--225",
  year = 	 2002,
  volume = 	 2421,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "We present a modal logic for describing the spatial
             organization and behavior of distributed systems. In
             addition to standard logical and temporal operators, our
             logic includes spatial operations corresponding to
             process composition and name hiding, and a fresh name
             quantifier.",
  annote = "Defines a proof theory for spatial logic of
           \cite{Caires:03:SpatialLogicForConcurrencyI} based on a
           sequent calculus, that enjoys the cut-elimination
           property. The logic is extended with explicit
           permutations.",
  folder = "Models"
}


@TechReport{Joyal:94:BisimulationFromOpenMaps,
  author = 	 "Joyal, Andr{\'e} and Nielsen, Mogens and
                  Winskel, Glynn",
  title = 	 "Bisimulation from Open Maps",
  institution =  uni-BRICS,
  year = 	 1994,
  type = 	 "Report Series",
  number = 	 "RS-94-7",
  address = 	 addr-daimi,
  note = 	 "42~pp. Appears in LICS~'93 special issue of
                  {\em Information and Computation},
                  127(2):164--185, " # jun # " 1996",
  abstract = "An abstract definition of bisimulation is presented. It
             enables a uniform definition of bisimulation across a
             range of different models for parallel computation
             presented as categories. As examples, transition systems,
             synchronisation trees, transition systems with
             independence (an abstraction from Petri nets) and
             labelled event structures are considered.  On transition
             systems the abstract definition readily specialises to
             Milner's strong bisimulation. On event structures it
             explains and leads to a revision of history-preserving
             bisimulation of Rabinovitch and Traktenbrot, Goltz and
             van Glabeek. A tie-up with open maps in a (pre)topos, as
             they appear in the work of Joyal and Moerdijk, brings to
             light a promising new model, presheaves on categories of
             pomsets, into which the usual category of labelled event
             structures embeds fully and faithfully. As an indication
             of its promise, this new presheaf model has
             ``refinement'' operators, though further work is required
             to justify their appropriateness and understand their
             relation to previous attempts. The general approach
             yields a logic, generalising Hennessy-Milner logic, which
             is characteristic for the generalised notion of
             bisimulation.",
  annote = 	 {},
  url = "http://www.brics.dk/RS/94/7/BRICS-RS-94-7.ps.gz",
  folder = "Models"
}


@InProceedings{Jensen:03:BigraphsAndTransitions,
  author = 	 "Jensen, Ole H{\o}gh and Milner, Robin",
  title = 	 "Bigraphs and Transitions",
  booktitle =    "Proceedings of the 30rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'03)",
  pages = 	 "38--49",
  year = 	 2003,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  location = {New Orleans, Louisiana, USA},
  doi = {http://doi.acm.org/10.1145/604131.604135},
  publisher = pub-ACM,
  abstract = "A bigraphical reactive system (BRS) involves bigraphs,
             in which the nesting of nodes represents locality,
             independently of the edges connecting them. BRSs
             represent a wide variety of calculi for mobility,
             including $\pi$-calculus and ambient calculus. A
             labelled transition system (LTS) for each BRS is here
             derived uniformly, adapting previous work of Leifer and
             Milner, so that under certain conditions the resulting
             bisimilarity is automatically a congruence. For an
             asynchronous $\pi$-calculus, this LTS and its
             bisimilarity agree closely with the standard.",
  annote = 	 {},
  folder = "Models"
}


@MastersThesis{Nardelli:00:TypesForSealCalculus,
  author = 	 "Nardelli, Francesco Zappa",
  title = 	 "Types for the Seal Calculus",
  school = 	 "University of Pisa",
  year = 	 2000,
  annote = 	 "Read this thesis wrt. types for mobility",
  folder =    ""
}




@InProceedings{Clarke:93:VerificationTooelsForFinStateConcSyst,
  author = 	 "Clarke, Edmund M. and Grumberg, Orna and Long, David E.",
  title = 	 "Verification Tools for Finite-State Concurrent Systems",
  booktitle =    "A Decade of Concurrency --- Reflections and Perspectives",
  pages = 	 "124--175",
  year = 	 1994,
  OPTeditor = 	 {},
  volume = 	 803,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  annote = 	 "Survey of model checking by the inventors of the topic",
  folder =    ""
}


@Article{Clarke:94:ModelCheckingAndAbstraction,
  author = 	 "Clarke, Edmund M. and Grumberg, Orna and Long, David E.",
  title = 	 "Model Checking and Abstraction",
  journal = 	 "ACM Transactions on Programming Languages and Systems (TOPLAS)",
  year = 	 1994,
  volume = 	 16,
  number = 	 5,
  pages = 	 "1512--1542",
  doi =          {http://doi.acm.org/10.1145/186025.186051},
  publisher = pub-ACM,
  abstract = "We describe a method for using abstraction to reduce the
             complexity of temporal-logic model checking. Using
             techniques similar to those involved in abstract
             interpretation, we construct an abstract model of a
             program without ever examining the corresponding
             unabstracted model. We show how this abstract model can
             be used to verify properties of the original program. We
             have implemented a system based on these techniques, and
             we demonstrate their practicality using a number of
             examples, including a program representing a pipelined
             ALU circuit with over $10^{1300}$ states.",
  annote = 	 "Current research in model checking: exploit abstraction, symmetries and compositionality",
  folder =    ""
}


@InProceedings{Thomsen:89:ACalcOfHOCommuSyst,
  author = 	 "Thomsen, Bent",
  title = 	 "A Calculus of Higher Order Communicating Systems",
  booktitle =    {Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'89},
  pages = 	 "143--154",
  year = 	 1989,
  OPTeditor = 	 {},
  location = {Austin, Texas, United States},
  doi = {http://doi.acm.org/10.1145/75277.75290},
  publisher =    pub-ACM,
  abstract = "In this paper we present A Calculus of Higher Order
             Communicating Systems. This calculus considers sending
             and receiving processes to be as fundamental as
             nondeterminism and parallel composition. The calculus is
             an extension of CCS [Mil80] in the sense that all the
             constructions of CCS are included or may be derived from
             more fundamental constructs and most of the mathematical
             framework of CCS carries over almost unchanged. Clearly
             CCS with processes as first class objects is a powerful
             metalanguage and we show that it is possible to simulate
             the untyped $\lambda$-calculus in CHOCS. The relationship
             between CHOCS and the untyped $\lambda$-calculus is
             further strengthened by a result showing that the
             recursion operator is unnecessary in the sense that
             recursion can be simulated by means of process passing
             and communication. As pointed out by R. Milner in
             [Mil80], CCS has its limitations when one wants to
             describe unboundedly expanding systems as e.g. an
             unbounded number of procedure invocations in an
             imperative concurrent programming language. We show how
             neatly CHOCS may describe both call by value and call by
             reference parameter mechanisms for the toy language of
             chapter 6 in [Mil80].",
  annote = 	 {},
  folder =    ""
}


@TechReport{Osten:95:IntroductionToCategories,
  author = 	 "Osten, Jaap van",
  title = 	 "Basic Category Theory",
  institution =  uni-BRICS,
  year = 	 1995,
  type = 	 "Lecture Series",
  number = 	 "LS-95-1",
  address = 	 addr-daimi,
  note = 	 "vi+75 pp",
  abstract =      "This course was given to advanced
                  undergraduate and beginning Ph.D. students in
                  the fall of 1994 in Aarhus, as part of Glynn
                  Winskel's semantics course. It is, in the
                  author's view, the very minimum of category
                  theory one needs to know if one is going to use
                  it sensibly. Nevertheless, two topics are
                  breathed on, which may be skipped: there is a
                  glimpse of categorical logic, and there is a
                  treatment of the $\lambda$-calculus in
                  cartesian closed categories. These are there to
                  give the reader at least a very rough idea of
                  how the theory ``works''. The text contains a
                  bit over hundred exercises, varying in
                  difficulty, which supplement the treatment and
                  are warmly recommended. There is an elaborate
                  index.
                  
                  \subsubsection*{Contents}
                  
                  \begin{itemize}
                  \item[1] Categories and Functors 
                    \begin{itemize}
                    \item[1.1] Definitions and examples 
                    \item[1.2] Some special objects and arrows 
                    \end{itemize}
                  \item[2] Natural transformations 
                    \begin{itemize}
                    \item[2.1] The Yoneda lemma 
                    \item[2.2] Examples of natural
                      transformations 
                    \item[2.3] Equivalence of categories; an
                      example 
                    \end{itemize}
                  \item[3] (Co)cones and (co)limits 
                    \begin{itemize}
                    \item[3.1] Limits 
                    \item[3.2] Limits by products and equalizers 
                    \item[3.3] Colimits 
                    \end{itemize}
                  \item[4] A little piece of categorical logic 
                    \begin{itemize}
                    \item[4.1] Regular categories and subobjects 
                    \item[4.2] Coherent logic in regular
                      categories 
                    \item[4.3] The language $\cal L(C)$ and
                      theory $T(\cal C)$ associated to a regular
                      category $\cal C$ 
                    \item[4.4] Example of a regular category 
                    \end{itemize}
                  \item[5] Adjunctions 
                    \begin{itemize}
                    \item[5.1] Adjoint functors 
                    \item[5.2] Expressing (co)completeness by
                      existence of adjoints; preservation of
                      (co)limits by adjoint functors 
                    \end{itemize}
                  \item[6] Monads and Algebras 
                    \begin{itemize}
                    \item[6.1] Algebras for a monad 
                    \item[6.2] $T$-Algebras at least as complete
                      as $\cal D$ 
                    \item[6.3] The Kleisli category of a monad 
                    \end{itemize}
                  \item[7] Cartesian closed categories and the
                    $\lambda $-calculus 
                    \begin{itemize}
                    \item[7.1] Cartesian closed categories
                      (ccc's); examples and basic facts 
                    \item[7.2] Typed $\lambda$-calculus and
                      cartesian closed categories 
                    \item[7.3] Representation of primitive
                      recursive functions in ccc's with natural
                      numbers object 
                    \end{itemize}
                  \end{itemize}",
  annote = 	 {},
  url = "http://www.brics.dk/LS/95/1/BRICS-LS-95-1.ps.gz",
  folder =    ""
}



@Article{Honda:99:OnReduction-basedProcessSemantics,
  author = 	 "Honda, Kohei and Yoshida, Nobuko",
  title = 	 "On reduction-based process semantics",
  journal = 	 j-THEO-CS,
  year = 	 1995,
  volume = 	 151,
  number = 	 2,
  pages = 	 "437--486",
  abstract = "A formulation of semantic theories for processes which
             does not rely on the notion of observables or convergence
             is studied. The new construction is based solely on a
             reduction relation and equational reasoning, but can
             induce meaningful theories for processes, both in weak
             and strong settings. The resulting theories in many cases
             coincide with, and sometimes generalise,
             observation-based formulation of behavioural
             equivalence. The basic construction of reduction-based
             theories is studied, taking a simple name passing
             calculus (called -calculus) and its extensions as an
             example. Results concerning the application of our
             construction to other calculi are also briefly
             discussed.",
  annote = 	 "For bisimulation TechRep",
  folder =    ""
}


@Article{Cattani:04:ProfunctorsOpenMapsAndBisimulation,
  author = 	 "Cattani, Gian Luca and Winskel, Glynn",
  title = 	 "Profunctors, Open Maps and Bisimulation",
  journal = 	 j-MAT-STRUCT,
  year = 	 2004,
  OPTkey = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTpages = 	 {},
  note = 	 "Accepted for publications, April 2004",
  OPTannote = 	 {},
  OPTFolder =    "CTCS 2004"
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SKAL RETTES


@Unpublished{BiXMLvladi:04,
  author = 	 "Conforti, Giovanni and Macedonio, Damiano and Sassone, Vladimiro",
  title = 	 "Bigraphical Logics for {XML}",
  note = 	 {},
  OPTkey = 	 {},
  OPTmonth = 	 {},
  year = 	 2004,
  OPTannote = 	 {}
}

@Unpublished{BiLogSpaNomvladi:04,
  author = 	 "Conforti, Giovanni and Macedonio, Damiano and Sassone, Vladimiro",
  title = 	 "BiLogics: Spatial-Nominal Logics for Bigraphs",
  note = 	 {},
  OPTkey = 	 {},
  OPTmonth = 	 {},
  year = 	 2004,
  OPTannote = 	 {}
}

@InProceedings{Gardner:03:ModellingDynamicWebData,
  author =       {Gardner, Philippa and Maffeis, Sergio},
  title =        {Modelling Dynamic Web Data},
  booktitle =    "9th International Workshop on Database Programming Languages (DBPL'03)",
  pages = 	 "130--146",
  year = 	 2003,
  ee        = {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=2921{\&}spage=130},
  editor = 	 "Lausen, Georg and Suciu, Dan",
  volume = 	 2921,
  series = 	 ser-LNCS,
  publisher =    pub-SV,
  abstract = "We introduce Xd$\pi$, a peer-to-peer model for reasoning
             about the dynamic behaviour of web data. It is based on
             an idealised model of semi-structured data, and an
             extension of the $\pi$-calculus with process mobility and
             with an operation for interacting with data. Our model
             can be used to reason about behaviour found in, for
             example, dynamic web page programming, applet
             interaction, and service orchestration. We study
             behavioural equivalences for Xd$\pi$, motivated by
             examples.",
  OPTannote = 	 {},
  folder = ""
}

@PhdThesis{Vivas::,
  author = 	 "Vivas, Jos{\'e} Luis",
  title = 	 "MISSING TITLE",
  school = 	 "MISSING SCHOOL",
  year = 	 9999,
  OPTtype = 	 {},
  OPTnote = 	 "http://www.it.kth.se/~josev/thesis.html",
  annote = 	 {},
  folder =    "Books + Theses 2"
}


@Unpublished{Hildebrandt:04:HOMERLocalNames,
  author = 	 {Hildebrandt, Thomas and Godskesen, Jens Chr. and Bundgaard, Mikkel},
  title = 	 {Bisimulation Congruences for Higher-Order Mobile Embedded Resources with Local Names},
  note = 	 {In preparation},
  year = 	 2004,
  annote = 	 {}
}


@InProceedings{Bundgaard:04:ACPSEncNamePassingHOMER,
  author = 	 "Bundgaard, Mikkel and Hildebrandt, Thomas and Godskesen, Jens Chr.",
  title = 	 "A {CPS} Encoding of Name-Passing in Higher-Order Mobile Embedded Resources",
  booktitle =    "Proceedings of the 11th International Workshop on Expressiveness in Concurrency (EXPRESS'04)",
  OPTpages = 	 {},
  year = 	 2004,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  series = 	 ser-ENTCS,
  OPTaddress = 	 "London, Great Britain",
  publisher =    pub-ELS,
  note = 	 "To appear",
  abstract = "We present an encoding of the synchronous $\pi$-calculus
             in the calculus of Higher-Order Mobile Embedded Resources
             (Homer), a pure higher-order calculus with mobile
             computing processes in nested locations, defined as a
             simple, conservative extension of the core
             process-passing subset of Thomsen's Plain CHOCS.

             We prove that our encoding is fully abstract with respect
             to barbed bisimulation and sound with respect to barbed
             congruence. Our encoding demonstrates that higher-order
             process-passing together with mobile computing resources
             in (local) named locations are sufficient to express
             $\pi$-calculus name-passing. The encoding uses a novel
             continuation passing style to facilitate the encoding of
             synchronous communication.",
  annote = 	 {}
}

@InProceedings{Milner:04:BigraphsPetriNets,
  author = 	 "Milner, Robin",
  title = 	 "Bigraphs for Petri Nets",
  booktitle =    "Lectures on Concurrency and Petri Nets: Advances in Petri Nets",
  pages = 	 "686--701",
  year = 	 2004,
  editor    =    {Desel, J{\"o}rg and Reisig, Wolfgang and Rozenberg, Grzegorz},
  volume = 	 3098,
  series = 	 ser-LNCS,
  isbn =         "3-540-22261-8",
  publisher =    pub-SV,
  annote = 	 {},
  abstract = "A simple example is given of the use of bigraphical
             reactive systems (BRSs). It provides a behavioural
             semantics for condition-event Petri nets whose interfaces
             are named condition nodes, using a simple form of BRS
             equipped with a labelled transition system and its
             associated bisimilarity equivalence. Both of the latter
             are derived from the standard net firing rules by a
             uniform technique in bigraphs, which also ensures that
             the bisimilarity is a congruence. Furthermore, this
             bisimilarity is shown to coincide with one induced by a
             natural notion of experiment on condition-event nets,
             defined independently of bigraphs.  The paper is intended
             as a bridge between Petri net theory and bigraphs, as
             well as a pedagogical exercise in the latter.",
  folder =       "Bigraphs"
}

@TechReport{Barber:96:DualIntuitionLinearLogic,
  author = 	 "Barber, Andrew",
  title = 	 "Dual Intuitionistic Linear Logic",
  institution =  "LFCS, Department of Computer Science, University of
                 Edinburgh",
  year = 	 1996,
  number = 	 "ECS-LFCS-96-347",
  abstract = "We present a new intuitionistic linear logic, Dual
             Intuitionistic Linear Logic, designed to reflect the
             motivation of exponentials as translations of
             intuitionistic types, and provide it with a term
             calculus, proving associated standard type-theoretic
             results. We give a sound and complete categorical
             semantics for the type-system, and consider the
             relationship of the new type-theory to the more familiar
             presentation found for example in ``A term calculus for
             intuitionistic linear logic'' by Benton et al.",
  annote = 	 {},
  url = "http://www.lfcs.inf.ed.ac.uk/reports/96/ECS-LFCS-96-347/ECS-LFCS-96-347.ps.gz",
  folder =    ""
}




@InProceedings{Boudol:97:PiCalcDirecStyle,
  author = 	 "Boudol, G{\'e}rard",
  title = 	 "The $\pi$-calculus in Direct Style",
  booktitle = {Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL'97)},
  pages = 	 "228--242",
  year = 	 1997,
  location =     "Paris, France",
  doi =          "http://doi.acm.org/10.1145/263699.263726",
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  publisher =    pub-ACM,
  abstract = "This work is concerned with the foundations of
             higher-order concurrent programming. We focus on
             languages based on Milner's pi-calculus. Motivated by the
             observation that an indirect style of programming, where
             one explicitly manages ``result channels'', is enforced
             in such languages, we aim at designing a similar, but
             more flexible model for higher-order concurrency.

             We introduce a calculus which is a direct extension of
             both the lambda and the pi calculi. We give a simple type
             system for it, that encompasses both Curry's type
             inference for the lambda-calculus, and Milner's sorting
             for the pi-calculus as particular cases of typing. We
             observe that the various continuation passing style
             transformations for lambda-terms, written in our
             calculus, actually correspond to encodings already given
             by Milner and others for evaluation strategies of
             lambda-terms into the pi-calculus. Furthermore, the
             associated sortings correspond to well-known double
             negation translations on types. Finally we provide an
             adequate CPS transform from our calculus to the
             pi-calculus. This shows that the latter may be regarded
             as an ``assembly language'', while our calculus seems to
             provide a better programming notation for higher-order
             concurrency.",
  OPTnote = 	 {},
  annote = 	 "Maybe this could be relevant for the continuations journal",
  folder =    ""
}


@Article{Milner:93:ElemInteractionTuringAwardLect,
  author = 	 "Milner, Robin",
  title = 	 "Elements of Interaction: Turing Award Lecture",
  journal = 	 j-CACM,
  year = 	 1993,
  volume = 	 36,
  number = 	 1,
  pages = 	 "78--89",
  OPTnote = 	 {},
  annote = 	 {},
  folder =    ""
}




%%% Branching time and abstraction in bisimulation semantics 
%%% http://theory.stanford.edu/~rvg/abstracts.html#23
%%% delay bisimulation



%%%%%%%%%%%%%% BOOKS I OWN

@Book{Pierce:91;BasicCategoryTheoryforCS,
  author = 	 "Pierce, Benjamin C.",
  title = 	 "Basic Category Theory for Computer Scientists",
  publisher = 	 pub-MIT,
  year = 	 1991,
  series = 	 ser-FOUND-COMP,
  OPTedition = 	 {},
  about = "Category theory is a branch of pure mathematics that is an
          important tool in theoretical computer science, especially
          in programming language semantics, domain theory, and
          concurrency, where it is a standard language of
          discourse. 

          Assuming a minimum of mathematical preparation, 'Basic
          Theory for Computer Scientists' provides a presentation of
          the basic constructions and terminology of category theory,
          including limits, functors, natural transformations,
          adjoints, and cartesian closed categories. Four case studies
          illustrate applications of category theory to programming
          language design, semantics, and the solution of recursive
          domain equations. A brief literature survey offers
          suggestions for further study in more advanced texts.",
  keywords = "Category theory, semantics, domain theory, concurrency",
  OPTnote = 	 {},
  annote = 	 {}
}


@Book{Fokkink:00:IntroProcessAlgebra,
  author = 	 "Fokkink, Wan",
  title = 	 "Introduction to Process Algebra",
  publisher = 	 pub-SV,
  year = 	 2000,
  series = 	 "Texts in Theoretical Computer Science. An EATCS Series",
  OPTedition = 	 {},
  about = "Automated and semi-automated manipulation of so-called
          labelled transition systems has become an important means in
          discovering flaws in software and hardware systems. Process
          algebra has been developed to express such labelled
          transition systems algebraically, which enhances the ways of
          manipulation by means of equational logic and term
          rewriting.The theory of process algebra has developed
          rapidly over the last twenty years, and verification tools
          have been developed on the basis of process algebra, often
          in cooperation with techniques related to model
          checking. This textbook gives a thorough introduction into
          the basics of process algebra and its applications.",
  keywords = "Algebraic specification, concurrency, operational semantics, process algebra, term rewriting, verification",
  OPTnote = 	 {},
  annote = 	 {}
}


@Proceedings{Bradfield:02:ComputerScienceLogic,
  title =        "Computer Science Logic, 16th International Workshop, CSL 2002,
                 11th Annual Conference of the EACSL, Edinburgh, Scotland, UK,
                 September 22-25, 2002, Proceedings",
  year =         2002,
  booktitle =    {CSL},
  editor    =    {Bradfield, Julian C.},
  volume =       2471,
  series =       ser-LNCS,
  publisher =    pub-SV,
  annote = 	 {}
}

@Book{Winskel:93:FormSemProgLang,
  author =       "Winskel, Glynn",
  title =        "The Formal Semantics of Programming Languages: An
                 Introduction",
  series =       ser-FOUND-COMP,
  pages =        384,
  publisher =    pub-MIT,
  OPTmonth =        "Feb",
  year =         1993,
  about = "The Formal Semantics of Programming Languages provides the
          basic mathematical techniques necessary for those who are
          beginning a study of the semantics and logics of programming
          languages. These techniques will allow students to invent,
          formalize, and justify rules with which to reason about a
          variety of programming languages. Although the treatment is
          elementary, several of the topics covered are drawn from
          recent research, including the vital area of concurency. The
          book contains many exercises ranging from simple to
          miniprojects.

          Starting with basic set theory, structural operational
          semantics is introduced as a way to define the meaning of
          programming languages along with associated proof
          techniques. Denotational and axiomatic semantics are
          illustrated on a simple language of while-programs, and fall
          proofs are given of the equivalence of the operational and
          denotational semantics and soundness and relative
          completeness of the axiomatic semantics. A proof of Gödel's
          incompleteness theorem, which emphasizes the impossibility
          of achieving a fully complete axiomatic semantics, is
          included. It is supported by an appendix providing an
          introduction to the theory of computability based on
          while-programs.

          Following a presentation of domain theory, the semantics and
          methods of proof for several functional languages are
          treated. The simplest language is that of recursion
          equations with both call-by-value and call-by-name
          evaluation. This work is extended to lan guages with higher
          and recursive types, including a treatment of the eager and
          lazy lambda-calculi. Throughout, the relationship between
          denotational and operational semantics is stressed, and the
          proofs of the correspondence between the operation and
          denotational semantics are provided. The treatment of
          recursive types - one of the more advanced parts of the book
          - relies on the use of information systems to represent
          domains. The book concludes with a chapter on parallel
          programming languages, accompanied by a discussion of
          methods for specifying and verifying nondeterministic and
          parallel programs.",
  keywords =     "",
  annote = 	 {}
}

@Book{Magee:99:ConcurrencyStateModelsJavaProg,
  author = 	 "Magee, Jeff and Kramer, Jeff",
  title = 	 "Concurrency: State Models \& Java Programs",
  publisher = 	 pub-WILEY,
  year = 	 1999,
  OPTedition = 	 {},
  about = "Concurrent Programs are notoriously difficult to get
          right. This book provides a systematic and practical
          approach to designing, analyzing and implementing concurrent
          programs. Concurrency concepts and techniques are introduced
          and illustrated using both state models and Java
          programs. The design models enable concurrent behavior to be
          animated, mechanically analyzed and then implemented in
          programs. With good support for concurrency, Java provides
          an ideal implementation language. Examples ranging from
          automobile cruise control to a game of space invaders are
          used throughout to motivate and illustrate the models and
          programs. Modeling is supported by a visual and interactive
          method for reasoning about design features. Programming is
          supported by interactive applets for experimenting with
          concurrent programs. This book and the CD-ROM which
          accompanies it provide readers with the means for
          understanding the fundamentals and practice of
          concurrency. Topics covered include:

          * threads and interaction
          * interference, exclusion and synchronization
          * deadlock, safety and liveness properties
          * message passing
          * concurrent software architectures
          * dynamic and timed systems.

          The accompanying CD-ROM contains: the software analysis
          tools for modeling concurrency, model animation and model
          checking; the full set of state models, Java examples and
          demonstration programs; and a comprehensive series of
          overhead slides for course presentation. ",
  keywords = "",
  OPTnote = 	 {},
  annote = 	 {}
}


@Book{Lea:99:ConcurrentProgrammingInJava,
  author = 	 "Lea, Doug",
  title = 	 "Concurrent Programming in Java: Design Principles and Patterns",
  publisher = 	 pub-AW,
  year = 	 1999,
  series = 	 "The Java Series",
  edition = 	 "{S}econd",
  about = "Concurrent Programming in Java, 2nd Edition surveys a wide
          field of research in parallelism and concurrency and shows
          how to do more with multithreading in Java with dozens of
          patterns and design tips. Written for the advanced Java
          developer, this book offers a comprehensive tour of
          leading-edge thinking about parallel coding processes.

          Within the dozens of techniques and tips offered here, this
          book accomplishes at least two goals. First, it shows how
          concurrency is implemented by default within Java, with
          material on how built-in features (like the synchronized
          keyword and its memory model) can be expected to perform
          when dealing with multiple threads. Naturally, Java threads
          themselves are also covered, including priorities,
          scheduling, and the like.

          Much of this book looks at ways to improve performance of
          concurrent code beyond the simple default strategies. After
          defining criteria for measuring concurrent code (such as
          safety and 'liveness,' a measure of running live threads
          effectively), the book presents dozens of techniques for
          letting threads work together safely. For the working Java
          programmer, coverage of patterns that have been implemented
          in the downloadable java.concurrency package will be the
          most immediately useful. (Within this nearly encyclopedic
          survey, short code snippets are used for every pattern and
          concept.)

          Though theoretical at times, this book offers plenty of
          ideas and sample code to get you started thinking of ways to
          improve multithreaded code.

          Impressively comprehensive, Concurrent Programming in Java
          offers a veritable bible of techniques for doing two things
          at once with threads in Java. It's a worthwhile guide to the
          state-of-the-art strategies for improving the performance of
          your Java threads.",
  keywords =     "Threads, concurrency, Java, design patterns, synchronisation, deadlock",
  OPTnote = 	 {},
  annote = 	 {}
}


@Book{Milner:99:CommMobileSysPiCalc,
  author = 	 {Milner, Robin},
  title = 	 {Communicating and Mobile Systems: the $\pi$-calculus},
  publisher = 	 pub-CUP,
  year = 	 1999,
  about = "Communication is a fundamental and integral part of
          computing, whether between different computers on a network,
          or between components within a single computer. In this book
          Robin Milner introduces a new way of modelling communication
          that reflects its position. He treats computers and their
          programs as themselves built from communicating parts,
          rather than adding communication as an extra level of
          activity. Everything is introduced by means of examples,
          such as mobile phones, job schedualers, vending machines,
          data structures, and the objects of object-oriented
          programming. But the aim of the book is to develop a theory,
          the pi-calculus, in which these things can be treated
          rigorously. The pi-calculus differs from other models of
          communicating behaviour mainly in its treatment of
          mobility. The movement of a piece of data inside a computer
          program is treated exactly the same as the transfer of a
          message--or indeed an entire computer program--across the
          internet. One can also describe networks which reconfigure
          themselves. The calculus is very simple but powerful; its
          most prominent ingredient is the notion of a name. Its
          theory has two important ingredients: the concept of
          behavioural (or observational) equivalence, and the use of a
          new theory of types to classify patterns of interactive
          behaviour. The internet, and its communication protocols,
          fall within the scope of the theory just as much as computer
          programs, data structures, algorithms and programming
          languages. This book is the first textbook on the subject;
          it has been long-awaited by professionals and will be
          welcome by them, and their students.",
  keywords = "",
  annote = 	 {}
}

@Book{Milner:89:CommAndConcurrency,
  author = 	 {Milner, Robin},
  title = 	 {Communication and Concurrency},
  publisher = 	 pub-PH,
  year = 	 1989,
  OPTseries = 	 "Prentice Hall International Series in Computer Science",
  OPTaddress = 	 pub-PH:adr,
  about = "This book is a valuable review of the description and
          verification of concurrent systems. As one of the leading
          theoretical computer scientists in Britain, Robin Miller has
          produced an excellent book containing a well- judged mixture
          of theory and practical applications. Includes information
          on Modelling Communication, Equational Laws and Their
          Applications, Strong Bisimulation and Strong Equivalence,
          and more. This book forms a solid base for academic courses
          and a valuable reference for practitioners.",
  keywords = "",
  annote = 	 {}
}


@Book{Sangiorgi:01:PiCalculus,
  author = 	 {Sangiorgi, Davide and Walker, David},
  title = 	 {The $\pi$-calculus: a Theory of Mobile Processes},
  publisher = 	 pub-CUP,
  year = 	 2001,
  edition = 	 {},
  about = "Mobile systems, whose components communicate and change
          their structure, now pervade the informational world and the
          wider world of which it is a part. The science of mobile
          systems is as yet immature, however. This book presents the
          pi-calculus, a theory of mobile systems. The pi-calculus
          provides a conceptual framework for understanding mobility,
          and mathematical tools for expressing systems and reasoning
          about their behaviours. The book serves both as a reference
          for the theory and as an extended demonstration of how to
          use pi-calculus to describe systems and analyse their
          properties. It covers the basic theory of pi-calculus, typed
          pi-calculi, higher-order processes, the relationship between
          pi-calculus and lambda-calculus, and applications of
          pi-calculus to object-oriented design and programming. The
          book is written at the graduate level, assuming no prior
          acquaintance with the subject, and is intended for computer
          scientists interested in mobile systems.",
  keywords = "",
  annote = 	 {}
}



@Book{Peled:01:SoftwareReliabilityMethods,
  author = 	 "Peled, Doron A.",
  title = 	 "Software Reliability Methods",
  publisher = 	 pub-SV,
  year = 	 2001,
  series = 	 "Texts in Computer Science",
  about = "This volume presents a collection of methods for dealing
          with software reliability. Ideally, formal methods need to
          be intuitive to use, require a relatively brief learning
          period, and incur only small overhead to the development
          process. This book compares these varying methods and
          reveals their respective advantages and disadvantages, while
          also staying close to the dual themes of automata theory and
          logic.

          Topics and features:
          * Collects and compares the key software reliability methods
            currently in use: deductive verification, automatic
            verification, testing, and process algebra

          * Provides useful information suitable in the software
            selection process for a given project

          * Offers numerous exercises, projects, and running examples
            to facilitate learning formal methods and allows for
            'hands-on' experience with these critical
            tools

          * Describes the mathematical principles supporting formal
            methods

          * Gives insights into new research directions in the field,
            as well as ways of developing new methods and/or adjusting
            existing ones.

          This volume can be used as an introduction to software
          methods techniques, a source for learning about various ways
          to enhance software reliability, and a guide to formal
          methods techniques. It is an essential resource for
          professionals and software engineers in R\&D departments in
          industry, using software reliability, program-modeling
          systems, and verification methods.",
  keywords = "",

  OPTnote = 	 {},
  annote = 	 {}
}

@Book{Bonabeau:99:SwarmIntelligence,
  author = 	 "Bonabeau, Eric and Dorigo, Marco and Theraulaz, Guy",
  title = 	 "Swarm Intelligence: From Natural to Artificial Systems",
  publisher = 	 pub-OUP,
  year = 	 1999,
  series = 	 "Santa Fe Institute Studies in the Sciences of Complexity",
  about = "Social insects - bees, termites, and wasps - can be viewed
          as powerful problem-solving systems with sophisticated
          collective intelligence. Composed of simple interacting
          agents, this intelligence lies in the networks of
          interactions among individuals and between individuals and
          the environment. Social insects are also a metaphor for
          artificial intelligence, and the problems they solve -
          finding food, dividing labour among nestmates, building
          nests, responding to external challenges - have important
          counterparts in engineering and computer science. 

          This text provides a detailed look at models of social
          insect behaviour and how to apply these models in the design
          of complex systems. It shows how these models replace an
          emphasis on control, preprogramming, and centralization with
          designs featuring autonomy, emergence, and distributed
          functioning. These designs are proving immensely flexible
          and robust, able to adapt quickly to changing environments
          and to continue functioning even when individual elements
          fail. In particular, these designs are an approach to the
          tremendous growth of complexity in software and
          information.",
  keywords = "",
  OPTnote = 	 {},
  annote = 	 {}
}

@Book{Coulouris:01:DistributedSystemsConceptsandDesign,
  author = 	 "Coulouris, George and Dollimore, Jean and Kindberg, Tim",
  title = 	 "Distributed Systems: Concepts and Design",
  publisher = 	 pub-AW,
  year = 	 2001,
  edition = 	 "{T}hird",
  about = "This new edition represents a significant update of the
          best-selling book, incorporating and anticipating the major
          developments in distributed systems technology. All chapters
          have been thoroughly revised and updated, including emphasis
          on the Internet, intranets, and middleware. New material
          includes coverage of large-scale applications, fault
          modeling and fault tolerance, models of system execution,
          object-orientation, and distributed multimedia
          systems. Discussion of security has also been brought
          forward in the book and integrated with other related
          technologies. The book includes a new chapter on distributed
          multimedia systems, and also provides new material on
          current network technologies such as IPv6, Mobile IP, and
          active and wireless networks. Throughout, Java and CORBA are
          used as the basis for most examples. This book is designed
          for programmers who need to learn the principles and
          practice of distributed system design. Readers should have
          an understanding of programming and elementary computer
          architecture, as well as a familiarity with basic operating
          system concepts, but the book does not require knowledge of
          networks.",
  keywords = "",

  OPTnote = 	 {},
  annote = 	 {}
}

@Book{Abiteboul:00:DataOnTheWeb,
  author = 	 "Abiteboul, Serge and Suciu, Dan and Buneman, Peter",
  title = 	 "Data on the Web: From Relations to Semistructured Data and XML",
  publisher = 	 pub-MORGAN-KAUF,
  year = 	 2000,
  OPTseries = 	 {(Morgan Kaufmann Series in Data Management Systems)},
  about = "Data on the Web: From Relations to Semistructured Data and
          XML is an examination of XML as a universal data transfer
          language and the theory behind the merging of the
          document-centric Web with a data-driven infrastructure. The
          book is intended as a textbook analysis of the issues, as
          well as background material for tool developers and others
          interested in the serious architectural details.

          Aimed at readers already familiar with database concepts,
          the book includes little introductory material. It quickly
          lays out the concepts of self-describing semi-structured
          data and how XML fits into this approach to data
          representation. The discussion deals with XML as a data
          transfer mechanism and not a presentation language. While
          there is a quick explanation of DTDs, Xlink, and XPointer,
          readers should be fairly familiar with XML before
          approaching this advanced title.

          The meat of the book revolves around query languages for
          XML. The authors present XML-QL and XSL in depth as
          examples. Then they move into much more advanced concepts
          such as schema formalisms, path constraints, and storage
          architectures. The book wraps up with a look at Lore and
          Strudel--two real-world systems that work with
          semi-structured data. Because of its intensive study of
          database and query theory, this textbook isn't for the
          ordinary Web developer. If data architectures are your
          expertise, however, Data on the Web may open new design
          doors.",
  keywords = "Database management, XML (document markup language), WWW, information retrieval",
  annote = 	 {}
}

@Book{Bratko:00:PrologProgrammingForArtificialIntelligence,
  author = 	 "Bratko, Ivan",
  title = 	 "Prolog Programming for Artificial Intelligence",
  publisher = 	 pub-PEARSON,
  year = 	 2000,
  OPTseries = 	 {},
  edition = 	 "{T}hird",
  about = "This best-selling guide to Prolog has been fully revised
          and extended to provide an even greater range of
          applications, enhancing its value as a stand-alone guide to
          Prolog, artificial intelligence, or AI programming. Ivan
          Bratko discusses natural language processing with grammar
          rules, planning, and machine learning. The coverage of
          meta-programming includes meta-interpreters and
          object-oriented programming in Prolog. The new edition
          includes coverage of: constraint logic programming;
          qualitative reasoning; inductive logic programming; recently
          developed algorithms; belief networks for handling
          uncertainty; and a major update on machine learning. This
          book is aimed at programmers who need to learn AI
          programming.",

  keywords = "",

  annote = 	 {}
}

@Book{Ashri:01:ProfessionalJavaMobileProgramming,
  author = 	 "Ashri, Ronald and Atkinson, Steve and Ayers, Danny and Haglind, Marten and Ray, Bill and Machin, Rob and Nashi, Nadia and Taylor, Richard and Wiggers, Chanoch",
  title = 	 "Professional Java Mobile Programming",
  publisher = 	 pub-WROX,
  year = 	 2001,
  series = 	 "Programmer to Programmer",
  about = "For any developer writing mobile applications on the Java
          platform, from smart cards to pagers to PDAs, Professional
          Java Mobile Programming provides both a 'big picture'
          perspective on Java running on all these platforms, as well
          as some practical detail on the APIs and design strategies
          you'll need to get started.

          This book's principal strength is probably its complete
          coverage of mobile Java's possibilities. From tiny smart
          cards to Java-aware phones to pagers and even full-fledged
          PDAs, the authors cover the dizzying array of acronyms
          involved in the Java 2 Micro Edition (J2ME). The actual
          source code here concentrates on two flavors (called
          profiles) of J2ME: the Mobile Information Device Profile
          (MIDP), for PDAs, and the Connected Limited Device
          Configuration (CLDC), for pagers. To this end, this text
          covers both high-level controls available on the MIDP
          platform, and then lower-level graphical calls. They provide
          a case study for a contact manager then port it to the more
          restricted form factor of the CLDC standard.

          Coverage of smart card programming will help get you started
          there. Smart cards have just a few bytes of memory, so
          programming them requires a very different mindset, and this
          text shows you how to work with these devices. Coverage of
          additional abilities in mobile Java from the Java Message
          Service (JMS) and telephony APIs rounds out the text. The
          authors anchor their sometimes wide-ranging discussion with
          some larger case studies, including a Towers of Hanoi
          simulation and a mobile application that uses global
          positioning information.

          Later samples integrate mobile applications into the larger
          J2EE platform on the server-side. The code here mixes in
          technologies like servlets, EJBs, XML, and XSLT with mobile
          user interfaces. A discussion of the software design process
          geared toward mobile development closes out this
          book. Useful reference sections compare the MIDP and CLDC
          APIs, as well as listing all available classes and methods
          in each.

          Though this text at times adopts a somewhat scattershot
          approach in its organization, its overall coverage of the
          rich possibilities of today's different mobile Java
          standards will help make it a useful resource for
          understanding what Java has to offer when it comes to mobile
          computing.",
  keywords = "Java 2 ME, KVM, profiles and configurations, JavaCard, JavaPhone, CDC, Foundation Profile, CLDC and MIDP",
  annote = 	 {}
}

@Book{Giotta:00:ProfessionalJMSProgramming,
  author = 	 "Giotta, Paul and Grant, Scott and Kovacs, Michael and Maffeis, Silvano and Morrison, K. Scott and Raj, Gopalan Suresh and Kunnumpurath, Meeraj Moidoo",
  title = 	 "Professional JMS Programming",
  publisher = 	 pub-WROX,
  year = 	 2000,
  series = 	 "Programmer to Programmer",
  about = "Professional JMS lifts the lid on the collection of data
          communications technologies known collectively as the Java
          Message Service (JMS). Don't approach this book without a
          very solid grounding in Java network programming and
          familiarity with the Java 2 Enterprise Edition (J2EE)
          environment, because the authors don't slow down for
          stragglers.

          The book explains one technology after another, each in
          terms of its place in larger distributed computing
          solutions. That, together with the fact that most of the
          code samples are long and rather sophisticated, makes this
          book best suited to systems architects and programmers in
          the early phases of their work.

          A typical discussion of a JMS technology begins with an
          architectural overview of what it's for. These discussions
          include numerous boxes, clip-art computers, arrows, and
          database cylinders, with labeled messages moving along the
          interconnections. Explanations of specifications for
          software systems that solve particular business problems
          follow, along with the code that does the job. Critical
          sections of these passages are commented, often with tables
          that detail what's in the messages flowing back and forth
          among pieces of the system. Where relevant, utilities that
          handle JMS and J2EE tasks are documented -- FioranoMQ and
          BEA WebLogic Server are explained thoroughly.",
  keywords = "Java Message Service (JMS), Point-to-Point, Publish/Subscribe messaging domains, message-driven EJBs",
  annote = 	 {}
}

@Book{Christiansen:00:SprogAbstrakteMaskiner,
  author = 	 "Christiansen, Henning",
  title = 	 "Sprog og abstrakte maskiner",
  publisher = 	 "Roskilde Universitetscenter, Datalogiafdelingen",
  year = 	 2000,
  series = 	 "Datalogiske Noter",
  edition = 	 "{T}hird",
  about = "",
  keywords = "",
  annote = 	 {}
}


@Book{Graham:94:ConcreteMathematics,
  author = 	 "Graham, Ronald L. and Knuth, Donald E. and Patashnik, Oren",
  title = 	 "Concrete Mathematics: {A} Foundation for Computer Science",
  publisher = 	 pub-AW,
  year = 	 1994,
  edition = 	 "{S}econd",
  about = "This book introduces the mathematics that supports advanced
          computer programming and the analysis of algorithms. The
          primary aim of its well-known authors is to provide a solid
          and relevant base of mathematical skills - the skills needed
          to solve complex problems, to evaluate horrendous sums, and
          to discover subtle patterns in data. It is an indispensable
          text and reference not only for computer scientists - the
          authors themselves rely heavily on it! - but for serious
          users of mathematics in virtually every discipline.

          Concrete Mathematics is a blending of CONtinuous and
          disCRETE mathematics. 'More concretely,' the authors
          explain, 'it is the controlled manipulation of mathematical
          formulas, using a collection of techniques for solving
          problems.' The subject matter is primarily an expansion of
          the Mathematical Preliminaries section in Knuth's classic
          Art of Computer Programming, but the style of presentation
          is more leisurely, and individual topics are covered more
          deeply. Several new topics have been added, and the most
          significant ideas have been traced to their historical
          roots. The book includes more than 500 exercises, divided
          into six categories. Complete answers are provided for all
          exercises, except research problems, making the book
          particularly valuable for self-study.

          Major topics include:
          * Sums
          * Recurrences
          * Integer functions
          * Elementary number theory
          * Binomial coefficients
          * Generating functions
          * Discrete probability
          * Asymptotic methods

          This second edition includes important new material about
          mechanical summation. In response to the widespread use of
          the first edition as a reference book, the bibliography and
          index have also been expanded, and additional nontrivial
          improvements can be found on almost every page. Readers will
          appreciate the informal style of Concrete
          Mathematics. Particularly enjoyable are the marginal
          graffiti contributed by students who have taken courses
          based on this material. The authors want to convey not only
          the importance of the techniques presented, but some of the
          fun in learning and using them.",
  keywords = "Sums, recurrences, integer functions, elementary number
             theory, binomial coefficients, generating functions,
             discrete probability, asymptotic methods.",
  annote = 	 {}
}

@Book{Pierce:02:TypesAndProgLang,
  author = 	 "Pierce, Benjamin C.",
  title = 	 "Types and Programming Languages",
  publisher = 	 pub-MIT,
  year = 	 2002,
  about = "A type system is a syntactic method for automatically
          checking the absence of certain erroneous behaviors by
          classifying program phrases according to the kinds of values
          they compute. The study of type systems - and of programming
          languages from a type-theoretic perspective - has important
          applications in software engineering, language design,
          high-performance compilers, and security. 

          This text provides a comprehensive introduction both to type
          systems in computer science and to the basic theory of
          programming languages. The approach is pragmatic and
          operational; each new concept is motivated by programming
          examples and the more theoretical sections are driven by the
          needs of implementations. Each chapter is accompanied by
          numerous exercises and solutions, as well as a running
          implementation, available via the Web. Dependencies between
          chapters are explicitly identified, allowing readers to
          choose a variety of paths through the material. The core
          topics include the untyped lambda-calculus, simple type
          systems, type reconstruction, universal and existential
          polymorphism, subtyping, bounded quantification, recursive
          types, kinds, and type operators. Extended case studies
          develop a variety of approaches to modeling the features of
          object-oriented languages.",
  keywords = "Untyped lambda-calculus, simple type systems, type
             reconstruction, universal and existential polymorphism,
             subtyping, bounded quantification, recursive types,
             kinds, and type operators.",
  annote = 	 {},
}
