@techreport{ PyPyJIT,
    title = "{JIT} Compiler Architecture",
    author = {Armin Rigo and Samuele Pedroni},
    year = "2007",
    institution = "PyPy Consortium",
    number = "D08.2",
    note = "http://codespeak.net/pypy/dist/pypy/doc/index-report.html"
}
@inproceedings{hoelzle_optimizing_1991,
	title = {Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches},
	isbn = {3-540-54262-0},
	url = {http://portal.acm.org/citation.cfm?id=679193\&dl=ACM\&coll=portal},
	booktitle = {Proceedings of the European Conference on Object-Oriented Programming},
	publisher = {Springer-Verlag},
	author = {Urs H{\"o}lzle and Craig Chambers and David Ungar},
	year = {1991},
	pages = {21-38}
}

@inproceedings{sullivan_dynamic_2001,
	title = {Dynamic Partial Evaluation},
	isbn = {3-540-42068-1},
	url = {http://portal.acm.org/citation.cfm?id=668117},
	booktitle = {Proceedings of the Second Symposium on Programs as Data Objects},
	publisher = {Springer-Verlag},
	author = {Gregory T. Sullivan},
	year = {2001},
	pages = {238-256}
}
@inproceedings{gal_hotpathvm_2006,
	address = {Ottawa, Ontario, Canada},
	title = {{HotpathVM}: an effective {JIT} compiler for resource-constrained devices},
	isbn = {1-59593-332-6},
	url = {http://portal.acm.org/citation.cfm?doid=1134760.1134780},
	doi = {10.1145/1134760.1134780},
	abstract = {We present a just-in-time compiler for a Java VM that is small enough to fit on resource-constrained devices, yet is surprisingly effective. Our system dynamically identifies traces of frequently executed bytecode instructions (which may span several basic blocks across several methods) and compiles them via Static Single Assignment (SSA) construction. Our novel use of SSA form in this context allows to hoist instructions across trace side-exits without necessitating expensive compensation code in off-trace paths. The overall memory consumption (code and data) of our system is only 150 kBytes, yet benchmarks show a speedup that in some cases rivals heavy-weight just-in-time compilers.},
	booktitle = {Proceedings of the 2nd international conference on Virtual execution environments},
	publisher = {ACM},
	author = {Andreas Gal and Christian W. Probst and Michael Franz},
	year = {2006},
	keywords = {dynamic compilation,embedded and resource-constrained systems,mixed-mode interpretive compiled systems,software trace scheduling,static single assignment form,virtual machines},
	pages = {144-153}
}


@article{bala_dynamo_2000,
	title = {Dynamo: a transparent dynamic optimization system},
	volume = {35},
	url = {http://citeseer.ist.psu.edu/bala00dynamo.html},
	journal = {ACM SIGPLAN Notices},
	author = {Vasanth Bala and Evelyn Duesterwald and Sanjeev Banerjia},
	year = {2000},
	keywords = {toread},
	pages = {1-12}
},

@techreport{gal_incremental_2006,
	title = {Incremental Dynamic Code Generation with Trace Trees},
	abstract = {The unit of compilation for traditional just-in-time compilers is the method. We have explored trace-based compilation, in which the unit of compilation is a loop, potentially spanning multiple methods and even library code. Using a new intermediate representation that is discovered and updated lazily on-demand while the program is being executed, our compiler generates code that is competitive with traditional dynamic compilers, but that uses only a fraction of the compile time and memory footprint.},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Andreas Gal and Michael Franz},
	month = nov,
	year = {2006},
	pages = {11}
},

@article{grant_dyc_2000,
	title = {{DyC}: an expressive annotation-directed dynamic compiler for C},
	volume = {248},
	url = {http://citeseer.ist.psu.edu/grant97dyc.html},
	journal = {Theoretical Computer Science},
	author = {Brian Grant and Markus Mock and Matthai Philipose and Craig Chambers and Susan J. Eggers},
	year = {2000},
	keywords = {unread},
	pages = {147-199}
},

@techreport{chang_efficient_2007,
	title = {Efficient Just-In-Time Execution of Dynamically Typed Languages
Via Code Specialization Using Precise Runtime Type Inference},
	abstract = {Dynamically typed languages such as JavaScript present a challenge to just-in-time compilers. In contrast to statically typed languages such as JVML, in which there are specific opcodes for common operations on primitive types (such as iadd for integer addition), all operations in dynamically typed language such as JavaScript are late-bound. Often enough, types cannot be inferred with certainty ahead of execution. As a result, just-in-time compilers for dynamically typed languages have tended to perform worse than their statically-typed counterparts. We present a new approach to compiling dynamically typed languages in which code traces observed during execution are dynamically specialized for each actually observed run-time type. For most benchmark programs, our prototype JavaScript virtual machine outperforms every other JavaScript platform known to us.},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Mason Chang and Michael Bebenita and Alexander Yermolovich and Andreas Gal and Michael Franz},
	year = {2007},
	keywords = {dynamic,javascript,JIT,traces}
}

@inproceedings{paleczny_java_2001,
	address = {Monterey, California},
	title = {The Java {HotSpot} server compiler},
	url = {http://portal.acm.org/citation.cfm?id=1267848},
	abstract = {The Java HotSpotTM Server Compiler achieves improved asymptotic performance through a combination of object-oriented and classical-compiler optimizations. Aggressive inlining using class-hierarchy analysis reduces function call overhead and provides opportunities for many compiler optimizations.},
	booktitle = {Proceedings of the Java Virtual Machine Research and Technology Symposium on Java Virtual Machine Research and Technology Symposium - Volume 1},
	publisher = {USENIX Association},
	author = {Michael Paleczny and Christopher Vick and Cliff Click},
	year = {2001},
}


@inproceedings{carl_friedrich_bolz_to_2007,
	title = {How to \emph{not} write a Virtual Machine},
	abstract = {Typical modern dynamic languages have a growing number of implementations. We explore the reasons for this situation, and the limitations it imposes on open source or academic communities that lack the resources to fine-tune and maintain them all. It is sometimes proposed that implementing dynamic languages on top of a standardized general-purpose object-oriented virtual machine (like Java or .NET) would help reduce this burden. We propose a complementary alternative to writing custom virtual machine (VMs) by hand, validated by the PyPy project: flexibly generating VMs from a high-level "specification",
inserting features and low-level details automatically ? including good just-in-time compilers tuned to the dynamic language at hand.
We believe this to be ultimately a better investment of efforts than the development of more and more advanced general-purpose object
oriented VMs. In this paper we compare these two approaches in detail.},
	booktitle = {Proceedings of 3rd Workshop on Dynamic Languages and Applications (DYLA 2007)},
	author = {Carl Friedrich Bolz and Armin Rigo},
	year = {2007}
},

@inproceedings{rigo_pypys_2006,
	address = {Portland, Oregon, USA},
	title = {{PyPy}'s approach to virtual machine construction},
	isbn = {1-59593-491-X},
	url = {http://portal.acm.org/citation.cfm?id=1176753},
	doi = {10.1145/1176617.1176753},
	abstract = {The PyPy project seeks to prove both on a research and a practical level the feasibility of constructing a virtual machine (VM) for a dynamic language in a dynamic language - in this case, Python. The aim is to translate (i.e. compile) the VM to arbitrary target environments, ranging in level from C/Posix to Smalltalk/Squeak via Java and CLI/.NET, while still being of reasonable efficiency within these environments.A key tool to achieve this goal is the systematic reuse of the Python language as a system programming language at various levels of our architecture and translation process. For each level, we design a corresponding type system and apply a generic type inference engine - for example, the garbage collector is written in a style that manipulates simulated pointer and address objects, and when translated to C these operations become C-level pointer and address instructions.},
	booktitle = {Companion to the 21st ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	publisher = {ACM},
	author = {Armin Rigo and Samuele Pedroni},
	year = {2006},
	keywords = {metacircularity,python,retargettable code generation,type inference,virtual machine},
	pages = {944-953}
},

@inproceedings{chang_tracing_2009,
        address = {Washington, {DC,} {USA}},
        title = {Tracing for Web 3.0: Trace Compilation for the Next Generation Web Applications},
        isbn = {978-1-60558-375-4},
        url = {http://portal.acm.org/citation.cfm?id=1508293.1508304},
        doi = {10.1145/1508293.1508304},
        abstract = {Today's web applications are pushing the limits of modern web browsers. The emergence of the browser as the platform of choice for rich client-side applications has shifted the use of in-browser {JavaScript}from small scripting programs to large computationally intensive application logic. For many web applications, {JavaScript} performance has become one of the bottlenecks preventing the development of even more interactive client side applications. While traditional just-in-time compilation is successful for statically typed virtual machinebased languages like Java, compiling {JavaScript} turns out to be a challenging task. Many {JavaScript} programs and scripts are short-lived, and users expect a responsive browser during page loading. This leaves little time for compilation of {JavaScript} to generate machine code.},
        booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN/SIGOPS} International Conference on Virtual Execution Environments},
        publisher = {{ACM}},
        author = {Mason Chang and Edwin Smith and Rick Reitmaier and Michael Bebenita and Andreas Gal and Christian Wimmer and Brendan Eich and Michael Franz},
        year = {2009},
        pages = {71--80}
},

@phdthesis{carl_friedrich_bolz_automatic_2008,
        type = {Master Thesis},
        title = {Automatic {JIT} Compiler Generation with Runtime Partial Evaluation
},
        school = {{Heinrich-Heine-Universität} Düsseldorf},
        author = {Carl Friedrich Bolz},
        year = {2008},
        note = {http://www.stups.uni-duesseldorf.de/thesis\_detail.php?id=14}
},

@inproceedings{bolz_tracingmeta_level_2009,
	address = {Genova, Italy},
	title = {Tracing the meta-level: {PyPy's} tracing {JIT} compiler},
	isbn = {978-1-60558-541-3},
	shorttitle = {Tracing the meta-level},
	url = {http://portal.acm.org/citation.cfm?id=1565827},
	doi = {10.1145/1565824.1565827},
	abstract = {We attempt to apply the technique of Tracing {JIT} Compilers in the context of the {PyPy} project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing {JIT} compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing {JIT} to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing {JIT} compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two {PyPy} interpreters: one is a small example, and the other one is the full Python interpreter.},
	booktitle = {Proceedings of the 4th workshop on the Implementation, Compilation, Optimization of {Object-Oriented} Languages and Programming Systems},
	publisher = {{ACM}},
	author = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijalkowski and Armin Rigo},
	year = {2009},
	pages = {18--25}
},
