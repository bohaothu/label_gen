


%
%
%
% automatically generated
% % bibtex2html lis.bib foret-2007.bib -force -html-links -sort-criterium year
% Date: Mon Jan  3 09:47:43 2011

% Author: ferre
%
%
%










@PROCEEDINGS{ICCS2010,
   TITLE        = {Conceptual Structures: From Information to Intelligence, 
      18th International Conference on Conceptual Structures, ICCS 2010, 
      Kuching, Sarawak, Malaysia, July 26-30, 2010. Proceedings},
   YEAR         = {2010},
   OPTADDRESS   = {},
   EDITOR       = {Madalina Croitoru and Sébastien Ferré and Dickson Lukose},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 6208},
   VOLUME       = {6208},
   BOOKTITLE    = {ICCS}
}

@ARTICLE{Foret09b,
   AUTHOR       = {Denis Béchet and Annie Foret},
   JOURNAL      = {Linguistic Analysis Journal},
   TITLE        = {A Pregroup Toolbox for Parsing and Building Grammars of 
      Natural Languages},
   YEAR         = {2010},
   OPTMONTH     = {},
   NOTE         = {to appear},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   VOLUME       = {36}
}

@ARTICLE{ducasse10,
   AUTHOR       = {Mireille Ducassé and Sébastien Ferré},
   JOURNAL      = {Revue internationale de systémique complexe et d'études relationnelles, Nouvelles Perspectives en Sciences Sociales.},
   TITLE        = {Aide à la décision multicritère : cohérence et équité 
      grâce à l'analyse de concepts},
   YEAR         = {2010},
   MONTH        = {Mai},
   OPTNOTE      = {},
   NUMBER       = {2},
   PAGES        = {181-196},
   VOLUME       = {5},
   PUBLISHER    = {Prise de parole, Université Laurentienne, Canada}
}

@ARTICLE{Foret09d,
   AUTHOR       = {A. Foret},
   JOURNAL      = {Information and Computation Journal},
   TITLE        = {A modular and parameterized presentation of pregroup 
      calculus},
   YEAR         = {2010},
   MONTH        = {May},
   OPTNOTE      = {},
   NUMBER       = {5},
   PAGES        = {395-604},
   VOLUME       = {208},
   KEYWORDS     = {Pregroups, Lambek categorial grammars, Logic functor, 
      Logic component, Cut elimination},
   PDF          = {http://dx.doi.org/10.1016/j.ic.2009.03.010},
   ABSTRACT     = {The concept of pregroup was introduced by Lambek for 
      natural language analysis, with a close link to non-commutative 
      linear logic. We reformulate the pregroup calculus so as to extend it 
      by composition with other logics and calculi. The cut elimination 
      property and the decidability property of the sequent calculus 
      proposed in the article are shown. Properties of composed calculi are 
      also discussed.}
}

@INPROCEEDINGS{AlaFer2010,
   AUTHOR       = {Pierre Allard and Sébastien Ferré},
   BOOKTITLE    = {Extraction et Gestion des Connaissances},
   TITLE        = {Recherche de dépendances fonctionnelles et de règles 
      d'association avec OLAP},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S. Ben Yahia and J.-M. Petit},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {651-652},
   PUBLISHER    = {Cépaduès-Éditions},
   SERIES       = {Revue des Nouvelles Technologies de l'Information},
   VOLUME       = {RNTI-E-19},
   KEYWORDS     = {association rule, functional dependency, OLAP, 
      navigation},
   ABSTRACT     = {Dans le domaine des bases de données, les outils de 
      calcul de règles d'association et de dépendances fonctionnelles 
      affichent traditionnellement les résultats sous forme d'une liste de 
      règles, difficiles à lire. Nous proposons ici de projeter une 
      relation d'une base de données sur un cube de données OLAP, afin 
      d'afficher ces règles de manière plus structurée et plus intuitive. 
      De plus, nous montrons que les liens de navigation d'OLAP peuvent 
      aider l'utilisateur à naviguer dans ces règles produites.}
}

@INPROCEEDINGS{AllardFR10,
   AUTHOR       = {Pierre Allard and Sébastien Ferré and Olivier Ridoux},
   BOOKTITLE    = {Concept Lattices and Their Applications},
   TITLE        = {Discovering Functional Dependencies and Association 
      Rules by Navigating in a Lattice of OLAP Views},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Kryszkiewicz and S. Obiedkov},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {199-210},
   PUBLISHER    = {CEUR-WS},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Functional Dependencies, Association Rules, FCA, OLAP, 
      Navigation},
   ABSTRACT     = {Discovering dependencies in data is a well-know problem 
      in database theory. The most common rules are Functional Dependencies 
      (FDs), Conditional Functional Dependencies (CFDs) and Association 
      Rules (ARs). Many tools can display those rules as lists, but those 
      lists are often too long for inspection by users. We propose a new 
      way to display and navigate through those rules. Display is based on 
      On-Line Analytical Processing (OLAP), presenting a set of rules as a 
      cube, where dimensions correspond to the premises of rules. Cubes 
      reflect the hierarchy that exists between FDs, CFDs and ARs. 
      Navigation is based on a lattice, where nodes are OLAP views, and 
      edges are OLAP navigation links, and guides users from cube to cube. 
      We present an illustrative example with the help of our prototype.}
}

@INPROCEEDINGS{Foret10b,
   AUTHOR       = {Denis Bechet and Alexander Dikovsky and Annie Foret},
   BOOKTITLE    = {Formal Grammar},
   TITLE        = {Two models of learning iterated dependencies.},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS},
   OPTVOLUME    = {},
   ABSTRACT     = {We study the learnability problem in the family of 
      Categorial Dependency Grammars (CDG), a class of categorial grammars 
      defining unlimited dependency structures. CDG satisfying a reasonable 
      condition on the iterant dependencies are shown to be incrementally 
      learnable in the limit.}
}

@INPROCEEDINGS{CellierC10,
   AUTHOR       = {Peggy Cellier and Thierry Charnois},
   BOOKTITLE    = {Traitement Automatique des Langues Naturelles (short paper)},
   TITLE        = {Fouille de données séquentielle d'itemsets pour 
      l'apprentissage de patrons linguistiques},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{CellierCP10,
   AUTHOR       = {Peggy Cellier and Thierry Charnois and Marc Plantevit},
   BOOKTITLE    = {Computational Linguistics and Intelligent Text Processing (CICLing)},
   TITLE        = {Sequential Patterns to Discover and Characterise 
      Biological Relations},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Alexander F. Gelbukh},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {537-548},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 6008},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{CellierCPC10,
   AUTHOR       = {Peggy Cellier and Thierry Charnois and Marc Plantevit and 
      Bruno Crémilleux},
   BOOKTITLE    = {Advances in Intelligent Data Analysis IX, 9th International Symposium (IDA)},
   TITLE        = {Recursive Sequence Mining to Discover Named Entity 
      Relations},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Paul R. Cohen and Niall M. Adams and Michael R. Berthold},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {30-41},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 6065},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Fer2010,
   AUTHOR       = {Sébastien Ferré},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {Conceptual Navigation in RDF Graphs with SPARQL-Like 
      Queries},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {L. Kwuida and B. Sertkaya},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {193-208},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 5986},
   OPTVOLUME    = {},
   KEYWORDS     = {conceptual navigation, semantic web, RDF, SPARQL, 
      querying, navigation},
   ABSTRACT     = {Concept lattices have been successfully used for 
      information retrieval and browsing. They offer the advantage of 
      combining querying and navigation in a consistent way. Conceptual 
      navigation is more flexible than hierarchical navigation, and easier 
      to use than plain querying. It has already been applied to formal, 
      logical, and relational contexts, but its application to the semantic 
      web is a challenge because of inference mechanisms and expressive 
      query languages such as SPARQL. The contribution of this paper is to 
      extend conceptual navigation to the browsing of RDF graphs, where 
      concepts are accessed through SPARQL-like queries. This extended 
      conceptual navigation is proved consistent w.r.t. the context (i.e., 
      never leads to an empty result set), and complete w.r.t. the 
      conjunctive fragment of the query language (i.e., every query can be 
      reached by navigation only). Our query language has an expressivity 
      similar to SPARQL, and has a more natural syntax close to description 
      logics.}
}

@INPROCEEDINGS{ForFer2010,
   AUTHOR       = {Annie Foret and Sébastien Ferré},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {On Categorial Grammars as Logical Information Systems},
   YEAR         = {2010},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {L. Kwuida and B. Sertkaya},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {225-240},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 5986},
   OPTVOLUME    = {},
   KEYWORDS     = {logical information systems, categoarial grammar, 
      pregroup, browsing},
   ABSTRACT     = {We explore different perspectives on how categorial 
      grammars can be considered as Logical Information Systems (LIS) both 
      theoretically, and practically. Categorial grammars already have 
      close connections with logic. We discuss the advantages of 
      integrating both approaches. We consider more generally different 
      ways of connecting computational linguistic data and LIS as an 
      application of Formal Concept Analysis.}
}

@MISC{CellierDFR10,
   AUTHOR       = {Peggy Cellier and Mireille Ducassé and Sébastien Ferré and 
      Olivier Ridoux},
   OPTHOWPUBLISHED = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   TITLE        = {Fouille de données pour la localisation de fautes dans 
      les programmes},
   YEAR         = {2010},
   BOOKTITLE    = {Journées nationales du GDR GPL (GDR Génie de la Programmation et du Logiciel)}
}

@PROCEEDINGS{ICFCA2009,
   TITLE        = {Formal Concept Analysis, 7th International Conference, 
      ICFCA 2009, Darmstadt, Germany, May 21-24, 2009, Proceedings},
   YEAR         = {2009},
   OPTADDRESS   = {},
   EDITOR       = {S. Ferré and S. Rudolph},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 5548},
   OPTVOLUME    = {},
   BOOKTITLE    = {ICFCA},
   KEYWORDS     = {formal concept analysis}
}

@PHDTHESIS{Bedel2009PhD,
   AUTHOR       = {Olivier Bedel},
   SCHOOL       = {Thèse de l'université de Rennes 1},
   TITLE        = {GEOLIS : Un Système d information logique pour l 
      organisation et la recherche de données géolocalisées},
   YEAR         = {2009},
   OPTADDRESS   = {},
   MONTH        = {22 janvier},
   NOTE         = {coencadrée par Olivier Ridoux et Sébastien Ferré},
   OPTTYPE      = {}
}

@INBOOK{Book-FIND:Chap5,
   PUBLISHER    = {Springer},
   TITLE        = {Dynamic Taxonomies and Faceted Search: Theory, Practice, 
      and Experience},
   YEAR         = {2009},
   AUTHOR       = {G. M. Sacco and S. Ferré},
   CHAPTER      = {5 - Extensions to the Model},
   ALTEDITOR    = {},
   PAGES        = {113--144},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {The Information Retrieval Series},
   OPTTYPE      = {},
   VOLUME       = {25},
   KEYWORDS     = {dynamic taxonomies, faceted search, browsing, 
      information retrieval}
}

@INBOOK{Book-FIND:Chap9,
   PUBLISHER    = {Springer},
   TITLE        = {Dynamic Taxonomies and Faceted Search: Theory, Practice, 
      and Experience},
   YEAR         = {2009},
   AUTHOR       = {G. M. Sacco and S. Ferré},
   CHAPTER      = {9 - Applications and Experiences},
   ALTEDITOR    = {},
   PAGES        = {263--302},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {The Information Retrieval Series},
   OPTTYPE      = {},
   VOLUME       = {25},
   KEYWORDS     = {dynamic taxonomies, faceted search, browsing, 
      information retrieval}
}

@INBOOK{Book-FIND:Chap3,
   PUBLISHER    = {Springer},
   TITLE        = {Dynamic Taxonomies and Faceted Search: Theory, Practice, 
      and Experience},
   YEAR         = {2009},
   AUTHOR       = {G. M. Sacco and S. Ferré and Y. Tzitzikas},
   CHAPTER      = {3 - Comparison with Other Techniques},
   ALTEDITOR    = {},
   PAGES        = {35--74},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {The Information Retrieval Series},
   OPTTYPE      = {},
   VOLUME       = {25},
   KEYWORDS     = {dynamic taxonomies, faceted search, browsing, 
      information retrieval}
}

@INBOOK{Book-FIND:Chap8,
   PUBLISHER    = {Springer},
   TITLE        = {Dynamic Taxonomies and Faceted Search: Theory, Practice, 
      and Experience},
   YEAR         = {2009},
   AUTHOR       = {G. M. Sacco and Y. Tzitzikas and S. Ferré},
   CHAPTER      = {8 - System Implementation},
   ALTEDITOR    = {},
   PAGES        = {215--262},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {The Information Retrieval Series},
   OPTTYPE      = {},
   VOLUME       = {25},
   KEYWORDS     = {dynamic taxonomies, faceted search, browsing, 
      information retrieval}
}

@INBOOK{Book-FIND:Chap4,
   PUBLISHER    = {Springer},
   TITLE        = {Dynamic Taxonomies and Faceted Search: Theory, Practice, 
      and Experience},
   YEAR         = {2009},
   AUTHOR       = {M. Stefaner and S. Ferré and S. Perugini and J. Koren and 
      Y. Zhang},
   CHAPTER      = {4 - User Interface Design},
   ALTEDITOR    = {},
   PAGES        = {75--112},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {The Information Retrieval Series},
   OPTTYPE      = {},
   VOLUME       = {25},
   KEYWORDS     = {dynamic taxonomies, faceted search, browsing, 
      information retrieval}
}

@ARTICLE{Fer2009,
   AUTHOR       = {S. Ferré},
   JOURNAL      = {Int. J. General Systems},
   TITLE        = {Camelis: a logical information system to organize and 
      browse a collection of documents},
   YEAR         = {2009},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {4},
   OPTPAGES     = {},
   VOLUME       = {38},
   KEYWORDS     = {information retrieval, browsing, 
      logical concept analysis, annotation},
   ABSTRACT     = {Since the arrival of digital cameras, many people are 
      faced to the challenge of organizing and browsing the overwhelming 
      flood of photos their life produces. The same is true for all sorts 
      of documents, e.g.~emails, audio files. Existing systems either let 
      users fill query boxes without any assistance, or drive them through 
      rigid navigation structures (e.g., hierarchies); or they do not let 
      users put annotations on their documents, even when this would 
      support the organization and retrieval of any documents on customized 
      criteria. We present a tool, {\sc Camelis}, that offers users with an 
      organization that is dynamically computed from documents and their 
      annotations. {\sc Camelis} is designed along the lines of Logical 
      Information Systems (LIS), which are founded on logical concept 
      analysis. Hence, (1) an expressive language can be used to describe 
      photos and query the collection, (2) manual and automatic annotations 
      can be smoothly integrated, and (3) expressive querying and flexible 
      navigation can be mixed in a same search and in any order. This 
      presentation is illustrated on a real collection of more than 5,000 
      photos.}
}

@ARTICLE{morin09,
   AUTHOR       = {Benjamin Morin and Ludovic Mé and Hervé Debar and 
      Mireille Ducassé},
   JOURNAL      = {Information Fusion},
   TITLE        = {A Logic-based model to support alert correlation in 
      intrusion detection},
   YEAR         = {2009},
   MONTH        = {October},
   OPTNOTE      = {},
   NUMBER       = {4},
   PAGES        = {285-299},
   VOLUME       = {10},
   KEYWORDS     = {Intrusion detection, Alert correlation, Data model},
   ABSTRACT     = { Managing and supervising security in large networks has 
      become a challenging task, as new threats and flaws are being 
      discovered on a daily basis. This requires an in depth and up-to-date 
      knowledge of the context in which security-related events occur. 
      Several tools have been proposed to support security operators in 
      this task, each of which focuses on some specific aspects of the 
      monitoring. Many alarm fusion and correlation approaches have also 
      been investigated. However, most of these approaches suffer from two 
      major drawbacks. First, they only take advantage of the information 
      found in alerts, which is not sufficient to achieve the goals of 
      alert correlation, that is to say to reduce the overall amount of 
      alerts, while enhancing their semantics. Second, these techniques 
      have been designed on an ad hoc basis and lack a shared data model 
      that would allow them to reason about events in a cooperative way. In 
      this paper, we propose a federative data model for security systems 
      to query and assert knowledge about security incidents and the 
      context in which they occur. This model constitutes a consistent and 
      formal ground to represent information that is required to reason 
      about complementary evidences, in order to confirm or invalidate 
      alerts raised by intrusion detection systems.}
}

@INPROCEEDINGS{Foret09a,
   AUTHOR       = {Denis Béchet and Annie Foret},
   BOOKTITLE    = {Proc. Parsing with Categorial Grammars, ESSLLI workshop, in Bordeaux, France},
   TITLE        = {(PPQ) : a pregroup parser using majority composition},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {parser, pregroups, Lambek categorial grammars, 
      parsing software, XML data},
   PDF          = {http://www.cs.toronto.edu/~tfowler/parsingwithcg/},
   ABSTRACT     = {Pregroup grammars are a mathematical formalism in the 
      spirit of categorial grammars. They are close to logical formalism 
      like Lambek calculus but have a polynomial parsing algorithm. The 
      paper presents a parser based on pregroup gram- mar that uses a 
      tabular approach based on majority partial composition. }
}

@INPROCEEDINGS{Foret09c,
   AUTHOR       = {Denis Béchet and Annie Foret},
   BOOKTITLE    = {journée ATALA : Quels analyseurs syntaxiques pour le français ?},
   TITLE        = {Une boîte à outils pour développer et utiliser les 
      grammaires de prégroupe},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   PDF          = {http://alpage.inria.fr/iwpt09/atala/bechet-foret.pdf},
   ABSTRACT     = {Pregroup grammars are a formalism in the spirit of 
      categorial grammars and the Lambek calculus. In contrast to the 
      latter, their parsing is polynomial. We present in this article a 
      toolbox that contains a parser and a set of programs for the 
      construction and use of grammars, in particular for French. }
}

@INPROCEEDINGS{CDFR2009,
   AUTHOR       = {P. Cellier and M. Ducassé and S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Conf. Software Engineering (SEKE)},
   TITLE        = {DeLLIS: A Data Mining Process for Fault Localization},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {432-437},
   PUBLISHER    = {Knowledge Systems Institute Graduate School},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {data mining, fault localization, software}
}

@INPROCEEDINGS{ducasse09c,
   AUTHOR       = {Mireille Ducassé},
   BOOKTITLE    = {25th International Conference on Logic Programming, ICLP 2009},
   TITLE        = {(C)LP Tracing and Debugging},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Patricia M. Hill and David Scott Warren},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {38},
   PUBLISHER    = {Springer},
   SERIES       = {Lecture Notes in Computer Science},
   VOLUME       = {5649}
}

@INPROCEEDINGS{ducasse09b,
   AUTHOR       = {Mireille Ducassé and Sébastien Ferré},
   BOOKTITLE    = {Modèles et Apprentissage en Sciences Humaines et Sociales},
   TITLE        = {Aide à la décision multicritère : cohérence et équité 
      grâce à l'analyse de concepts},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {Juin},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Décision multicritère, aide à la décision, choix social, 
      analyse formelle de concepts, systèmes d'information logiques, 
      étude de cas},
   ABSTRACT     = {De nombreuses décisions sont prises en commission, par 
      exemple pour affecter des ressources. Les critères de décision sont 
      difficiles à exprimer et la situation globale est en général trop 
      complexe pour que les participants puissent l'appréhender pleinement. 
      Dans cet article, nous décrivons un processus de décision où 
      l'analyse de concepts est utilisée pour faire face à ces problèmes. 
      Grâce à l'analyse de concepts, les personnes fair play ont la 
      possibilité d'être équitables envers les candidats et de faire preuve 
      de cohérence dans leurs jugements sur toute la durée de la réunion. }
}

@INPROCEEDINGS{Fer2009b,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Int. Conf. Conceptual Structures},
   TITLE        = {Efficient Browsing and Update of Complex Data Based on 
      the Decomposition of Contexts},
   YEAR         = {2009},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S. Rudolph and F. Dau and S. O. Kuznetsov},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {159-172},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 5662},
   OPTVOLUME    = {},
   KEYWORDS     = {software component, logical concept analysis, browsing, 
      update},
   ABSTRACT     = {Formal concept analysis is recognized as a good paradigm 
      for browsing data sets. Besides browsing, update and complex data are 
      other important aspects of information systems. To have an efficient 
      implementation of concept-based information systems is difficult 
      because of the diversity of complex data and the computation of 
      conceptual structures, but essential for the scalability to 
      real-world applications. We propose to decompose contexts into 
      simpler and specialized components: logical context functors. We 
      demonstrate this allows for scalable implementations, updatable 
      ontologies, and richer navigation structures, while retaining 
      genericity.}
}

@TECHREPORT{Fer2009c,
   AUTHOR       = {S. Ferré},
   INSTITUTION  = {Institut de Recherche en Informatique et Systèmes Aléatoires (IRISA)},
   TITLE        = {Navigating the Semantic Web with Logical Information 
      Systems},
   YEAR         = {2009},
   OPTADDRESS   = {},
   MONTH        = {August},
   OPTNOTE      = {},
   NUMBER       = {1934},
   TYPE         = {internal publication},
   KEYWORDS     = {logical information systems, semantic web, navigation, 
      querying},
   URL          = {http://www.irisa.fr/centredoc/publis/PI/2009/navigating-the-semantic-web-with-logical-information-systems},
   ABSTRACT     = {Exploratory search is about browsing and understanding 
      an information base. It requires a more interactive process than 
      retrieval search, where the user sends a query and the system returns 
      answers. Logical Information Systems (LIS) support exploratory search 
      by guiding users in the construction of queries, and by giving 
      summaries of query results. The contribution of this paper is to 
      adapt and extend LIS to the Semantic Web. We define a summarization 
      and navigation data structure that provides rich views over data, and 
      guides users from view to view. This guiding is proved consistent 
      (i.e., never leads to an empty result set), and complete (i.e., every 
      query can be reached by navigation only). The query language covers a 
      large fragment of SPARQL, and is more concise by using a syntax close 
      to description logics. Our approach could be implemented on top of 
      existing tools for storing, reasoning and querying.}
}

@MISC{ducasse09,
   AUTHOR       = {Mireille Ducassé},
   HOWPUBLISHED = {Poster aux Rencontres ``Pédagogie et Formations d'Ingénieurs''},
   MONTH        = {Mars},
   NOTE         = {INSA de Toulouse},
   TITLE        = {Cours de conception participative dans la formation 
      d'ingénieur en informatique},
   YEAR         = {2009},
   ABSTRACT     = {On entend souvent des plaintes au sujet d'applications 
      informatiques inadaptées à leurs utilisateurs. Nous pensons que les 
      informaticiens doivent être sensibilisés à la prise en compte des 
      utilisateurs dans la conception et le développement de logiciels. 
      Cela ne relève pas de techniques informatiques, mais c'est néanmoins 
      suffisement délicat et complexe pour justifier un cours. Au 
      département informatique de l'INSA de Rennes, les étudiants réalisent 
      une analyse par conception participative d'un produit grand public. 
      C'est un travail par groupe et collaboratif, tous les groupes 
      travaillent sur le même produit mais avec des utilisateurs 
      différents. Le cours est également sa propre illustration. L'avis des 
      étudiants est systématiquement collecté et le cours est en constante 
      évolution.}
}

@BOOK{ccc,
   PUBLISHER    = {Dunod},
   TITLE        = {Calculateurs, calculs, calculabilité},
   YEAR         = {2008},
   AUTHOR       = {O. Ridoux and G. Lesventes},
   ALTEDITOR    = {},
   OPTADDRESS   = {},
   OPTEDITION   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   SERIES       = {Sciences Sup},
   OPTVOLUME    = {}
}

@PHDTHESIS{Cellier2008PhD,
   AUTHOR       = {Peggy Cellier},
   SCHOOL       = {Thèse de l'université de Rennes 1},
   TITLE        = {DeLLIS : Débogage de programmes par Localisation de 
      fautes avec un Système d'Information Logique},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {05 décembre},
   NOTE         = {coencadrée par Mireille Ducassé, Sébastien Ferré et Olivier Ridoux},
   OPTTYPE      = {}
}

@PHDTHESIS{Denmat2008PhD,
   AUTHOR       = {Tristan Denmat},
   SCHOOL       = {Thèse de l'INSA de Rennes},
   TITLE        = {Contraintes et abstractions pour la génération 
      automatique de données de test},
   YEAR         = {2008},
   OPTADDRESS   = {},
   MONTH        = {05 juin},
   NOTE         = {coencadrée par Mireille Ducassé et Anaud Gotlieb},
   OPTTYPE      = {}
}

@INCOLLECTION{Foret08b,
   AUTHOR       = {Denis Bechet and Alexander Dikovsky and Annie Foret and 
      Emmanuelle Garel},
   BOOKTITLE    = {Computational Algebraic Approaches to Natural Language. Polimetrica Publisher, Italy, pp. 85-108.},
   PUBLISHER    = {},
   TITLE        = {Introduction of option and iteration into pregroup 
      grammars},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCHAPTER   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTSERIES    = {},
   OPTTYPE      = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Pregroups, Lambek Categorial Grammars, 
      Categorial Dependency Grammar},
   ABSTRACT     = {We discuss the relationship between pregroups and 
      dependency grammars. Conventional pregroup grammars do not formally 
      account for optionality and for iteration. We introduce Gentzen-style 
      rules to take care of two new operations, and an equivalent rewriting 
      system. The extended pregroup calculus enjoys several properties 
      shared with traditional dependency grammars, yet does not 
      significantly expand the polynomial complexity of the syntactic 
      analysis on the pregroup grammar.}
}

@ARTICLE{BFRQ2008,
   AUTHOR       = {O. Bedel and S. Ferré and O. Ridoux and E. Quesseveur},
   JOURNAL      = {Revue Internationale de Géomatique},
   TITLE        = {GEOLIS: A Logical Information System for Geographical 
      Data},
   YEAR         = {2008},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {3-4},
   PAGES        = {371-390},
   VOLUME       = {17},
   KEYWORDS     = {logical information system, geographical data, 
      navigation},
   PDF          = {http://www.irisa.fr/LIS/obedel/publis/rig_geolis.pdf},
   ABSTRACT     = {Today, the thematic layer is still the prevailling 
      structure in geomatics for handling geographical information. 
      However, the layer model is rigid: it implies partitionning 
      geographical data in predefined categories and using the same 
      description schema for all elements of a layer. Recently, Logical 
      Information Systems (LIS) introduced a new paradigm for information 
      management and retrieval. Using LIS, we propose a more flexible 
      organisation of vectorial geographical data at a thiner level since 
      it is centered on the geographical feature. LIS do not rely on a 
      hierarchical organisation of information, and enable to tightly 
      combine querying and navigation. In this article, we present the use 
      of LIS to handle geographical data. In particular, we detail a data 
      model for geographical features and the corresponding querying and 
      navigation model. These models have been implemented in the GEOLIS 
      prototype, which has been used to lead experiments on real data.}
}

@ARTICLE{CFRD2008,
   AUTHOR       = {P. Cellier and S. Ferré and O. Ridoux and M. Ducassé},
   JOURNAL      = {Int. J. Foundations of Computer Science (IJFCS)},
   TITLE        = {A Parameterized Algorithm to Explore Formal Contexts 
      with a Taxonomy},
   YEAR         = {2008},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {2},
   PAGES        = {319--343},
   VOLUME       = {19},
   EDITOR       = {S. Ben Yahia and E. Mephu Nguifo},
   KEYWORDS     = {algorithm, concept lattice, taxonomy},
   PUBLISHER    = {World Scientific},
   ABSTRACT     = {Formal Concept Analysis (FCA) is a natural framework to 
      learn from examples. Indeed, learning from examples results in sets 
      of frequent concepts whose extent contains mostly these examples. In 
      terms of association rules, the above learning strategy can be seen 
      as searching the premises of rules where the consequence is set. In 
      its most classical setting, FCA considers attributes as a non-ordered 
      set. When attributes of the context are partially ordered to form a 
      taxonomy, Conceptual Scaling allows the taxonomy to be taken into 
      account by producing a context completed with all attributes deduced 
      from the taxonomy. The drawback, however, is that concept intents 
      contain redundant information. In this article, we propose a 
      parameterized algorithm, to learn rules in the presence of a 
      taxonomy. It works on a non-completed context. The taxonomy is taken 
      into account during the computation so as to remove all redundancies 
      from intents. Simply changing one of its operations, this 
      parameterized algorithm can compute various kinds of concept-based 
      rules. We present instantiations of the parameterized algorithm to 
      learn rules as well as to compute the set of frequent concepts.}
}

@ARTICLE{langevine08,
   AUTHOR       = {Ludovic Langevine and Mireille Ducassé},
   JOURNAL      = {Theory and Practice of Logic Programming, Cambridge University Press},
   TITLE        = {Design and Implementation of a Tracer Driver: Easy and 
      Efficient Dynamic Analyses of Constraint Logic Programs},
   YEAR         = {2008},
   MONTH        = {Sep-Nov},
   OPTNOTE      = {},
   NUMBER       = {5-6},
   OPTPAGES     = {},
   VOLUME       = {8},
   URL          = {http://arxiv.org/abs/0804.4116}
}

@INPROCEEDINGS{AlaFer2008,
   AUTHOR       = {P. Allard and S. Ferré},
   BOOKTITLE    = {DEXA Int. Work. Dynamic Taxonomies and Faceted Search (FIND)},
   TITLE        = {Dynamic Taxonomies for the Semantic Web},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. M. Tjoa and R. R. Wagner},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {382--386},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {semantic web, ontologies, logical information system, 
      dynamic taxonomies},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/find2008-Allard.pdf},
   ABSTRACT     = {The semantic web aims at enabling the web to understand 
      and answer the requests from people and machines. It relies on 
      several standards for representing and reasoning about web contents. 
      Among them, the Web Ontology Language (OWL) is used to define 
      ontologies, i.e. knowledge bases, and is formalized with description 
      logics. In this paper, we demonstrate how dynamic taxonomies and 
      their benefits can be transposed to browse OWL~DL ontologies. We only 
      assume the ontology has an assertional part, i.e. defines objects and 
      not only concepts. The existence of relations between objects in OWL 
      leads us to define new navigation modes for crossing these relations. 
      A prototype, Odalisque, has been developed on top of well-known tools 
      for the semantic web.}
}

@INPROCEEDINGS{Foret08a,
   AUTHOR       = {Denis Bechet and Alexander Dikovsky and Annie Foret and 
      Emmanuelle Garel},
   BOOKTITLE    = {Int. Conf. Language and Automata Theory and Applications (LATA)},
   TITLE        = {Optional and Iterated Types for Pregroup Grammars},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   NOTE         = {Accepted for publication},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Pregroups, Lambek Categorial Grammars, 
      Categorial Dependency Grammar},
   ABSTRACT     = {Pregroup grammars are a context-free grammar formalism 
      which may be used to describe the syntax of natural languages. 
      However, this formalism is not able to easily define types 
      corresponding to optional or iterated arguments like an optional 
      complement of a verb or a sequence of its adverbial modifiers. This 
      paper introduces two constructions that %% solve this issue. make up 
      for this deficiency.}
}

@INPROCEEDINGS{BedFerRid2008,
   AUTHOR       = {O. Bedel and S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {Handling Spatial Relations in Logical Concept Analysis 
      To Explore Geographical Data},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {R. Medina and S. Obiedkov},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {241--257},
   PUBLISHER    = {Springer},
   SERIES       = {LNAI 4933},
   OPTVOLUME    = {},
   KEYWORDS     = {spatial relations, concept analysis, logic, 
      geographical data, data retrieval},
   PDF          = {http://www.irisa.fr/LIS/obedel/publis/icfca08_bedel.pdf},
   ABSTRACT     = {Because of the expansion of geo-positioning tools and 
      the democratization of geographical information, the amount of 
      geo-localized data that is available around the world keeps 
      increasing. So, the ability to efficiently retrieve informations in 
      function of their geographical facet is an important issue. In 
      addition to individual properties such as position and shape, spatial 
      relations between objects are an important criteria for selecting and 
      reaching objects of interest: e.g., given a set of touristic points, 
      selecting those having a nearby hotel or reaching the nearby hotels. 
      In this paper, we propose Logical Concept Analysis (LCA) and its 
      handling of relations for representing and reasoning on various kinds 
      of spatial relations: e.g., Euclidean distance, topological 
      relations. Furthermore, we present an original way of navigating in 
      geolocalized data, and compare the benefits of our approach with 
      traditional Geographical Information Systems (GIS).}
}

@INPROCEEDINGS{icse08,
   AUTHOR       = {Peggy Cellier},
   BOOKTITLE    = {International Conference on Software Engineering (ICSE 2008) Companion},
   TITLE        = {Formal concept analysis applied to fault localization},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = { Robby},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {991-994},
   PUBLISHER    = {ACM},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/icse2008.pdf}
}

@INPROCEEDINGS{CDFR2008a,
   AUTHOR       = {P. Cellier and M. Ducassé and S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {Formal Concept analysis enhances Fault Localization in 
      Software},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {R. Medina and S. Obiedkov},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {273--288},
   PUBLISHER    = {Springer},
   SERIES       = {LNAI 4933},
   OPTVOLUME    = {},
   KEYWORDS     = {fault localization, formal concept analysis},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/icfca2008-cellier.pdf},
   ABSTRACT     = {Recent work in fault localization crosschecks traces of 
      correct and failing execution traces. The implicit underlying 
      technique is to search for association rules which indicate that 
      executing a particular source line will cause the whole execution to 
      fail. This technique, however, has limitations. In this article, we 
      first propose to consider more expressive association rules where 
      several lines imply failure. We then propose to use Formal Concept 
      Analysis (FCA) to analyze the resulting numerous rules in order to 
      improve the readability of the information contained in the rules. 
      The main contribution of this article is to show that applying two 
      data mining techniques, association rules and FCA, produces better 
      results than existing fault localization techniques.}
}

@INPROCEEDINGS{ducasse08,
   AUTHOR       = {Mireille Ducassé and Sébastien Ferré},
   BOOKTITLE    = {Proceedings of the International Conference on Conceptual Structures},
   TITLE        = {Fair(er) and (almost) serene committee meetings with 
      Logical and Formal Concept Analysis},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {P. Eklund and O. Haemmerlé},
   MONTH        = {July},
   NOTE         = {Lecture Notes in Artificial Intelligence 5113},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ANNOTE       = {taux acceptation 19/70 = 27\%},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/iccs2008.pdf},
   ABSTRACT     = { In academia, many decisions are taken in committee, for 
      example to hire people or to allocate resources. Genuine people often 
      leave such meetings quite frustrated. Indeed, it is intrinsically 
      hard to make multi-criteria decisions, selection criteria are hard to 
      express and the global picture is too large for participants to 
      embrace it fully. In this article, we describe a recruiting process 
      where logical concept analysis and formal concept analysis are used 
      to address the above problems. We do not pretend to totally eliminate 
      the arbitrary side of the decision. We claim, however, that, thanks 
      to concept analysis, genuine people have the possibility to 1) be 
      fair with the candidates, 2) make a decision adapted to the 
      circumstances, 3) smoothly express the rationales of decisions, 4) be 
      consistent in their judgements during the whole meeting, 5) vote (or 
      be arbitrary) only when all possibilities for consensus have been 
      exhausted, and 6) make sure that the result, in general a total 
      order, is consistent with the partial orders resulting from the 
      multiple criteria.}
}

@INPROCEEDINGS{Fer2008,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {DEXA Int. Work. Dynamic Taxonomies and Faceted Search (FIND)},
   TITLE        = {Agile Browsing of a Document Collection with Dynamic 
      Taxonomies},
   YEAR         = {2008},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. M. Tjoa and R. R. Wagner},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {377--381},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {browsing, navigation, logical information system, 
      dynamic taxonomies},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/find2008.pdf},
   ABSTRACT     = {Dynamic taxonomies and faceted search are increasingly 
      used to organize and browse document collections. The main function 
      of dynamic taxonomies is to start with the full collection, and 
      zoom-in to a small enough subset of items for direct inspection. In 
      this paper, we present other navigation modes than zoom-in for less 
      directed and more exploratory browsing of a document collection. The 
      presented navigation modes are zoom-out, shift, pivot, and querying 
      by examples. These modes correspond to query transformations, and 
      make use of boolean operators. Therefore, the current focus is always 
      clearly specified by a query.}
}

@ARTICLE{Foret07a,
   AUTHOR       = {D. Bechet and A. Foret and I. Tellier},
   JOURNAL      = {Studia Logica},
   TITLE        = {Learnability of Pregroup Grammars},
   YEAR         = {2007},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {2-3},
   OPTPAGES     = {},
   VOLUME       = {87},
   KEYWORDS     = {Learning from positive examples, Pregroup grammars, 
      Computational linguistics, parsing, Categorial Grammars, constraints},
   ABSTRACT     = { This paper investigates the learnability by positive 
      examples in the sense of Gold of Pregroup Grammars. In a first part, 
      Pregroup Grammars are presented and a new parsing strategy is prop 
      osed. Then, theoretical learnability and non-learnability results for 
      subclasses of Pregroup Grammars are proved. In the last two parts, we 
      focus on learning Pregroup Grammars from a sp ecial kind of input 
      called feature-tagged examples. A learning algorithm based on the 
      parsing strategy presented in the first part is given. Its validity 
      is proved and its prop erties are examplified. }
}

@ARTICLE{Foret07b,
   AUTHOR       = {D. Béchet and R. Bonato and A. Dikovsky and A. Foret and 
      Y. Le Nir and E. Moreau and C. Retoré and I. Tellier},
   JOURNAL      = {Recherches linguistiques de Vincennes},
   TITLE        = {``Modèles algorithmiques de l'acquisition de la syntaxe 
      : concepts et méthodes, résultats et problèmes},
   YEAR         = {2007},
   OPTMONTH     = {},
   NOTE         = {Vol. 37, Presses Universitaires de Vincennes},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Acquisition syntaxique, inférence grammaticale, 
      grammaires catégorielles, modèle de Gold, 
      ressources syntaxiques (syntax learning, grammatical inference, 
      categorial grammars, Gold's model, syntactical resources)},
   PDF          = {http://rlv.revues.org/document1492.html},
   ABSTRACT     = { Dans cet article, nous prÃ©sentons nos rÃ©sultats 
      rÃ©cents concernant l'apprentissage de la syntaxe des langues 
      naturelles, en adoptant le point de vue de l'infÃ©rence grammaticale 
      symbolique. L'objectif est d'identifier Ã partir d'exemples, dans une 
      classe de grammaires connue Ã l'avance, une grammaire particuliÃ¨re 
      qui engendre les dits exemples. Le modÃ¨le de Gold fixe les 
      conditions et le critÃ¨re de rÃ©ussite d'une telle entreprise : quand 
      un algorithme produisant une grammaire candidate existe-t-il ? quelle 
      structure doivent contenir les exemples : suites de mots, suites de 
      mots Ã©tiquetÃ©s, arbres d'analyse ? D'un point de vue thÃ©orique, 
      nos rÃ©sultats Ã©tablissent l'apprenabilitÃ© ou la non-apprenabilitÃ© 
      de certaines classes de grammaires catÃ©gorielles. En pratique, nos 
      rÃ©sultats permettent aussi d'acquÃ©rir automatiquement des 
      ressources syntaxiques Ã partir de donnÃ©es rÃ©elles. Au final, nous 
      discutons de l'intÃ©rÃªt de cette approche pour modÃ©liser 
      l'acquisition de leur langue naturelle par les enfants ainsi que pour 
      construire automatiquement des grammaires Ã©lectroniques Ã partir de 
      corpus. In this paper, we present our recent results on the 
      acquistion of the syntax of natural languages, from the point of view 
      of the theory of grammatical inference. Given a class of possible 
      grammars, the objective is to identify, from a set of positive 
      examples, a grammar in the class which produces the examples. The 
      Gold model formalises the learning process and gives stringent 
      criteria of its success: when does there exist an algorithm producing 
      a target grammar ? what kind of structure should the examples have 
      (strings of words, strings of tagged words, trees) ? From a 
      theoretical point of view, our results establish the learnability or 
      the unlearnability of various classes of categorial grammars. From a 
      practical perspective, these results enable the extraction of 
      syntactic information from real data. Finally, we discuss the 
      interest of this approach for modelling child language acquisition 
      and for automated induction of grammars from corpora. }
}

@INPROCEEDINGS{BedFerRid2007a,
   AUTHOR       = {O. Bedel and S. Ferré and O. Ridoux},
   BOOKTITLE    = {DEXA Work. Advances in Conceptual Knowledge Engineering (ACKE)},
   TITLE        = {Exploring a Geographical Dataset with GEOLIS},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {540--544},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {logical information system, 
      geographical information system, information retrieval, 
      spatial logic},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/acke2007.pdf},
   ABSTRACT     = {Geographical data are mainly structured in layers of 
      information. However, this model of organisation is not convenient 
      for navigation inside a dataset, and so limits geographical data 
      exploration to querying. We think information retrieval could be made 
      easier in GIS by the introduction of a navigation based on 
      geographical object properties. For this purpose, we propose a 
      prototype, GEOLIS1, which tightly combines querying and navigation in 
      the search process of geographical data. GEOLIS relies on Logical 
      Information Systems (LIS), which are based on Formal Concept Analysis 
      (FCA) and logics. In this paper, we detail data organisation and 
      navigation process in GEOLIS. We also present the results of an 
      experimentation led on a real dataset.}
}

@INPROCEEDINGS{Foret07d,
   AUTHOR       = {D. Béchet and A. Foret},
   BOOKTITLE    = {Proceedings of WOLLIC 2007},
   TITLE        = {Fully Lexicalized Pregroup Grammars},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {12--25},
   PUBLISHER    = {Springer},
   OPTSERIES    = {},
   VOLUME       = {LNCS 4576},
   KEYWORDS     = {Pregroups, Lambek Categorial Grammars, Simulation},
   PDF          = {http://www.springerlink.com/content/dn21412422761255/?p=8a0b76b8ad414c23a5d75a11ec27652f&pi=25},
   ABSTRACT     = { Pregroup grammars are a context-free grammar formalism 
      introduced as a simplification of Lambek calculus. This formalism is 
      interesting for several reasons: the syntactical properties of words 
      are specified by a set of types like the other type-based grammar 
      formalisms ; as a logical model, compositionality is easy ; a 
      polytime parsing algorithm exists. However, this formalism is not 
      completely lexicalized because each pregroup grammar is based on the 
      free pregroup built from a set of primitive types together with a 
      partial order, and this order is not lexical information. In fact, 
      only the pregroup grammars that are based on primitive types with an 
      order that is equality can be seen as fully lexicalized. We show here 
      how we can transform, using a morphism on types, a particular 
      pregroup grammar into another pregroup grammar that uses the equality 
      as the order on primitive types. This transformation is at most 
      quadratic in size (linear for a fixed set of primitive types), it 
      preserves the parse structures of sentences and the number of types 
      assigned to a word. }
}

@INPROCEEDINGS{CFRD2007,
   AUTHOR       = {P. Cellier and S. Ferré and O. Ridoux and M. Ducassé},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {A Parameterized Algorithm for Exploring Concept Lattices},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S.O. Kuznetsov and S. Schmidt},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer},
   SERIES       = {LNAI 4390},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, algorithm, taxonomy},
   ABSTRACT     = {Formal Concept Analysis (FCA) is a natural framework for 
      learning from positive and negative examples. Indeed, learning from 
      examples results in sets of frequent concepts whose extent contains 
      only these examples. In terms of association rules, the above 
      learning strategy can be seen as searching the premises of exact 
      rules where the consequence is fixed. In its most classical setting, 
      FCA considers attributes as a non-ordered set. When attributes of the 
      context are ordered, Conceptual Scaling allows the related taxonomy 
      to be taken into account by producing a context completed with all 
      attributes deduced from the taxonomy. The drawback, however, is that 
      concept intents contain redundant information. In this article, we 
      propose a parameterized generalization of a previously proposed 
      algorithm, in order to learn rules in the presence of a taxonomy. The 
      taxonomy is taken into account during the computation so as to remove 
      all redundancies from intents. Simply changing one component, this 
      parameterized algorithm can compute various kinds of concept-based 
      rules. We present instantiations of the parameterized algorithm for 
      learning positive and negative rules.}
}

@INPROCEEDINGS{denmat07,
   AUTHOR       = {Tristan Denmat and Arnaud Gotlieb and Mireille Ducassé},
   BOOKTITLE    = {Int. Conf. Principles and Practice of Constraint Programming (CP)},
   TITLE        = {An Abstract Interpretation-based Combinator for 
      Modelling While Loops in Constraint Programming},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {C. Bessière},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {LNCS 4741},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{denmat07b,
   AUTHOR       = {Tristan Denmat and Arnaud Gotlieb and Mireille Ducassé},
   BOOKTITLE    = {Int. Symp. Software Reliability Engineering (ISSRE)},
   TITLE        = {Improving Constraint-Based Testing with Dynamic Linear 
      Relaxations},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {K. Goseva-Popstojanova and P. Runeson},
   MONTH        = {November},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IEEE Press},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{deransart07,
   AUTHOR       = {Pierre Deransart and Mireille Ducassé and Gérard Ferrand},
   BOOKTITLE    = {Actes de Troisièmes Journées Francophones de Programmation par Contraintes},
   TITLE        = {Une sémantique observationnelle du modèle des boîtes 
      pour la résolution de programmes logiques},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {F. Fages},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {HAL : http://hal.inria.fr/JFPC07},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Fer2007b,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Int. Conf. Concept Lattices and Their Applications},
   TITLE        = {CAMELIS: Organizing and Browsing a Personal Photo 
      Collection with a Logical Information System},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {J. Diatta and P. Eklund and M. Liquière},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {112--123},
   OPTPUBLISHER = {},
   SERIES       = {CEUR Workshop Proceedings ISSN 1613-0073},
   VOLUME       = {331},
   KEYWORDS     = {logical information system, photo collection, 
      organization, information retrieval},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/cla2007.pdf},
   ABSTRACT     = {Since the arrival of digital cameras, many people are 
      faced to the challenge of organizing and retrieving the overwhelming 
      flow of photos their life produces. Most people put no metadata on 
      their photos, and we believe this is because existing tools make a 
      very limited use of them. We present a tool, Camelis, that offers 
      users with an organization of photos that is dynamically computed 
      from the metadata, making worthwhile the effort to produce it. 
      Camelis is designed along the lines of Logical Information Systems 
      (LIS), which are founded on logical concept analysis. Hence, (1) an 
      expressive language can be used to describe photos and query the 
      collection, (2) manual and automatic metadata can be smoothly 
      integrated, and (3) expressive querying and flexible navigation can 
      be mixed in a same search and in any order. This presentation is 
      illustrated by experiences on a real collection of more than 5000 
      photos.}
}

@INPROCEEDINGS{Fer2007a,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {The Efficient Computation of Complete and Concise 
      Substring Scales with Suffix Trees},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S.O. Kuznetsov and S. Schmidt},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer},
   SERIES       = {LNAI 4390},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, logic, string, suffix tree},
   ABSTRACT     = {Strings are an important part of most real application 
      multi-valued contexts. Their conceptual treatment requires the 
      definition of {\em substring scales}, i.e., sets of relevant 
      substrings, so as to form informative concepts. However these scales 
      are either defined by hand, or derived in a context-unaware manner 
      (e.g., all words occuring in string values). We present an efficient 
      algorithm based on suffix trees that produces complete and concise 
      substring scales. Completeness ensures that every possible concept is 
      formed, like when considering the scale of all substrings. 
      Conciseness ensures the number of scale attributes (substrings) is 
      less than the cumulated size of all string values. This algorithm is 
      integrated in Camelis, and illustrated on the set of all ICCS paper 
      titles.}
}

@INPROCEEDINGS{FerRid2007,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {DEXA Work. Dynamic Taxonomies and Faceted Search (FIND)},
   TITLE        = {Logical Information Systems: from Taxonomies to Logics},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {212--216},
   PUBLISHER    = {IEEE Computer Society},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {logical information system, taxonomy, logic},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/find2007.pdf},
   ABSTRACT     = {Dynamic taxonomies have been proposed as a solution for 
      combining querying and navigation, offering both expressivity and 
      interactivity. Navigation is based on the filtering of a 
      multidimensional taxonomy w.r.t. query answers, which helps users to 
      focus their search. We show that properties that are commonly used 
      only in queries can be integrated in taxonomies, and hence in 
      navigation, by the use of so-called logics. Hand-designed taxonomies 
      and concrete domains (e.g., dates, strings) can be combined so as to 
      form complex taxonomies. For instance, valued attributes can be 
      handled, and different roles between documents and locations can be 
      distinguished. Logical Information Systems (LIS) are characterized by 
      the combination of querying and navigation, and the systematic use of 
      logics.}
}

@INPROCEEDINGS{Foret07c,
   AUTHOR       = {A. Foret},
   BOOKTITLE    = {Proceedings of WOLLIC 2007},
   TITLE        = {Pregroup Calculus as a Logical Functor},
   YEAR         = {2007},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer},
   OPTSERIES    = {},
   VOLUME       = {LNCS 4576},
   KEYWORDS     = {Pregroups, Lambek Categorial Grammars, Logic Functor, 
      Cut Elimination},
   PDF          = {http://www.springerlink.com/content/f51674814541n234/?p=8a0b76b8ad414c23a5d75a11ec27652f&pi=20},
   ABSTRACT     = { The concept of pregroup was introduced by Lambek for 
      natural language analysis, with a close link to non-commutative 
      linear logic. We reformulate the pregroup calculus so as to extend it 
      by composition with other logics and calculii.The cut elimination 
      property and the decidabilityproperty of the sequent calculus 
      proposed in the article are shown.Properties of composed calculii are 
      also discussed. }
}

@PHDTHESIS{Tombini06,
   AUTHOR       = {Elvis Tombini},
   SCHOOL       = {INSA de Rennes},
   TITLE        = {Amélioration du diagnostic en détection d'intrusions : 
      étude et application d'une combinaison de méthodes de détection 
      d'intrusions comportementale et par scénarios},
   YEAR         = {2006},
   OPTADDRESS   = {},
   MONTH        = {septembre},
   NOTE         = {M. Ducassé, H. Debar et L. Mé, directeurs de thèse},
   OPTTYPE      = {}
}

@ARTICLE{Foret06tcs,
   AUTHOR       = {Denis Bechet and Annie Foret},
   JOURNAL      = {Journal of Theoretical Computer Science},
   TITLE        = {k-Valued Non-Associative Lambek Grammars are learnable 
      from Generalized Functor-Argument Structures},
   YEAR         = {2006},
   OPTMONTH     = {},
   NOTE         = {Vol. 355, 2 (extended version)},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Grammatical inference, Categorial grammars, 
      Non-associative Lambek calculus, Learning from positive examples, 
      Model of Gold},
   PDF          = {http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V1G-4J6230G-2&_user=6068168&_rdoc=1&_fmt=&_orig=search&_sort=d&view=c&_acct=C000016487&_version=1&_urlVersion=0&_userid=6068168&md5=1f61f9cb9faf4705a95c1494b7f68602},
   ABSTRACT     = { This paper is concerned with learning categorial 
      grammars from positive examples in the model of Gold. 
      Functor-argument structures (written FA) are usual syntactical 
      decompositions of sentences in sub-components distinguishing the 
      functional parts from the argument parts defined in the case of 
      classical categorial grammars also known as AB-grammars. In the case 
      of non-associative type-logical grammars, we propose a similar notion 
      that we call generalized functor-argument structures and we show that 
      these structures capture the essence of non-associative Lambek (NL) 
      calculus without product. We show that (i) rigid and k-valued 
      non-associative Lambek (NL without product) grammars are learnable 
      from generalized functor-argument structured sentences. We also 
      define subclasses of k-valued grammars in terms of arity. We first 
      show that (ii) for each k and each bound on arity the class of 
      FA-arity bounded k-valued NL languages of FA structures is finite and 
      (iii) that FA-arity bounded k-valued NL grammars are learnable both 
      from strings and from FA structures as a corollary. Result (i) is 
      obtained from (ii); this learnability result (i) is interesting and 
      surprising when compared to other results: in fact we also show that 
      (iv) this class has infinite elasticity. Moreover, these classes are 
      very close to classes like rigid associative Lambek grammars learned 
      from natural deduction structured sentences (that are different and 
      much richer than FA or generalized FA) or to k-valued non-associative 
      Lambek grammars unlearnable from strings or even from bracketed 
      strings. Thus, the class of k-valued non-associative Lambek grammars 
      learned from generalized functor-argument sentences is at the 
      frontier between learnable and unlearnable classes of languages. }
}

@ARTICLE{FerKin2006,
   AUTHOR       = {S. Ferré and R. D. King},
   JOURNAL      = {Journal of Computational Biology},
   TITLE        = {Finding Motifs in Protein Secondary Structure for Use in 
      Function Prediction},
   YEAR         = {2006},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {3},
   PAGES        = {719--731},
   VOLUME       = {13},
   KEYWORDS     = {functional genomics, protein secondary structure, 
      flexible motifs, dichotomic search algorithm}
}

@ARTICLE{tsi-indexation-composants,
   AUTHOR       = {Benjamin Sigonneau and Olivier Ridoux},
   JOURNAL      = {Technique et Science Informatiques},
   TITLE        = {Indexation multiple et automatisée de composants 
      logiciels},
   YEAR         = {2006},
   OPTMONTH     = {},
   NOTE         = {À paraître},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   ANNOTE       = {Numéro thématique AFADL'04},
   PDF          = {http://www.irisa.fr/lande/sigonneau/publications/articles/tsi-preprint.pdf},
   ABSTRACT     = {Software reuse requires that programmers be able to 
      locate reusable components in software repositories. We propose that 
      a general information retrieval framework, which is able to combine 
      arbitrary indexing schemes and called Logical Information Systems, is 
      applied to querying in software repositories. As an illustration, 
      indexing of methods in a package is studied, and three indexing 
      schemes are presented in this framework: a formal scheme, a 
      semi-formal one, and an informal one. The formal one captures 
      object-orientation by combining type isomorphism axioms and 
      inheritance relations. The semi-formal scheme captures naming 
      conventions and the informal one captures keywords in comments. 
      Theory of the formal methods and details on the experiments are 
      presented.}
}

@INPROCEEDINGS{BFRQ2006,
   AUTHOR       = {O. Bedel and S. Ferré and O. Ridoux and E. Quesseveur},
   BOOKTITLE    = {Int. Conf. Spatial Analysis and GEOmatics - SAGEO 2006},
   TITLE        = {GEOLIS: A Logical Information System for Geographical 
      Data},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {logical information systems, geographical data, 
      navigation, querying},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/sageo2006.pdf},
   ABSTRACT     = {Today, the thematic layer is still the prevailling 
      structure in geomatics for handling geographical information. 
      However, the layer model is rigid: it implies partitionning 
      geographical data in predefined categories and using the same 
      description schema for all elements of a layer. Recently, Logical 
      Information Systems (LIS) introduced a new paradigm for information 
      management and retrieval. Using LIS, we propose a more flexible 
      organisation of vectorial geographical data at a thiner level since 
      it is centered on the geographical feature. LIS does not rely on a 
      hierarchical organisation of information, and enable to tightly 
      combine querying and navigation in a same search. In this article, we 
      present a work in progress about the use of LIS model to handle 
      geographical data. In particular, we detail a data model for 
      geographical features and the corresponding querying and navigation 
      model. These models have been implemented in the GEOLIS prototype, 
      which has been used to lead experiments with real data.}
}

@INPROCEEDINGS{BedRidQue2006,
   AUTHOR       = {O. Bedel and O. Ridoux and E. Quesseveur},
   BOOKTITLE    = {Int. Conf. Free and OpenSource Sofware for Geoinformatics},
   TITLE        = {Combining Logical Information System and OpenGIS Tools 
      for Geographical Data Exploration},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {september},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {logical information system, GIS, graphical data},
   URL          = {http://www.foss4g2006.org/contributionDisplay.py?contribId=131&sessionId=51&confId=1}
}

@INPROCEEDINGS{CFRD2006,
   AUTHOR       = {P. Cellier and S. Ferré and O. Ridoux and M. Ducassé},
   BOOKTITLE    = {Int. Conf. Concept Lattices and Their Applications},
   TITLE        = {An Algorithm to Find Frequent Concepts of a Formal 
      Context with Taxonomy},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S. Ben Yahia and E. Mephu Nguifo},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {243--248},
   PUBLISHER    = {Springer},
   SERIES       = {LNAI 4932},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, algorithm, taxonomy},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/cla2006.pdf},
   ABSTRACT     = {Formal Concept Analysis (FCA) considers attributes as a 
      non-ordered set. This is appropriate when the data set is not 
      structured. When an attribute taxonomy exists, existing techniques 
      produce a completed context with all attributes deduced from the 
      taxonomy. Usual algorithms can then be applied on the completed 
      context for finding frequent concepts, but the results systematically 
      contain redundant information. This article describes an algorithm 
      which allows the frequent concepts of a formal context with taxonomy 
      to be computed. It works on a non-completed context and uses the 
      taxonomy information when needed. The results avoid the redundancy 
      problem with equivalent performance.}
}

@INPROCEEDINGS{Fer2006b,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {Negation, Opposition, and Possibility in Logical Concept 
      Analysis.},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Rokia Missaoui and Jürg Schmid},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {130-145},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 3874},
   OPTVOLUME    = {},
   KEYWORDS     = {logic, concept analysis, epistemic logic, all i know}
}

@INPROCEEDINGS{LISFS2006,
   AUTHOR       = {Y. Padioleau and B. Sigonneau and O. Ridoux},
   BOOKTITLE    = {Int. Conf. Software Engineering},
   TITLE        = {LISFS: a logical information system as a file system 
      (demo)},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Leon J. Osterweil and H. Dieter Rombach and 
      Mary Lou Soffa},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {803-806},
   PUBLISHER    = {ACM},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Foret06a,
   AUTHOR       = {Eric Poupard and Denis Bechet and Annie Foret},
   BOOKTITLE    = {Actes de la Conférence d'APprentissage 2006 (CAP'06)},
   TITLE        = {Categorial Grammar Acquisition from a French Treebank},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   NOTE         = {(Poster)},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{SigRid2006a,
   AUTHOR       = {B. Sigonneau and O. Ridoux},
   BOOKTITLE    = {ICSE Work. Mining Software Repositories},
   TITLE        = {Software Engineering Applications of Logic File System 
      -- Application to Automated Multi-Criteria Indexation of Software 
      Components},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{vautier06,
   AUTHOR       = {Alexandre Vautier and Marie-Odile Cordier and 
      Mireille Ducassé and René Quiniou},
   BOOKTITLE    = {Actes de l'atelier ``Fouille de données temporelles'' associé aux 6es Journées Francophones ``Extraction et de Gestion des Connaissances''},
   TITLE        = {Agrégation d'alarmes faiblement structurées},
   YEAR         = {2006},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {Janvier},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.irisa.fr/dream/Pages_Pros/Alexandre.Vautier/publis/egc_06_vpn.pdf},
   ABSTRACT     = {La contribution principale de ce document est une 
      approche plaçant l'opérateur au coeur de l'analyse de journaux 
      d'alarmes faiblement structurées en lui permettant d'utiliser ce 
      qu'il sait, même si ses connaissances sont partielles, et sans le 
      submerger d'informations. Des motifs temporels structurés sont 
      extraits par agrégation d'alarmes généralisées et corrélation se 
      basant sur la date des alarmes et sur la similarité d'attributs 
      autres que la date. L'approche est appliquée aux alarmes produites 
      par un concentrateur VPN (Virtual Private Network). Une étude de cas 
      montre comment 5000 d'alarmes peuvent être regroupées en 50 motifs.}
}

@TECHREPORT{FerRid2006a,
   AUTHOR       = {S. Ferré and O. Ridoux},
   INSTITUTION  = {Irisa},
   TITLE        = {Logic Functors: A Toolbox of Components for Building 
      Customized and Embeddable Logics},
   YEAR         = {2006},
   OPTADDRESS   = {},
   MONTH        = {March},
   OPTNOTE      = {},
   NUMBER       = {RR-5871},
   TYPE         = {Research Report},
   KEYWORDS     = {logic, components, modules and functors, 
      theorem provers, type checking, application developpement},
   PAGES        = {103 p.},
   URL          = {http://www.inria.fr/rrrt/rr-5871.html},
   ABSTRACT     = {Logic Functors form a framework for specifying new 
      logics, and deriving automatically theorem provers and 
      consistency/completeness diagnoses. Atomic functors are logics for 
      manipulating symbols and concrete domains, while other functors are 
      logic transformers that may add connectives or recursive structures, 
      or may alter the semantics of a logic. The semantic structure of the 
      framework is model theoretic as opposed to the verifunctional style 
      often used in classical logic. This comes close to the semantics of 
      description logics, and we show indeed that the logic~${\cal ALC}$ 
      can be rebuilt using logic functors. This offers the immediate 
      advantage that variants of~${\cal ALC}$ can be explored and 
      implemented almost for free. This report comes with extensive 
      appendices describing in detail a toolbox of logic functors 
      (definitions, algorithms, theorems, and proofs).}
}

@TECHREPORT{creFT2006,
   AUTHOR       = {Alexandre Vautier and Marie-Odile Cordier and 
      Mireille Ducassé and René Quiniou},
   INSTITUTION  = {IRISA},
   TITLE        = {Visualization of Internet Flow Records},
   YEAR         = {2006},
   OPTADDRESS   = {},
   MONTH        = {november},
   NOTE         = {CURAR deliverable - CRE France Telecom R & D},
   NUMBER       = {1828},
   TYPE         = {Publication Interne}
}

@PHDTHESIS{Pad2005,
   AUTHOR       = {Y. Padioleau},
   SCHOOL       = {Université de Rennes 1},
   TITLE        = {Logic File System, un système de fichier basé sur la 
      logique},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {February},
   OPTNOTE      = {},
   TYPE         = {Thèse d'université},
   KEYWORDS     = {file system, logical information system, navigation, 
      file}
}

@ARTICLE{FerKin2004b,
   AUTHOR       = {S. Ferré and R. D. King},
   JOURNAL      = {Fundamenta Informaticae -- Special Issue on Advances in Mining Graphs, Trees and Sequences},
   TITLE        = {A dichotomic search algorithm for mining and learning in 
      domain-specific logics},
   YEAR         = {2005},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {1-2},
   PAGES        = {1--32},
   VOLUME       = {66},
   KEYWORDS     = {machine learning, logic, concept analysis, data-mining, 
      logic functors},
   PUBLISHER    = {IOS Press},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/fi-mgts2004.pdf},
   ABSTRACT     = { Many application domains make use of specific data 
      structures such as sequences and graphs to represent knowledge. These 
      data structures are ill-fitted to the standard representations used 
      in machine learning and data-mining algorithms: propositional 
      representations are not expressive enough, and first order ones are 
      not efficient enough. In order to efficiently represent and reason on 
      these data structures, and the complex patterns that are related to 
      them, we use domain-specific logics. We show these logics can be 
      built by the composition of logical components that model elementary 
      data structures. The standard strategies of top-down and bottom-up 
      search are ill-suited to some of these logics, and lack flexibility. 
      We therefore introduce a dichotomic search strategy, that is 
      analogous to a dichotomic search in an ordered array. We prove this 
      provides more flexibility in the search, while retaining completeness 
      and non-redundancy. We present a novel algorithm for learning using 
      domain specific logics and dichotomic search, and analyse its 
      complexity. We also describe two applications which illustrates the 
      search for motifs in sequences; where these motifs have arbitrary 
      length and length-constrained gaps. In the first application 
      sequences represent the trains of the East-West challenge; in the 
      second application they represent the secondary structure of Yeast 
      proteins for the discrimination of their biological functions.}
}

@INPROCEEDINGS{Foret05b,
   AUTHOR       = {Denis Bechet and Alexandre Dikovsky and Annie Foret},
   BOOKTITLE    = {Proceedings of the LACL 2005 Conference : Logical Aspects of Computational Linguistics, LNCS(LNAI) 3492},
   TITLE        = {Dependency Structure Grammars},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {18--34},
   PUBLISHER    = {springer},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   PDF          = {http://www.springerlink.com/content/yda6x9u1t99y3198/},
   ABSTRACT     = { In this paper, we define Dependency Structure Grammars 
      (DSG), which are rewriting rule grammars generating sentences 
      together with their dependency structures, are more expressive than 
      CF-grammars and non-equivalent to mildly context-sensitive grammars. 
      We show that DSG are weakly equivalent to Categorial Dependency 
      Grammars (CDG) recently introduced in [6,3]. In particular, these 
      dependency grammars naturally express long distance dependencies and 
      enjoy good mathematical properties. }
}

@INPROCEEDINGS{For05c,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {FGMOL'05, the tenth conference on Formal Grammar and the ninnth on the Mathematics of Language},
   TITLE        = {On Rigid NL Lambek Grammars Inference from Generalized 
      Functor-Argument Data},
   YEAR         = {2005},
   ADDRESS      = {Edinburgh, Scotland},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {grammatical inference, categorial grammars, 
      non- associative Lambek calculus, learning from positive examples, 
      model of Gold},
   ABSTRACT     = { This paper is concerned with the inference of 
      categorial grammars, a context-free grammar formalism in the field of 
      computational linguistics. A recent result has shown that whereas 
      they are not learnable from strings in the model of Gold, rigid and 
      k-valued non-asso ciative Lamb ek grammars are still learnable from 
      generalized functor-argument structured sentences. We fo cus here on 
      the algorithmic part of this result and provide an algo- rithm that 
      can b e seen as an extension of Buszkowski, Penn and Kanazawa's 
      contributions for classical categorial grammars. }
}

@INPROCEEDINGS{Foret05a,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Proceedings of the LACL 2005 Conference: Logical Aspects of Computational Linguistics, LNCS(LNAI) 3492},
   TITLE        = {k-Valued Non-Associative Lambek Grammars (without 
      Product) Form a Strict Hierarchy of Languages},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {1--17},
   PUBLISHER    = {springer},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   PDF          = {http://www.springerlink.com/content/k4cy3ynkmmd56hct/},
   ABSTRACT     = { The notion of k-valued categorial grammars where a word 
      is associated to at most k types is often used in the field of 
      lexicalized grammars as a fruitful constraint for obtaining several 
      properties like the existence of learning algorithms. This principle 
      is relevant only when the classes of k-valued grammars correspond to 
      a real hierarchy of languages. This paper establishes the relevance 
      of this notion for two related grammatical systems. In the first 
      part, the classes of k-valued non-associative Lambek (NL) grammars 
      without product is proved to define a strict hierarchy of languages. 
      The second part introduces the notion of generalized functor argument 
      for non-associative Lambek ($NL_{\emptyset}$) calculus without 
      product but allowing empty antecedent and establishes also that the 
      classes of k-valued ($NL_{\emptyset}$) grammars without product form 
      a strict hierarchy of languages }
}

@INPROCEEDINGS{denmat05b,
   AUTHOR       = {T. Denmat and M. Ducassé and O. Ridoux},
   BOOKTITLE    = {Proceedings of the 20th IEEE/ACM International Conference on Automated Software Engineering},
   TITLE        = {Data mining and cross-checking of execution traces. A 
      re-interpretation of Jones, Harrold and Stasko test information 
      visualization},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {T. Ellman and A. Zisman},
   MONTH        = {November},
   NOTE         = {See RR-5661 for a long version of this article},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software Engineering, Debugging, 
      Artificial Intelligence, Learning, Knowledge acquisition},
   ABSTRACT     = {The current trend in debugging and testing is to 
      cross-check information collected during several executions. Jones et 
      al., for example, propose to use the instruction coverage of passing 
      and failing runs in order to visualize suspicious statements. This 
      seems promising but lacks a formal justification. In this paper, we 
      show that the method of Jones et al. can be re-interpreted as a data 
      mining procedure. More particularly, they define an indicator which 
      characterizes association rules between data. With this formal 
      framework we are able to explain intrinsic limitations of the above 
      indicator.}
}

@INPROCEEDINGS{DGD05,
   AUTHOR       = {T. Denmat and A. Gotlieb and M. Ducassé},
   BOOKTITLE    = {Proceedings of the 15th Workshop on Logic-based Method for Programming Environments},
   TITLE        = {Proving or Disproving Likely Invariants with Constraint 
      Reasoning},
   YEAR         = {2005},
   ADDRESS      = {Sitges, SPAIN},
   OPTCROSSREF  = {},
   EDITOR       = {A. Serebrenik},
   MONTH        = {October},
   NOTE         = {Satelite event of International Conference on Logic Programming (ICLP'2005). Published in Computer Research Repository cs.SE/0508108},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software Engineering, Testing and Debugging, 
      Program verification, Constraint and logic languages},
   URL          = {http://arxiv.org/abs/cs.pl/0508108},
   ABSTRACT     = {A program invariant is a property that holds for every 
      execution of the program. Recent work suggest to infer likely-only 
      invariants, via dynamic analysis. A likely invariant is a property 
      that holds for some executions but is not guaranteed to hold for all 
      executions. In this paper, we present work in progress addressing the 
      challenging problem of automatically verifying that likely invariants 
      are actual invariants. We propose a constraint-based reasoning 
      approach that is able, unlike other approaches, to both prove or 
      disprove likely invariants. In the latter case, our approach provides 
      counter-examples. We illustrate the approach on a motivating example 
      where automatically generated likely invariants are verified. }
}

@INPROCEEDINGS{FerRidSig2005,
   AUTHOR       = {S. Ferré and O. Ridoux and B. Sigonneau},
   BOOKTITLE    = {ICCS},
   TITLE        = {Arbitrary Relations in Formal Concept Analysis and 
      Logical Information Systems},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {166-180},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 3596},
   OPTVOLUME    = {},
   KEYWORDS     = {logical concept analysis, relation, 
      logical information system, navigation},
   ABSTRACT     = {A logical view of formal concept analysis considers 
      attributes of a formal context as unary predicates. In a first part, 
      we propose an augmented definition that handles {\em binary 
      relations} between objects. A Galois connection is defined on 
      augmented contexts. It represents concept inheritance as usual, but 
      also relations between concepts. As usual, labeling operators are 
      also defined. In particular, concepts and relations are visible and 
      labeled in a single structure. In a second part, we show how 
      relations can be used for navigating in an augmented concept lattice. 
      This part augments the theory of Logical Information Systems. An 
      implementation is sketched, and first experimental results are 
      presented.}
}

@INPROCEEDINGS{langevine05,
   AUTHOR       = {L. Langevine and M. Ducassé},
   BOOKTITLE    = {Proceedings of the 6th Automated Debugging Symposium},
   TITLE        = {A Tracer Driver for Hybrid Execution Analyses},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {September},
   NOTE         = {see RR-5611 for a longer version of this article},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software Engineering, Debugging, Monitors, Tracing, 
      Programming Environments},
   URL          = {http://doi.acm.org/10.1145/1085130.1085149},
   ABSTRACT     = {Tracers provide users with useful information about 
      program executions. In this paper we propose a ``tracer driver'', 
      from a single tracer, it provides a powerful front-end for multiple 
      dynamic analysis tools while limiting the overhead of the trace 
      generation. The tracer driver can be used both synchronously and 
      asynchronously. The relevant execution events are specified by 
      flexible event patterns and a large variety of trace data can be 
      given either systematically or ``on demand''. The proposed tracer 
      driver has been designed and experimented in the context of 
      constraint logic programming, within GNU-Prolog. Its principles are, 
      however, independent of the traced programming language. Experimental 
      measures show that the flexibility and power of the described 
      architecture are also the basis of reasonable performances. }
}

@INPROCEEDINGS{langevine05b,
   AUTHOR       = {L. Langevine and M. Ducassé},
   BOOKTITLE    = {Proceedings of the 15th Workshop on Logic-based Method for Programming Environments},
   TITLE        = {A Tracer Driver for Versatile Dynamic Analyses of 
      Constraint Logic Programs},
   YEAR         = {2005},
   ADDRESS      = {Sitges, SPAIN},
   OPTCROSSREF  = {},
   EDITOR       = {A. Serebrenik},
   MONTH        = {October},
   NOTE         = {Satelite event of International Conference on Logic Programming (ICLP'2005). Published in Computer Research Repository cs.SE/0508105},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software Engineering, Debugging, Monitors, Tracing, 
      Programming Environments},
   URL          = {http://arxiv.org/abs/cs.pl/0508105},
   ABSTRACT     = {Programs with constraints are hard to debug. In this 
      paper, we describe a general architecture to help develop new 
      debugging tools for constraint programming. The possible tools are 
      fed by a single general-purpose tracer. A tracer-driver is used to 
      adapt the actual content of the trace, according to the needs of the 
      tool. This enables the tools and the tracer to communicate in a 
      client-server scheme. Each tool describes its needs of execution data 
      thanks to event patterns. The tracer driver scrutinizes the execution 
      according to these event patterns and sends only the data that are 
      relevant to the connected tools. Experimental measures show that this 
      approach leads to good performance in the context of constraint logic 
      programming, where a large variety of tools exists and the trace is 
      potentially huge. }
}

@INPROCEEDINGS{padioleau05,
   AUTHOR       = {Yoann Padioleau and Olivier Ridoux},
   BOOKTITLE    = {USENIX Annual Technical Conference, General Track (Short Paper)},
   TITLE        = {A Parts-of-File File System},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.usenix.org/events/usenix05/tech/general/padioleau.html},
   ABSTRACT     = { The Parts-of-file File System (PofFS) allows read-write 
      accesses to different views of a given file or set of files in order 
      to help the user separate and manipulate different concerns. The set 
      of files is considered as a mount point from which views can be 
      selected as read-write files via directories. Paths are formulas 
      mentioning properties of a desired view. Each directory contain a 
      file (the view) which contains the parts of the mounted files that 
      satisfy the properties. This service is offered generically at the 
      file system level, and a plug-in interface permits that file formats, 
      or application-specific details are handled by user-defined 
      operators. Special plug-ins called transducers can be defined for 
      automatically attaching properties to parts of files. Performances 
      are encouraging; files of 100 000 lines are handled efficiently.}
}

@INPROCEEDINGS{lisfs-bda05,
   AUTHOR       = {Yoann Padioleau and Benjamin Sigonneau and 
      Olivier Ridoux and Sébastien Ferré},
   BOOKTITLE    = {Bases de données avancées},
   TITLE        = {LISFS: a Logical Information System as a File System},
   YEAR         = {2005},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Véronique Benzaken},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {393--398},
   PUBLISHER    = {Université de Rennes 1},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://bda05.irisa.fr/},
   PDF          = {http://www.irisa.fr/lande/sigonneau/publications/articles/bda2005.pdf},
   ABSTRACT     = {We present Logical Information Systems (LIS). A LIS can 
      be viewed as a schema-less database whose objects are described by 
      logical formulas. Objects are automatically organized according to 
      their logical description, and logical formulas can be used for 
      representing both queries and navigation links. The key feature of a 
      LIS is that it answers a query with a set of navigation links 
      expressed in the same logic as the query. As navigation links are 
      dynamically computed from any query, and can be used as query 
      increments, it follows that querying and navigation steps can be 
      combined in any order. We then present LISFS, a file-system 
      implementation of a LIS, where objects are files or parts of files. 
      This has the benefit to make LIS features available right now to 
      existing applications. This implementation can easily be extended and 
      specialized through a plug-in mechanism. Finally, we present some 
      applications in the field of personal databases (e.g., music, images, 
      emails), and demonstrate that building specialized interfaces for 
      visualizing databases can be done easily through LISFS navigation. }
}

@TECHREPORT{denmat05c,
   AUTHOR       = {T. Denmat and M. Ducassé and O. Ridoux},
   INSTITUTION  = {INRIA},
   TITLE        = {Data Mining and Cross-checking of Execution Traces. A 
      re-interpretation of Jones, Harrold and Stasko test information 
      visualization (Long version)},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {August},
   NOTE         = {Also Publication Interne IRISA PI-1743},
   NUMBER       = {RR-5661},
   TYPE         = {Research Report},
   URL          = {http://www.inria.fr/rrrt/rr-5661.html}
}

@TECHREPORT{langevine05c,
   AUTHOR       = {L. Langevine and M. Ducassé},
   INSTITUTION  = {INRIA},
   TITLE        = {A Tracer Driver to Enable Concurrent Dynamic Analyses},
   YEAR         = {2005},
   OPTADDRESS   = {},
   MONTH        = {June},
   OPTNOTE      = {},
   NUMBER       = {RR-5611},
   TYPE         = {Research Report},
   URL          = {http://www.inria.fr/rrrt/rr-5611.html}
}

@PROCEEDINGS{ducasse04b,
   TITLE        = {Proceedings of the First International Workshop on 
      Teaching Logic Programming: TeachLP},
   YEAR         = {2004},
   ADDRESS      = {http://www.ep.liu.se/ecp/012/},
   EDITOR       = {M. Ducassé and U. Nilsson and D. Seipel},
   MONTH        = {September},
   NOTE         = {ISSN 1650-3686 (print), 1650-3740 (www)},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Linköping Electronic Conference Proceedings, Issue No. 12},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INCOLLECTION{langevine04,
   AUTHOR       = {L. Langevine and P. Deransart and M. Ducassé},
   BOOKTITLE    = {Recent advances in Constraint Programming},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Artificial Intelligence 3010},
   TITLE        = {A Generic Trace Schema for the Portability of CP(FD) 
      Debugging Tools},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCHAPTER   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   EDITOR       = {J. Vancza and K. Apt and F. Fages and F. Rossi and 
      P. Szeredi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   PAGES        = {171--195},
   OPTSERIES    = {},
   OPTTYPE      = {},
   OPTVOLUME    = {}
}

@ARTICLE{debar04,
   AUTHOR       = {Hervé Debar and Benjamin Morin and Frédéric Cuppens and 
      Fabien Autrel and Ludovic Mé and Bernard Vivinis and Salem Benferhat and 
      Mireille Ducassé and Rodolphe Ortalo},
   JOURNAL      = {Technique et Science Informatiques},
   TITLE        = {Corrélation d'alertes en détection d'intrusions},
   YEAR         = {2004},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {3},
   PAGES        = {323--358},
   VOLUME       = {23}
}

@ARTICLE{FerRid2004,
   AUTHOR       = {S. Ferré and O. Ridoux},
   JOURNAL      = {Information Processing & Management},
   TITLE        = {An Introduction to Logical Information Systems},
   YEAR         = {2004},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {3},
   PAGES        = {383--419},
   VOLUME       = {40},
   KEYWORDS     = {information systems, information search, retrieval, 
      query formulation, representation languages, deduction, 
      theorem proving},
   ABSTRACT     = {Logical information systems (LIS) use logic in a uniform 
      way to describe their contents, to query it, to navigate through it, 
      to analyze it, and to maintain it. They can be given an abstract 
      specification that does not depend on the choice of a particular 
      logic, and concrete instances can be obtained by instantiating this 
      specification with a particular logic. In fact, a logic plays in a 
      LIS the role of a schema in databases. We present the principles of 
      LIS, the constraints they impose on the expression of logics, and 
      hints for their effective implementation.}
}

@ARTICLE{VRA-RIA2004,
   AUTHOR       = {Jeanne Villaneau and Olivier Ridoux and 
      Jean-Yves Antoine},
   JOURNAL      = {RIA --- Revue d'Intelligence Artificielle, (à paraître)},
   TITLE        = {LOGUS : un système formel de compréhension de l'oral 
      spontané},
   YEAR         = {2004},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Foret04b,
   AUTHOR       = {D. Bechet and A. Dikovsky and A. Foret and E. Moreau},
   BOOKTITLE    = {Proceedings of the Formal Grammar Conference (FG 2004)},
   TITLE        = {On learning discontinuous dependencies from positive 
      data},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Foret04a,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Proceedings of the CG 2004 Conference : Categorial Grammars An efficient tool for Natural Language Processing},
   TITLE        = {On Intermediate Structures for Non-Associative Lambek 
      Grammars and Learnability},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Foret04c,
   AUTHOR       = {D. Bechet and A. Foret and I. Tellier},
   BOOKTITLE    = {Proceedings of the International Conference of grammatical Inference (ICGI 2004), LNAI 3264},
   TITLE        = {Learnability of Pregroup Grammars},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{FerKin2004a,
   AUTHOR       = {S. Ferré and R. D. King},
   BOOKTITLE    = {Int. Conf. Formal Concept Analysis},
   TITLE        = {BLID: an Application of Logical Information Systems to 
      Bioinformatics},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {P. Eklund},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {47--54},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 2961},
   OPTVOLUME    = {},
   KEYWORDS     = {logical concept analysis, information system, 
      bioinformatics},
   ABSTRACT     = {BLID (Bio-Logical Intelligent Database) is a 
      bioinformatic system designed to help biologists extract new 
      knowledge from raw genome data by providing high-level facilities for 
      both data browsing and analysis. We describe BLIDrsquos novel data 
      browsing system which is based on the idea of Logical Information 
      Systems. This enables combined querying and navigation of data in 
      BLID (extracted from public bioinformatic repositories). The browsing 
      language is a logic especially designed for bioinformatics. It 
      currently includes sequence motifs, taxonomies, and macromolecule 
      structures, and it is designed to be easily extensible, as it is 
      composed of reusable components. Navigation is tightly combined with 
      this logic, and assists users in browsing a genome through a form of 
      human-computer dialog.}
}

@INPROCEEDINGS{langevine04c,
   AUTHOR       = {L. Langevine and M. Ducassé},
   BOOKTITLE    = {Proceedings of the International Conference on Logic Programming},
   TITLE        = {A tracer driver to enable debugging, monitoring and 
      visualization of CLP executions from a single tracer},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {B. Demoen and V. Lifschtitz},
   MONTH        = {September},
   NOTE         = {Poster},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {462-463},
   PUBLISHER    = {Lecture Notes in Computer Science 3132, Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{langevine04b,
   AUTHOR       = {L. Langevine and M. Ducassé},
   BOOKTITLE    = {Actes des Journées Francophones de Programmation en Logique avec Contraintes},
   TITLE        = {Un pilote de traceur pour la PLC. Déboguer, auditer et 
      visualiser une exécution avec un même traceur},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {F. Mesnard},
   MONTH        = {Juin},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {19-36},
   PUBLISHER    = {HERMES Science Publications},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{RS-AFADL2004,
   AUTHOR       = {Benjamin Sigonneau and Olivier Ridoux},
   BOOKTITLE    = {AFADL --- Approches Formelles dans l'Assistance au Développement de Logiciels},
   TITLE        = {Indexation multiple et automatisée de composants 
      logiciels orientés objet},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{tombini04,
   AUTHOR       = {E. Tombini and H. Debar and L. Mé and M. Ducassé},
   BOOKTITLE    = {Proceedings of the Annual Computer Security Applications Conference},
   TITLE        = {A serial combination of anomaly and misuse IDSes applied 
      to HTTP traffic},
   YEAR         = {2004},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {D. Thomsen and C. Schuba},
   MONTH        = {December},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@TECHREPORT{ducasse04,
   AUTHOR       = {M. Ducassé and B. Sigonneau},
   INSTITUTION  = {INRIA},
   TITLE        = {Building efficient tools to query execution traces},
   YEAR         = {2004},
   OPTADDRESS   = {},
   MONTH        = {July},
   NOTE         = {Also Publication Interne IRISA 1638},
   NUMBER       = {RR-5280},
   TYPE         = {Rapport de Recherche}
}

@TECHREPORT{dico-sp4-04,
   AUTHOR       = {J.-P. Pouzol and S. Benferhat and H. Debar and 
      M. Ducassé and E. Fayol and S. Gombault and J. Goubault-Larrecq and 
      Y. Lavictoire and L. Mé and L. Noé and J. Olivain and E. Totel and 
      B. Vivinis},
   INSTITUTION  = {},
   TITLE        = {Rapport de synthèse sur la création de sondes de 
      détection d'intrusions},
   YEAR         = {2004},
   OPTADDRESS   = {},
   MONTH        = {Juillet},
   NOTE         = {121 pages},
   OPTNUMBER    = {},
   TYPE         = {Livrable du projet RNTL DICO}
}

@PROCEEDINGS{ducasse03,
   TITLE        = {Actes des Journées Francophones de Programmation en 
      Logique avec Contraintes},
   YEAR         = {2003},
   OPTADDRESS   = {},
   EDITOR       = {M. Ducassé},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Revue des Sciences et Technologies de l'Information, Hors série/JFPLC 2003, HERMES Science Publications},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Bechet03g,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Actes de la Conférence d'APprentissage 2003 (CAP'2003)},
   TITLE        = {Apprentissage des grammaires de Lambek rigides et 
      d'arité bornée pour le traitement automatique des langues},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Bechet03e,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Actes de la conférence Traitement Automatique des Langues Naturelles (TALN'2003)},
   TITLE        = {Remarques et perspectives sur les langages de prégroupe 
      d'ordre 1/2},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = { ATALA},
   MONTH        = {June},
   NOTE         = {(Poster)},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Bechet03f,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Proceedings of the 10th Workshop on Logic, Language, Information and Computation (WoLLIC'2003), volume 85, Electronic Notes in Theoretical Computer Science},
   TITLE        = {k-Valued Non-Associative Lambek Grammars are Learnable 
      from Function-Argument Structures},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Bechet03d,
   AUTHOR       = {Denis Bechet and Annie Foret},
   BOOKTITLE    = {Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics (ACL 2003)},
   TITLE        = {k-valued Non-Associative Lambek Categorial Grammars are 
      not Learnable from Strings},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = { ACL},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{deransart03,
   AUTHOR       = {P. Deransart and L. Langevine and M. Ducassé},
   BOOKTITLE    = {Proceedings of the ERCIM workshop on Constraint and Logic Programming},
   TITLE        = {A Generic Trace Schema for the Portability of CP(FD) 
      Debugging Tools},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{ducasse03b,
   AUTHOR       = {M. Ducassé and L. Langevine and P. Deransart},
   BOOKTITLE    = {Proceedings of the Fifth International Workshop on Automated Debugging},
   TITLE        = {Rigorous design of tracers: an experiment for constraint 
      logic programming},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Ronsse},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {CoRR cs.SE/0309027},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{Fer2003,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Using Conceptual Structures -- Contributions to ICCS 2003},
   TITLE        = {The Use of Associative Concepts for Fast Incremental 
      Concept Formation in Sparse Contexts},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {B. Ganter and de Moor, A.},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Shaker Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, associative concept, lattice, 
      algorithm, sparse context},
   PDF          = {http://www.irisa.fr/LIS/ferre/papers/iccs2003.pdf}
}

@INPROCEEDINGS{For03u,
   AUTHOR       = {Annie Foret},
   BOOKTITLE    = {Proceedings of the 17th International Workshop on Unification Valencia, Spain, June 8-9, (UNIF'03)},
   TITLE        = {On the Computation of Joins for Non Associative Lambek 
      Categorial Grammars.},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{langevine03,
   AUTHOR       = {L. Langevine and M. Ducassé and P. Deransart},
   BOOKTITLE    = {Proceedings of the 19th Int. Conf. in Logic Programming},
   TITLE        = {A Propagation Tracer for Gnu-Prolog: from Formal 
      Definition to Efficient Implementation},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {C. Palamidessi},
   MONTH        = {December},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{yp-or-usenix2003,
   AUTHOR       = {Yoann Padioleau and Olivier Ridoux},
   BOOKTITLE    = {Proc. USENIX Annual Technical Conference},
   TITLE        = {A Logic File System},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{yp-or-cfse2003,
   AUTHOR       = {Yoann Padioleau and Olivier Ridoux},
   BOOKTITLE    = {Proc. Conférence Française sur les Systèmes d'exploitation},
   TITLE        = {Présentation du «Parts-of-file File System»},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{or-iclp2003,
   AUTHOR       = {Olivier Ridoux},
   BOOKTITLE    = {Proc. Int. Conf. Logic Programming},
   TITLE        = {Logic Information Systems for Logic Programmers},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {C. Palamidessi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, LNCS},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@TECHREPORT{dico-sp3-03,
   AUTHOR       = {Jean Goubault-Larrecq and Stéphane Demri and 
      Mireille Ducassé and Ludovic Mé and Julien Olivain and 
      Claudine Picaronny and Jean-Philippe Pouzol and Eric Totel and 
      Bernard Vivinis},
   INSTITUTION  = {Projet RNTL DICO},
   TITLE        = {Algorithmes de détection et langages de signatures},
   YEAR         = {2003},
   ADDRESS      = {http://dico.netsecuresoftware.com//index.htm},
   MONTH        = {Octobre},
   OPTNOTE      = {},
   NUMBER       = {3.3},
   TYPE         = {Livrable}
}

@TECHREPORT{yp-or-lisfs-inria2003,
   AUTHOR       = {Y. Padioleau and O. Ridoux},
   INSTITUTION  = {INRIA},
   TITLE        = {A Logic File System},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {4656},
   TYPE         = {Research Report},
   KEYWORDS     = {file system, information retrieval, applied logic},
   URL          = {http://www.inria.fr/rrrt/rr-4656.html},
   ABSTRACT     = {We present the new paradigm of logic file systems, its 
      implementation, and first experimental results. It offers in an 
      integrated way navigation and classification, the possibility of 
      expressive queries, ease of use, and possible heterogeneity of data. 
      This paradigm is object-centered. It associates logical descriptions 
      to objects, and logical relations between descriptions serve as a 
      basis for navigation and querying. We compare logic file systems with 
      the hierarchical, boolean, and data-base paradigms. We present 
      briefly the rôle of logic in logic file systems, and in more details 
      the implementation issues of a particular logic file system that uses 
      a simple logic.}
}

@TECHREPORT{yp-or-poffs-inria2003,
   AUTHOR       = {Y. Padioleau and O. Ridoux},
   INSTITUTION  = {INRIA},
   TITLE        = {The Parts-of-file File System},
   YEAR         = {2003},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {4783},
   TYPE         = {Rapport de recherche}
}

@MISC{deransart03b,
   AUTHOR       = {P. Deransart and L. Langevine and M. Ducassé},
   HOWPUBLISHED = {Demonstration presented at the 13th Workshop on Logic Programming Environments},
   MONTH        = {December},
   OPTNOTE      = {},
   TITLE        = {Debugging Constraint problems with Portable Tools},
   YEAR         = {2003}
}

@PROCEEDINGS{ducasse02,
   TITLE        = {Journal of Automated Software Engineering 9(1), special 
      issue on automated debugging},
   YEAR         = {2002},
   OPTADDRESS   = {},
   EDITOR       = {M. Ducassé},
   MONTH        = {janvier},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {Kluwer},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@PHDTHESIS{Fer2002a,
   AUTHOR       = {S. Ferré},
   SCHOOL       = {Université de Rennes 1},
   TITLE        = {Systèmes d'information logiques : un paradigme 
      logico-contextuel pour interroger, naviguer et apprendre},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {October},
   NOTE         = {Accessible en ligne à l'adresse http://www.irisa.fr/bibli/publi/theses/theses02.html.},
   TYPE         = {Thèse d'université},
   KEYWORDS     = {système d'information, treillis (théorie des), 
      analyse de concepts, logique, recherche de l'information, 
      navigateurs (logiciels), apprentissage automatique},
   URL          = {http://www.irisa.fr/bibli/publi/theses/theses02.html},
   ABSTRACT     = {Les deux principaux paradigmes de recherche 
      d'information, la navigation et l'interrogation, sont souvent 
      dissociés. Les systèmes hiérarchiques offrent une structure de 
      navigation figée qui ne convient pas à toutes les utilisations ; ce 
      qu'ils compensent par des outils de recherche. Ceux-ci, fondés sur 
      l'interrogation, sont plus souples mais sont plus difficiles à 
      utiliser pour les non-initiés et rendent délicat le contrôle du 
      volume des réponses. Il apparaît donc comme nécessaire de combiner 
      étroitement navigation et interrogation. Pour réaliser cette 
      combinaison, nous nous fondons sur l'Analyse de concepts (AC) qui 
      permet de construire automatiquement, à partir d'une description des 
      objets, une structure de navigation appelée «treillis de concepts», 
      où les concepts jouent à la fois le rôle de répertoire et de requête. 
      Comme dans l'AC les descriptions se limitent à des ensembles 
      d'attributs, nous avons généralisé l'AC pour les remplacer par des 
      formules d'une logique arbitraire. Ceci nous semble important pour 
      traiter des applications diverses. Les Systèmes d'information 
      logiques (SIL) se définissent donc par la combinaison 
      navigation/interrogation, l'emploi de la logique (descriptions, 
      requêtes et liens de navigation) et la généricité. Sur cette base, 
      nous avons développé plusieurs mécanismes pour faciliter l'expression 
      et la découverte de connaissances. Les connaissances d'un domaine 
      peut être exprimées par une terminologie. Un dialogue homme-machine, 
      fondé sur le treillis de concepts, permet de retrouver des objets 
      (navigation) et de découvrir des régularités entre les objets 
      (extraction de connaissances). Un mécanisme d'apprentissage offre une 
      assistance à la classification des objets. Enfin, un prototype a été 
      développé pour d'expérimenter ces mécanismes. Il est générique dans 
      le sens où il ne dépend pas de la logique employée. Ces logiques 
      peuvent être assemblés à l'aide d'un jeu de composants logique, que 
      nous avons constitué.}
}

@ARTICLE{jahier02,
   AUTHOR       = {E. Jahier and M. Ducassé},
   JOURNAL      = {Theory and Practice of Logic Programming},
   TITLE        = {Generic Program Monitoring by Trace Analysis},
   YEAR         = {2002},
   MONTH        = {September},
   OPTNOTE      = {},
   NUMBER       = {4-5},
   OPTPAGES     = {},
   VOLUME       = {2}
}

@INPROCEEDINGS{BarFerRid2002,
   AUTHOR       = {S. Bars and S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Workshop on Isomorphisms of Types},
   TITLE        = {Logic Functors for Types as Search Keys},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.irit.fr/zeno/WIT2002/}
}

@INPROCEEDINGS{deransart02,
   AUTHOR       = {P. Deransart and L. Langevine and M. Ducassé},
   BOOKTITLE    = {Proc. of the International Workshop on User-Interaction in Constraint Satisfaction},
   TITLE        = {A Generic Trace Model for Finite Domain Solvers},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {B. O'Sullivan},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Cornell University},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{ducasse02c,
   AUTHOR       = {M. Ducassé and L. Langevine},
   BOOKTITLE    = {Actes des Journées Francophones de Programmation en Logique avec Contraintes},
   TITLE        = {Analyse automatisée de traces d'exécution de programmes 
      CLP(FD)},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Rueher},
   MONTH        = {Mai},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {119-134},
   PUBLISHER    = {HERMES science publications},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{ducasse02d,
   AUTHOR       = {M. Ducassé and L. Langevine},
   BOOKTITLE    = {Proceedings of the International Conference on Logic Programming},
   TITLE        = {Automated analysis of CLP(FD) program execution traces},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {P. Stuckey},
   MONTH        = {July},
   NOTE         = {Poster. Extended version available at http://www.irisa.fr/LIS/ducasse/},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Lecture Notes in Computer Science 2401, Springer-Verlag},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{FerRid2002,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Conf. Conceptual Structures},
   TITLE        = {The Use of Associative Concepts in the Incremental 
      Building of a Logical Context},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {U. Priss, D. Corbett, G. Angelova},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {299--313},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 2393},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, logic, information systems, learning, 
      classification, context},
   ABSTRACT     = {A formal context associates to objects a description 
      that combines automatically extracted properties (intrinsic) and 
      manually assigned ones (extrinsic). The extrinsic properties are 
      expressed by users according to intentions that are often subjective 
      and changing, and determine the classification and retrieval of 
      objects. So, we find it important to assist users in this task 
      through the automatic suggestion of extrinsic properties to be 
      assigned and even the discovery of rules to automate these 
      assignements. The principle is to learn from the description of 
      existing objects the extrinsic description of a new object. Because 
      of the changing nature of users' intentions, the assistance given in 
      the incremental building of a logical context must be interactive. We 
      present formal principles, and an application to the classification 
      of email messages. }
}

@INPROCEEDINGS{For02b,
   AUTHOR       = {Annie Foret and Le Nir, Yannick},
   BOOKTITLE    = {COLING'2002, 19th International Conference on Computational Linguistics},
   TITLE        = {Lambek rigid grammars are not learnable from strings},
   YEAR         = {2002},
   ADDRESS      = {Taipei, Taiwan},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{For02a,
   AUTHOR       = {Annie Foret and Le Nir, Yannick},
   BOOKTITLE    = {CAp'2002, Conférence Francophone d'Apprentissage},
   TITLE        = {Les grammaires de Lambek rigides ne sont pas apprenables 
      à partir des chaines},
   YEAR         = {2002},
   ADDRESS      = {Orléans, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Presses Universitaires de Grenoble},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{For02c,
   AUTHOR       = {Annie Foret and Le Nir, Yannick},
   BOOKTITLE    = {ICGI'2002, the 6th International Colloquium on Grammatical Inference},
   TITLE        = {On limit points for some variants of rigid Lambek 
      Grammars},
   YEAR         = {2002},
   ADDRESS      = {Amsterdam, the Netherlands},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {2484},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {Lecture Notes in Artificial Intelligence},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{langevine02,
   AUTHOR       = {L. Langevine and P. Deransart and M. Ducassé and 
      E. Jahier},
   BOOKTITLE    = {Actes des Journées Francophones de Programmation en Logique avec Contraintes},
   TITLE        = {Prototypage de traceurs CLP(FD)},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Rueher},
   MONTH        = {Mai},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {135-150},
   PUBLISHER    = {HERMES science publications},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{morin02,
   AUTHOR       = {B. Morin and L. Mé and H. Debar and M. Ducassé},
   BOOKTITLE    = {Recent Advances in Intrusion Detection},
   TITLE        = {M2D2 : A Formal Data Model for IDS Alert Correlation},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {et al., A. Wespi},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {97-104},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science 2516},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{pouzol02,
   AUTHOR       = {Jean-Philippe Pouzol and Mireille Ducassé},
   BOOKTITLE    = {Proc. of 15th IEEE Computer Security Foudations Workshop},
   TITLE        = {Formal specification of intrusion signatures and 
      detection rules},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {S. Schneider},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {64--76},
   PUBLISHER    = {IEEE Press},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{var-taln2002,
   AUTHOR       = {J. Villaneau and J.-Y. Antoine and O. Ridoux},
   BOOKTITLE    = {TALN'02: Traitement Automatique de la Langue Naturelle},
   TITLE        = {LOGUS : un système formel de compréhension du français 
      parlé spontané - présentation et évaluation},
   YEAR         = {2002},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@TECHREPORT{Fer2002,
   AUTHOR       = {S. Ferré},
   INSTITUTION  = {Inria, Institut National de Recherche en Informatique et en Automatique},
   TITLE        = {Incremental Concept Formation made More Efficient by the 
      Use of Associative Concepts},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {October},
   OPTNOTE      = {},
   NUMBER       = {RR-4569},
   TYPE         = {Research Report},
   KEYWORDS     = {context, concept lattice, Galois lattice, 
      incremental algorithm, complexity},
   PAGES        = {13 p.},
   URL          = {http://www.inria.fr/rrrt/rr-4569.html},
   ABSTRACT     = {Formal Concept Analysis (FCA) is interested in the 
      formation of concept lattices from binary relations between objects 
      and attributes, a.k.a. contexts. Many algorithms have been proposed 
      to generate the set of all concepts, and also the edges of the 
      lattice between these concepts. We develop the principle and the code 
      of a new algorithm combining two existing ones, Godin's and Bordat's 
      algorithms. Then, we show by both a theoretical and practical study 
      that it is the most efficient algorithm for sparse contexts, which 
      are usually found in real applications.}
}

@TECHREPORT{FerRid2002a,
   AUTHOR       = {S. Ferré and O. Ridoux},
   INSTITUTION  = {Inria, Institut National de Recherche en Informatique et en Automatique},
   TITLE        = {Introduction to Logical Information Systems},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {September},
   OPTNOTE      = {},
   NUMBER       = {RR-4540},
   TYPE         = {Research Report},
   KEYWORDS     = {information system, information search and retrieval, 
      query formulation, representation languages, 
      deduction and theorem proving},
   PAGES        = {25 p.},
   URL          = {http://www.inria.fr/rrrt/rr-4540.html},
   ABSTRACT     = {Logical Information Systems (LIS) use logic in a uniform 
      way to describe their contents, to query it, to navigate through it, 
      to analyze it, and to maintain it. They can be given an abstract 
      specification that does not depend on the choice of a particular 
      logic, and concrete instances can be obtained by instantiating this 
      specification with a particular logic. In fact, a logic plays in a 
      LIS the role of a schema in data-bases. We present the principles of 
      logical information systems, the constraints they impose on the 
      expression of logics, and hints for their effective implementation.}
}

@TECHREPORT{FerRid2002b,
   AUTHOR       = {S. Ferré and O. Ridoux},
   INSTITUTION  = {Inria, Institut National de Recherche en Informatique et en Automatique},
   TITLE        = {Logic Functors : a Framework for Developing Embeddable 
      Customized Logics},
   YEAR         = {2002},
   OPTADDRESS   = {},
   MONTH        = {May},
   OPTNOTE      = {},
   NUMBER       = {RR-4457},
   OPTTYPE      = {},
   KEYWORDS     = {applied logic, software component},
   PAGES        = {32 p.},
   URL          = {http://www.inria.fr/rrrt/rr-4457.html},
   ABSTRACT     = {Logic-based applications often use customized logics 
      which are composed of several logics. These customized logics are 
      also often embedded as a black-box in an application. So, 
      implementing them requires the specification of a well-defined 
      interface with common operations such as a parser, a printer, and a 
      theorem prover. In order to be able to compose these logic, one must 
      also define composition laws, and prove their properties. We present 
      the principles of logic functors and their compositions for 
      constructing logics that are ad-hoc, but sound. An important issue is 
      how the operations of different sublogics inter-operate. We propose a 
      formalization of the logic functors, their semantics, 
      implementations, proof-theoretic properties, and their composition. }
}

@ARTICLE{ducasse01,
   AUTHOR       = {M. Ducassé and E. Jahier},
   JOURNAL      = {Electronic Notes in Theoretical Computer Science},
   TITLE        = {Efficient Automated Trace Analysis: Examples with 
      Morphine},
   YEAR         = {2001},
   OPTMONTH     = {},
   NOTE         = {K. Havelund and G. Rosu (Eds), proceedings of the first Workshop on Runtime Verification},
   NUMBER       = {2},
   OPTPAGES     = {},
   VOLUME       = {55}
}

@ARTICLE{rb-jflp2001,
   AUTHOR       = {Olivier Ridoux and Patrice Boizumault},
   JOURNAL      = {Journal of Functional and Logic Programming},
   TITLE        = {Typed Static Analysis: Application to the Groundness 
      Analysis of Typed Prolog},
   YEAR         = {2001},
   MONTH        = {July},
   OPTNOTE      = {},
   NUMBER       = {4},
   OPTPAGES     = {},
   VOLUME       = {2001},
   PUBLISHER    = {EAPLS}
}

@INPROCEEDINGS{Fer2001,
   AUTHOR       = {S. Ferré},
   BOOKTITLE    = {Symbolic and Quantitative Approaches to Reasoning with Uncertainty},
   TITLE        = {Complete and Incomplete Knowledge in Logical Information 
      Systems},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Salem Benferhat and Philippe Besnard},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {782--791},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 2143},
   OPTVOLUME    = {},
   KEYWORDS     = {modal logic, All I know, 
      complete and incomplete knowledge, information system},
   ABSTRACT     = {We present a generalization of logic All I Know by 
      presenting it as an extension of standard modal logics. We study how 
      this logic can be used to represent complete and incomplete knowledge 
      in Logical Information Systems. In these information systems, a 
      knowledge base is a collection of objects (e.g., files, 
      bibliographical items) described in the same logic as used for 
      expressing queries. We show that usual All I Know (transitive and 
      euclidean accessibility relation) is convenient for representing 
      complete knowledge, but not for incomplete knowledge. For this, we 
      use \emph{serial} All I Know (serial accessibility relation).}
}

@INPROCEEDINGS{FerRid2001b,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {Int. Work. Logic-based Program Synthesis and Transformation},
   TITLE        = {A Framework for Developing Embeddable Customized Logics},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. Pettorossi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {191--215},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 2372},
   OPTVOLUME    = {},
   KEYWORDS     = {logic, composition, theorem prover, logic-based systems},
   URL          = {ftp://ftp.irisa.fr/local/lande/sf-or-lopstr01.ps.gz},
   ABSTRACT     = {Logic-based applications often use customized logics 
      which are composed of several logics. These customized logics are 
      also often embedded as a black-box in an application. Their 
      implementation requires the specification of a well-defined interface 
      with common operations such as a parser, a printer, and a theorem 
      prover. In order to be able to compose these logics, one must also 
      define composition laws, and prove their properties. We present the 
      principles of logic functors and their compositions for constructing 
      customized logics. An important issue is how the operations of 
      different sublogics inter-operate. We propose a formalization of the 
      logic functors, their semantics, implementations, and their 
      composition.}
}

@INPROCEEDINGS{FerRid2001,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {International Conference on Conceptual Structures},
   TITLE        = {Searching for Objects and Properties with Logical 
      Concept Analysis},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Harry S. Delugach and Gerd Stumme},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {187--201},
   PUBLISHER    = {Springer},
   SERIES       = {LNCS 2120},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, navigation, knowledge discovery, 
      logical information system},
   ABSTRACT     = {Logical Concept Analysis is Formal Concept Analysis 
      where logical formulas replace sets of attributes. We define a 
      Logical Information System that combines navigation and querying for 
      searching for objects. Places and queries are unified as formal 
      concepts represented by logical formulas. Answers can be both 
      extensional (objects belonging to a concept) and intensional 
      (formulas refining a concept). Thus, all facets of navigation are 
      formalized in terms of Logical Concept Analysis. We show that the 
      definition of being a refinement of some concept is a specific case 
      of Knowledge Discovery in a formal context. It can be generalized to 
      recover more classical KD~operations like machine-learning through 
      the computation of necessary or sufficient properties (modulo some 
      confidence), or data-mining through association rules.}
}

@INPROCEEDINGS{For01a,
   AUTHOR       = {Annie Foret},
   BOOKTITLE    = {New Perspectives in Logic and Formal Linguisitics, Proceedings Vth ROMA Workshop},
   TITLE        = {Conjoinability and unification in Lambek categorial 
      grammars},
   YEAR         = {2001},
   ADDRESS      = {Roma},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Bulzoni Editore},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{For01b,
   AUTHOR       = {Annie Foret},
   BOOKTITLE    = {LACL'01, 4th International Conference on Logical Aspects of Computational Linguistics},
   TITLE        = {Mixing deduction and substitution in Lambek categorial 
      grammars, some investigations},
   YEAR         = {2001},
   ADDRESS      = {Le Croisic, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {2099},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {Lecture Notes in Artificial Intelligence},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{For01c,
   AUTHOR       = {Annie Foret},
   BOOKTITLE    = {FGMOL'01, the sixth conference on Formal Grammar and the seventh on the Mathematics of Language},
   TITLE        = {The emptiness of intersection problem for k-valued 
      categorial grammars (classical and Lambek) is undecidable},
   YEAR         = {2001},
   ADDRESS      = {Helsinki, Finland},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{jahier01b,
   AUTHOR       = {E. Jahier and M. Ducassé and O. Ridoux},
   BOOKTITLE    = {Logic Based Program Synthesis and Transformation},
   TITLE        = {Specifying Prolog Trace Models with a Continuation 
      Semantics},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {K.-K. Lau},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science 2042},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{langevine01,
   AUTHOR       = {L. Langevine and P. Deransart and M. Ducassé and 
      E. Jahier},
   BOOKTITLE    = {Proceedings of the 11th Workshop on Logic Programming Environments},
   TITLE        = {Prototyping clp(fd) tracers: a trace model and an 
      experimental validation environment},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {T. Kusalik},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Computer Research Repository, CS.PL/0111043},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{pouzol01,
   AUTHOR       = {J.-P. Pouzol and M. Ducassé},
   BOOKTITLE    = {Recent Advances in Intrusion Detection, Proceedings of the 4th International Symposium},
   TITLE        = {From Declarative Signatures to Misuse IDS},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {W. Lee and L. Mé and A. Wespi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {1-21},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science 2212},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{var-lacl2001,
   AUTHOR       = {J. Villaneau and J.-Y. Antoine and O. Ridoux},
   BOOKTITLE    = {4th Int. Conf. Logical Aspects of Computational Linguistics},
   TITLE        = {Combining Syntax and Pragmatic Knowledge for the 
      Understanding of Spontaneous Spoken Sentences},
   YEAR         = {2001},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {de Groote, Ph. and G. Morill and Ch. Retoré},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@TECHREPORT{ducasse01b,
   AUTHOR       = {M. Ducassé and L. Rozé},
   INSTITUTION  = {IRISA},
   TITLE        = {Revisiting the ``Traffic lights'' B case study},
   YEAR         = {2001},
   OPTADDRESS   = {},
   MONTH        = {November},
   OPTNOTE      = {},
   NUMBER       = {1424},
   TYPE         = {Publication Interne}
}

@PROCEEDINGS{ducasse2000c,
   TITLE        = {Proceedings of the 4th International Workshop on 
      Automated Debugging (AADEBUG2000)},
   YEAR         = {2000},
   ADDRESS      = {Munich},
   EDITOR       = {M. Ducassé},
   MONTH        = {August},
   NOTE         = {Refereed proceedings to appear in the COmputer Research Repository (CORR)},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {COrr},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.irisa.fr/lande/ducasse/aadebug2000/proceedings.html}
}

@ARTICLE{ducasse2000,
   AUTHOR       = {M. Ducassé and J. Noyé},
   JOURNAL      = {Elsevier Journal of Logic Programming,},
   TITLE        = {Tracing Prolog programs by source instrumentation is 
      efficient enough},
   YEAR         = {2000},
   MONTH        = {May},
   OPTNOTE      = {},
   NUMBER       = {2},
   PAGES        = {157-172},
   VOLUME       = {43},
   KEYWORDS     = {Debugging, tracing, source to source transformation, 
      benchmarking, Prolog.},
   URL          = {http://www.irisa.fr/lande/ducasse/ducasse-noye-manchester-98.ps.gz},
   ABSTRACT     = {Tracing by automatic program source instrumentation has 
      major advantages over compiled code instrumentation: it is more 
      portable, it benefits from many compiler optimizations, it produces 
      traces in terms of the original program, and it can be tailored to 
      specific debugging needs. The usual argument in favor of compiled 
      code instrumentation is its supposed efficiency. We have compared the 
      performance of two operational low-level Prolog tracers with source 
      instrumentation. We have executed classical Prolog benchmark 
      programs, collecting trace information without displaying it. On 
      average, collecting trace information by program instrumentation is 
      about as fast as using a low-level tracer in one case, and only twice 
      slower in the other. This is a minor penalty to pay, compared to the 
      advantages of the approach. To our knowledge, this is the first time 
      that a quantitative comparison of both approaches is made for any 
      programming language. }
}

@INPROCEEDINGS{abily2000,
   AUTHOR       = {V. Abily and M. Ducassé},
   BOOKTITLE    = {RAID 2000 (Recent Advances on Intrusion Detection)},
   TITLE        = {Benchmarking a distributed intrusion detection system 
      based on ASAX: Preliminary results},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {H. Debar},
   OPTMONTH     = {},
   NOTE         = {Refereed extended abtract},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.raid-symposium.org/raid2000/program.html}
}

@INPROCEEDINGS{ducasse2000b,
   AUTHOR       = {M. Ducassé and L. Rozé},
   BOOKTITLE    = {LOgic-based Program Synthesis and TRansformation},
   TITLE        = {Proof obligations of the B formal method: Local proofs 
      ensure global consistency},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. Bossi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {11-30},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science, 1817},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{FerRid2000a,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {International Conference on Rules and Objects in Databases},
   TITLE        = {A File System Based on Concept Analysis},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Yehoshua Sagiv},
   MONTH        = {July},
   OPTNOTE      = {},
   NUMBER       = {1861},
   OPTORGANIZATION = {},
   PAGES        = {1033--1047},
   PUBLISHER    = {Springer},
   SERIES       = {Lecture Notes in Computer Science},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, logic, information system, 
      file system},
   ABSTRACT     = {We present the design of a file system whose 
      organization is based on Concept Analysis ``à la Wille-Ganter''. The 
      aim is to combine querying and navigation facilities in one 
      formalism. The file system is supposed to offer a standard interface 
      but the interpretation of common notions like directories is new. The 
      contents of a file system is interpreted as a Formal Context, 
      directories as Formal Concepts, and the sub-directory relation as 
      Formal Concepts inclusion. We present an organization that allows for 
      an efficient implementation of such a Conceptual File System.}
}

@INPROCEEDINGS{FerRid2000b,
   AUTHOR       = {S. Ferré and O. Ridoux},
   BOOKTITLE    = {International Conference on Conceptual Structures},
   TITLE        = {A Logical Generalization of Formal Concept Analysis},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Guy Mineau and Bernhard Ganter},
   MONTH        = {August},
   OPTNOTE      = {},
   NUMBER       = {1867},
   OPTORGANIZATION = {},
   PAGES        = {371--384},
   PUBLISHER    = {Springer},
   SERIES       = {Lecture Notes in Computer Science},
   OPTVOLUME    = {},
   KEYWORDS     = {concept analysis, logic, context, information system},
   ABSTRACT     = {We propose a generalization of Formal Concept Analysis 
      (FCA) in which sets of attributes are replaced by expressions of an 
      almost arbitrary logic. We prove that all FCA can be reconstructed on 
      this basis. We show that from any logic that is used in place of sets 
      of attributes can be derived a contextualized logic that takes into 
      account the formal context and that is isomorphic to the concept 
      lattice. We then justify the generalization of FCA compared with 
      existing extensions and in the perspective of its application to 
      information systems.}
}

@INPROCEEDINGS{jahier00,
   AUTHOR       = {E. Jahier and M. Ducassé and O. Ridoux},
   BOOKTITLE    = {Proc. of LOgic-based Program Synthesis and TRansformation},
   TITLE        = {Specifying Prolog Trace Models with a Continuation 
      Semantics},
   YEAR         = {2000},
   ADDRESS      = {London},
   OPTCROSSREF  = {},
   EDITOR       = {K.-K. Lau},
   MONTH        = {July},
   NOTE         = {Technical Report Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-00-6-1.},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.cs.man.ac.uk/cstechrep/titles00.html}
}

@INPROCEEDINGS{jahier00b,
   AUTHOR       = {E. Jahier and M. Ducassé and O. Ridoux},
   BOOKTITLE    = {Actes des Journées francophones de Programmation Logique et par Contraintes},
   TITLE        = {Spécification de modèles de traces de programmes Prolog 
      à l'aide d'une sémantique par continuation},
   YEAR         = {2000},
   ADDRESS      = {Marseille},
   OPTCROSSREF  = {},
   EDITOR       = { Touraivane},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Hermès},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{LOPSTR99,
   AUTHOR       = {D. Le Métayer and V.-A. Nicolas and O. Ridoux},
   BOOKTITLE    = {LOgic-based Program Synthesis and TRansformation},
   TITLE        = {Verification by testing for recursive program schemes},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. Bossi},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, Lecture Notes in Computer Science, 1817},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{pouzol2000,
   AUTHOR       = {J.-P. Pouzol and M. Ducassé},
   BOOKTITLE    = {RAID 2000 (Recent Advances on Intrusion Detection)},
   TITLE        = {Handling Generic Intrusion Signatures is not Trivial},
   YEAR         = {2000},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {H. Debar},
   OPTMONTH     = {},
   NOTE         = {Refereed extended abtract},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {http://www.raid-symposium.org/raid2000/program.html}
}

@TECHREPORT{FerRid2000c,
   AUTHOR       = {S. Ferré and O. Ridoux},
   INSTITUTION  = {Inria, Institut National de Recherche en Informatique et en Automatique},
   TITLE        = {A File System Based on Concept Analysis},
   YEAR         = {2000},
   OPTADDRESS   = {},
   MONTH        = {avril},
   OPTNOTE      = {},
   NUMBER       = {RR-3942},
   TYPE         = {Technical Report},
   PAGES        = {12 p.},
   URL          = {http://www.inria.fr/rrrt/rr-3942.html}
}

@PROCEEDINGS{ducasse99g,
   TITLE        = {Proceedings of the 10th Workshop on Logic Programming 
      Environments},
   YEAR         = {1999},
   ADDRESS      = {http://www.cs.usask.ca/projects/envlop/WLPE/10WLPE/},
   EDITOR       = {M. Ducassé and A. Kusalik and G. Puebla},
   MONTH        = {novembre},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@PHDTHESIS{smallet99d,
   AUTHOR       = {S. Mallet},
   SCHOOL       = {Insa de Rennes, Irisa},
   TITLE        = {Explications dans les bases de données déductives : 
      Associer trace et sémantique},
   YEAR         = {1999},
   OPTADDRESS   = {},
   MONTH        = {novembre},
   OPTNOTE      = {},
   OPTTYPE      = {}
}

@INCOLLECTION{ducasse99b,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Learning to Build and Comprehend Complex Information Structures: Prolog as a Case Study},
   PUBLISHER    = {Ablex},
   TITLE        = {Abstract views of Prolog executions with Opium},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCHAPTER   = {},
   OPTCROSSREF  = {},
   OPTEDITION   = {},
   EDITOR       = {P. Brna and du Boulay, B. and H. Pain},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   SERIES       = {Cognitive Science and Technology},
   OPTTYPE      = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software engineering, Programming environment, 
      Automated debugging, Trace abstraction mechanisms, 
      Debugging language, Program behavior understanding, 
      Prolog Debugging tool},
   URL          = {http://www.irisa.fr/lande/ducasse/ducasse-ablex99.ps.gz},
   ABSTRACT     = {Opium is a system for analysing and debugging Prolog 
      programs. Its kernel comprises an execution tracer and a programming 
      language with a set of primitives for trace and source analysis. In 
      this chapter we show the power of Opium for supporting abstract views 
      of Prolog executions. Abstract views give high-level points of view 
      about executions. They filter out irrelevant details; they 
      restructure the remaining information; and they compact it so that 
      the amount of information given at each step has a reasonable size. 
      The examples of abstract views given in the following are a goal 
      execution profile, some data abstractions, an instantiation profile, 
      a failure analysis, a loop analysis, and a kind of explanation for an 
      expert system written in Prolog. }
}

@ARTICLE{BEL99,
   AUTHOR       = {C. Belleannée and P. Brisset and O. Ridoux},
   JOURNAL      = {J. Logic Programming},
   TITLE        = {A Pragmatic Reconstruction of $\lambda$Prolog},
   YEAR         = {1999},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {1},
   PAGES        = {67--102},
   VOLUME       = {41}
}

@ARTICLE{ducasse99,
   AUTHOR       = {M. Ducassé},
   JOURNAL      = {The Journal of Logic programming},
   TITLE        = {Opium: An extendable trace analyser for Prolog},
   YEAR         = {1999},
   OPTMONTH     = {},
   NOTE         = {Special issue on Synthesis, Transformation and Analysis of Logic Programs, A. Bossi and Y. Deville (eds), Also Rapport de recherche INRIA RR-3257 and Publication Interne IRISA PI-1127},
   OPTNUMBER    = {},
   OPTPAGES     = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software Engineering, Automated Debugging, 
      Trace Query Language, Program Execution Analysis, 
      Abstract Views of Program Executions, Prolog},
   URL          = {http://www.irisa.fr/lande/ducasse/ducasse-jlp-98.ps.gz},
   ABSTRACT     = {Traces of program executions are a helpful source of 
      information for program debugging. They, however, give a picture of 
      program executions at such a low level that users often have 
      difficulties to interpret the information. Opium, our extendable 
      trace analyzer, is connected to a ``standard'' Prolog tracer. Opium 
      is programmable and extendable. It provides a trace query language 
      and abstract views of executions. Users can therefore examine program 
      executions at the levels of abstraction which suit them. Opium has 
      shown its capabilities to build abstract tracers and automated 
      debugging facilities. This article describes in depth the trace query 
      mechanism, from the model to its implementation. Characteristic 
      examples are detailed. Extensions written so far on top of the trace 
      query mechanism are listed. Two recent extensions are presented: the 
      abstract tracers for the LO (Linear Objects) and the CHR (Constraint 
      Handling Rules) languages. These two extensions were specified and 
      implemented within a few days. They show how to use Opium for real 
      applications. }
}

@INPROCEEDINGS{ducasse99d,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the 9th International Workshop on LOgic-based Program Synthesis and TRansformation},
   TITLE        = {An introduction to the B formal method},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A.-L. Bossi},
   MONTH        = {September},
   NOTE         = {Technical report CS-99-16, Slides},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {23--30},
   PUBLISHER    = {Universita' Ca' Foscari di Venezia},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{ducasse99c,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the 21st International Conference on Software Engineering},
   TITLE        = {Coca: An automated Debugger for C},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {504-513},
   PUBLISHER    = {ACM Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ANNOTE       = {Also RR-3489},
   KEYWORDS     = {Software engineering, Programming environment, 
      Automated debugging, Trace query mechanism, Debugging language, 
      Program behavior understanding, C Debugging tool.},
   URL          = {http://www.irisa.fr/lande/ducasse/coca-irisa-98.ps.gz},
   ABSTRACT     = {We present Coca, an automated debugger for C, where the 
      breakpoint mechanism is based on events related to language 
      constructs. Events have semantics whereas source lines used by most 
      debuggers do not have any. A trace is a sequence of events. It can be 
      seen as an ordered relation in a database. Users can specify 
      precisely which events they want to see by specifying values for 
      event attributes. At each event, visible variables can be queried. 
      The trace query language is Prolog with a handful of primitives. The 
      trace query mechanism searches through the execution traces using 
      both control flow and data whereas debuggers usually search according 
      to either control flow or data. As opposed to fully ``relational'' 
      debuggers which use plain database querying mechanisms, Coca trace 
      querying mechanism does not require any storage. The analysis is done 
      on the fly, synchronously with the traced execution. Coca is 
      therefore more powerful than ``source line'' debuggers and more 
      efficient than relational debuggers. }
}

@INPROCEEDINGS{jahier99d,
   AUTHOR       = {E. Jahier and M. Ducassé},
   BOOKTITLE    = {Proceedings of the International Conference on Logic Programming},
   TITLE        = {A generic approach to monitor program executions},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {D. De Schreye},
   MONTH        = {November},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Monitoring, Trace analysis, Flexibility, 
      Logic programming, Mercury},
   URL          = {ftp://ftp.irisa.fr/local/lande/ej-md-iclp99.ps.gz},
   ABSTRACT     = { Monitoring requires to gather data about executions. 
      The monitoring functionalities currently available are built on top 
      of ad hoc instrumentations. Most of them are implemented at 
      low-level; in any case they require an in-depth knowledge of the 
      system to instrument. The best people to implement these 
      instrumentations are generally the implementors of the compiler. 
      They, however, cannot decide which data to gather. Indeed, hundreds 
      of variants can be useful and only end-users know what they want. In 
      this article, we propose a primitive which enables users to easily 
      specify what to monitor. It is built on top of the tracer of the 
      Mercury compiler. We illustrate how to use this primitive on two 
      different kinds of monitoring. Firstly, we implement monitors that 
      collect various kinds of statistics; each of them is well-known, the 
      novelty is that users can get exactly the variants they need. 
      Secondly, we define two notions of test coverage for logic programs 
      and show how to measure coverage rates with our primitive. To our 
      knowledge no definition of test coverage exist for logic programming 
      so far. Each example is only a few lines of Mercury. Measurements 
      show that the performance of the primitive on the above examples is 
      acceptable for an execution of several millions of trace events. Our 
      primitive, although simple, lays the foundation for a generic and 
      powerful monitoring environment. }
}

@INPROCEEDINGS{jahier99b,
   AUTHOR       = {E. Jahier and M. Ducassé},
   BOOKTITLE    = {Actes des Journées francophones de Programmation Logique et par Contraintes},
   TITLE        = {Un traceur d'exécutions de programmes ne sert pas qu'au 
      débogage},
   YEAR         = {1999},
   ADDRESS      = {Lyon},
   OPTCROSSREF  = {},
   EDITOR       = {F. Fages},
   MONTH        = {juin},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Hermès},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Dynamic analysis, Trace analysis, Monitoring, 
      Measure of test coverage, Logic programming, Mercury},
   URL          = {ftp://ftp.irisa.fr/local/lande/ej-md-jfplc99.ps.gz},
   ABSTRACT     = {In this paper we show that a tracer with a trace 
      analyser can be used to achieve more than debugging. We first 
      illustrate how to compute coverage ratios for test cases. We also 
      give 4 examples to monitor the behavior of programs. Thus, instead of 
      building ad hoc instrumentations, which is currently the case for 
      such tools, one can use a uniform environment which allows a synergy 
      between the tools to take place. As a matter of fact, while studying 
      the test coverage measurement we enriched the trace information, to 
      the benefit of the other tools. Moreover, ad hoc instrumentations 
      require an in depth knowledge of the system to instrument, either at 
      low level or by source to source transformation. Even it is not 
      technically difficult, it always requires a significant programming 
      effort. On the opposite, with our approach, the instrumentation is 
      generic. It is done once for all, and the specific analyses can be 
      relatively simple. The examples of this article consist of less than 
      a dozen of Prolog lines each.}
}

@INPROCEEDINGS{jahier99e,
   AUTHOR       = {E. Jahier and M. Ducassé and O. Ridoux},
   BOOKTITLE    = {Proc. of ICLP'99 Workshop on Logic Programming Environments},
   TITLE        = {Specifying trace models with a continuation semantics},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Ducassé and A. Kusalik and L. Naish and G. Puebla},
   OPTMONTH     = {},
   NOTE         = {LPE'99},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {trace models, continuation semantics, specification, 
      validation, Logic programming},
   URL          = {ftp://ftp.irisa.fr/local/lande/ej-md-or-lpe99.ps.gz},
   ABSTRACT     = {In this article, we have give a formal specification of 
      Byrd's box model and we show how this specification can be extended 
      to specify richer trace models. We have also sho how these 
      specifications can be executed by a direct translation into 
      lambda-Prolog, leading to a Prolog interpreter that performs 
      execution traces. This interpreter can be used both to experiment 
      various trace models and to validate the different event 
      specifications. Hence we have a formal framework to specify and 
      prototype trace models.}
}

@INPROCEEDINGS{sm-iclp99,
   AUTHOR       = {S. Mallet and M. Ducassé},
   BOOKTITLE    = {Proceedings of the International Conference on Logic Programming},
   TITLE        = {Generating deductive database explanations},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {D. De Schreye},
   MONTH        = {November},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {deductive databases, debugging, trace, 
      operational semantics, multi-SLD-AL, meta-interpreter, 
      substitution set, instrumentation},
   URL          = {ftp://ftp.irisa.fr/local/lande/sm-md-iclp99.ps.gz},
   ABSTRACT     = {Existing explanation systems for deductive databases 
      show forests of proof trees. Although proof trees are often useful, 
      they are only one possible interesting representation. We argue that 
      an explanation system for deductive databases must be able to 
      generate explanations at several levels of abstraction. One possible 
      and well known technique to achieve this flexibility is to instrument 
      meta-interpreters. It is, however, not often used because of its 
      inefficiency. On the other hand, deductive databases often generate 
      intermediate information stored in the physical database. This 
      information can be considered as a low-level trace giving a faithful 
      picture of what has happened at the relational level. The deductive 
      reasoning is lost but can be very easily recovered by a 
      meta-interpreter. In this article we describe a technique to generate 
      explanations by integrating a relational trace and an instrumented 
      meta-interpreter. The expensive aspects of meta-interpretation are 
      reduced by the use of the trace which avoids many costly 
      calculations. The flexibility of meta-interpretation is preserved, as 
      illustrated by the generation of three different kinds of 
      explanations: a box-oriented trace, a multi-SLD-AL tree and abstract 
      AND trees. This technique enables powerful explanation systems to be 
      implemented with very few modifications of the deductive database 
      mechanism itself.}
}

@INPROCEEDINGS{smallet99b,
   AUTHOR       = {S. Mallet and M. Ducassé},
   BOOKTITLE    = {LOgic-based Program Synthesis and TRansformation},
   TITLE        = {Myrtle: A set-oriented meta-interpreter driven by a 
      ``relational'' trace for deductive database debugging},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {P. Flener},
   OPTMONTH     = {},
   NOTE         = {Résumé, version complète en RR-3598 INRIA},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {328-330},
   PUBLISHER    = {Springer-Verlag, LNCS 1559},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@INPROCEEDINGS{dlm-van-or-lopstr99,
   AUTHOR       = {D. Le Métayer and V.-A. Nicolas and O. Ridoux},
   BOOKTITLE    = {LOPSTR'99 (International Workshop on Logic Program Synthesis and Transformation)},
   TITLE        = {Verification by testing for recursive program schemes},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, LNCS},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Software engineering, program verification, 
      white-box testing, automated test data generation, program analysis, 
      program schemes},
   URL          = {http://www.irisa.fr/lande/vnicolas/articleLNCS99.pdf},
   ABSTRACT     = {In this paper, we explore the testing-verification 
      relationship with the objective of mechanizing the generation of test 
      data. We consider program classes defined as recursive program 
      schemes and we show that complete and finite test data sets can be 
      associated with such classes, that is to say that these test data 
      sets allow us to distinguish every two different functions in these 
      schemes. This technique is applied to the verification of simple 
      properties of programs.}
}

@INPROCEEDINGS{RID99,
   AUTHOR       = {Olivier Ridoux and Patrice Boizumault and 
      Frédéric Malésieux},
   BOOKTITLE    = {Proc. of the Int. Symp. on Functional and Logic Programming},
   TITLE        = {Typed static analysis: application to groundness 
      analysis of LambdaProlog and Prolog},
   YEAR         = {1999},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {A. Middeldorp and T. Sato},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@TECHREPORT{FerRid1999,
   AUTHOR       = {S. Ferré and O. Ridoux},
   INSTITUTION  = {Inria, Institut National de Recherche en Informatique et en Automatique},
   TITLE        = {Une généralisation logique de l'analyse de concepts 
      logique},
   YEAR         = {1999},
   OPTADDRESS   = {},
   MONTH        = {December},
   OPTNOTE      = {},
   NUMBER       = {RR-3820},
   TYPE         = {Technical Report},
   ANNOTE       = {FCA,logic,SI},
   KEYWORDS     = {concept analysis, concept lattice, logic, context, 
      information systems, querying, browsing},
   PAGES        = {26 p.},
   URL          = {http://www.inria.fr/rrrt/rr-3820.html},
   ABSTRACT     = {Nous proposons une généralisation de l'analyse de 
      concepts formels (ACF) dans laquelle les ensembles d'attributs sont 
      remplacés par des expressions d'une logique presque arbitraire. Nous 
      prouvons que toute l'ACF peut être reconstruite sur cette base. Nous 
      montrons qu'à partir de toute logique utilisée à la place des 
      ensembles d'attributs, on peut dériver une logique contextualisée qui 
      prend en compte le contexte formel et qui est isomorphe au treillis 
      de concepts. Nous comparons ensuite la généralisation de l'ACF aux 
      extensions qui y ont déjà été apportées. Enfin, nous présentons nos 
      perspectives d'application aux systèmes d'information.}
}

@TECHREPORT{sm-rr99,
   AUTHOR       = {S. Mallet and M. Ducassé},
   INSTITUTION  = {INRIA},
   TITLE        = {Myrtle: A set-oriented meta-interpreter driven by a 
      ``relational'' trace for deductive database debugging},
   YEAR         = {1999},
   OPTADDRESS   = {},
   MONTH        = {January},
   OPTNOTE      = {},
   NUMBER       = {RR-3598},
   TYPE         = {Research Report},
   KEYWORDS     = {deductive databases, debugging, trace, multi-SLD-AL, 
      meta-interpreter, substitution set, instrumentation},
   URL          = {http://www.inria.fr/rrrt/rr-3598.html},
   ABSTRACT     = {Deductive databases manage large quantities of data and, 
      in general, in a set-oriented way. The existing systems of 
      explanation for deductive databases do not take these constraints 
      into account. We propose a tracing technique which consists of 
      integrating a "relational" trace and an instrumented meta-interpreter 
      using substitution sets. The relational trace efficiently gives 
      precise information about data extraction from the relational 
      database. The meta-interpreter manages substitution sets and gives 
      explanation on the deduction. The expensive aspects of 
      meta-interpretation are reduced by the use of the trace which avoids 
      many calculations. The flexibility of meta-interpretation is 
      preserved. It allows different profiles of trace to be easily 
      produced.}
}

@MANUAL{ducasse99e,
   TITLE        = {An automated debugger for Mercury - Opium-M 0.1 User and 
      reference manuals},
   OPTADDRESS   = {},
   AUTHOR       = {M. Ducassé and E. Jahier},
   OPTEDITION   = {},
   MONTH        = {mai},
   NOTE         = {RT-231 INRIA (aussi PI-1234 IRISA)},
   OPTORGANIZATION = {},
   YEAR         = {1999}
}

@MANUAL{jahier99,
   TITLE        = {Opium-M 0.1 User and Reference Manuals},
   ADDRESS      = {IRISA, Rennes},
   AUTHOR       = {E. Jahier and M. Ducassé},
   OPTEDITION   = {},
   MONTH        = {March},
   OPTNOTE      = {},
   OPTORGANIZATION = {},
   YEAR         = {1999},
   KEYWORDS     = {Logic programming, Mercury, Trace analyser, 
      Trace query language, Automated debugging, User manual, 
      Reference manual},
   URL          = {http://www.irisa.fr/EXTERNE/projet/lande/jahier/download.html},
   ABSTRACT     = {This document gathers the user manual and the reference 
      manual of Opium-M, an analyser of execution traces of Mercury 
      Programs. Opium-M is an adaptation to Mercury of Opium a trace 
      analyser for Prolog. Mercury is a new logic programming language. Its 
      type, mode and determinism declarations enable codes to be generated 
      that is at the same time more efficient and more reliable than with 
      current logic programming languages. The deterministic parts of 
      Mercury programs are as efficient as their C counterparts. Moreover, 
      numerous mistakes are detected at compilation time. However, our 
      industrial partner experience shows that the fewer remaining 
      mistakes, the harder they are to be diagnosed. A high-level debugging 
      tool was thus necessary. Program execution traces given by 
      traditional debuggers provide programmers with useful pieces of 
      information. However, using them requires to analyse by hand huge 
      amounts of information. Opium-M is connected to the traditional 
      tracer of Mercury, it allows execution trace analyses to be 
      automated. It provides a relational trace query language based on 
      Prolog which enables users to specify precisely what they want to see 
      in the trace. Opium-M, then, automatically filters out information 
      irrelevant for the users.}
}

@ARTICLE{dlm-van-or-IEEEsoftware98,
   AUTHOR       = {D. Le Métayer and V.-A. Nicolas and O. Ridoux},
   JOURNAL      = {IEEE Software},
   TITLE        = {Programs, Properties, and Data: Exploring the Software 
      Development Trilogy},
   YEAR         = {1998},
   MONTH        = {November/December},
   OPTNOTE      = {},
   NUMBER       = {6},
   PAGES        = {75-81},
   VOLUME       = {15},
   KEYWORDS     = {Software engineering, testing, verification, 
      program analysis, program learning},
   URL          = {http://www.irisa.fr/lande/vnicolas/articleIEEE98.pdf},
   ABSTRACT     = {Software development usually involves a collection of 
      properties, programs and data as input or output documents. Putting 
      these three kinds of documents at the vertices of a triangle, one 
      sees that all three sides of the triangle have been exploited in 
      formal methods, and that they have often been used in both 
      directions. However, richer combinations have seldom been envisaged, 
      and formal methods often amount to a strict orientation of the figure 
      by imposing functional dependencies (e.g.,~infering test cases from 
      specifications). Moreover, undecidability problems arise when 
      properties are expressed in full predicate logic (or similar 
      formalisms) or programs are written in Turing-equivalent programming 
      languages. We advocate that (1) formal methods should provide more 
      flexible ways to exploit the developer's knowledge and offer a 
      variety of possibilities to construct programs, properties and test 
      data and (2) it is worth restricting the power of logic formalisms 
      and programming languages for the benefit of mechanization. We go one 
      step in this direction, and present a formal method for generating 
      test cases that combines techniques from abstract interpretation 
      ({\em program -> property}) and testing ({\em program+property -> 
      test data}), and takes inspiration from automated learning (test 
      generation via a {\em testing bias}). The crucial property of the 
      test suites generated this way is that they are robust with respect 
      to a test objective formalized as a property. In other words, if a 
      program passes the test suite, then it is guaranteed to satisfy the 
      property. As this process leads to decision problems in very 
      restricted formalisms, it can be fully mechanized.}
}

@INPROCEEDINGS{ducasse98c,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {B'98, Proceedings of the Educational Session},
   TITLE        = {Teaching B at a Technical University is Possible and 
      Rewarding},
   YEAR         = {1998},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {H. Habrias and S. E. Dunn},
   MONTH        = {avril},
   NOTE         = {ISBN: 2-9512461-0-2},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Association de Pilotage des Conférences B, Nantes},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {B formal method, teaching},
   URL          = {http://www.irisa.fr/lande/ducasse/B-edu-98.ps.gz},
   ABSTRACT     = {In January 1994, to replace a highly unpopular 
      denotational semantics course, I undertook to set up a course on the 
      B method at the INSA of Rennes (Institut National des Sciences 
      Appliquées), at a Bac+4 level. I had almost no previous knowledge of 
      formal methods. I had, however, programmed much in Prolog and felt 
      the need for a strong programming discipline, supported if possible 
      by methods and tools. The experience is, in my opinion, successful. 
      The students do learn much during the course, find interesting 
      placements where their competence is appreciated and every occurrence 
      of the course teaches me something. In the article, I first list 
      reasons to start the experience. I then discuss the pedagogical 
      objectives of the course. The contents of the course is given and an 
      assessment is made.}
}

@INPROCEEDINGS{ducasse98b,
   AUTHOR       = {M. Ducassé and J. Noyé},
   BOOKTITLE    = {IJCSLP'98 Post-conference workshop on Implementation Technologies for Programming Languages based on Logic.},
   TITLE        = {Tracing Prolog Programs by Source Instrumentation is 
      Efficient Enough},
   YEAR         = {1998},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {K. Sagonas},
   MONTH        = {June},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Debugging, tracing, source to source transformation, 
      benchmarking, Prolog},
   URL          = {http://www.irisa.fr/lande/ducasse/ducasse-noye-manchester-98.ps.gz},
   ABSTRACT     = {Tracing by automatic program source instrumentation has 
      major advantages over compiled code instrumentation: it is more 
      portable, it benefits from many compiler optimizations, it produces 
      traces in terms of the original program, and it can be tailored to 
      specific debugging needs. The usual argument in favor of compiled 
      code instrumentation is its supposed efficiency. We have compared the 
      performance of two operational low-level Prolog tracers with source 
      instrumentation. We have executed classical Prolog benchmark 
      programs, collecting trace information without displaying it. On 
      average, collecting trace information by program instrumentation is 
      about as fast as using a low-level tracer in one case, and only twice 
      slower in the other. This is a minor penalty to pay, compared to the 
      advantages of the approach. To our knowledge, this is the first time 
      that a quantitative comparison of both approaches is made for any 
      programming language. }
}

@INPROCEEDINGS{mallet98a,
   AUTHOR       = {S. Mallet and M. Ducassé},
   BOOKTITLE    = {Journées francophones de Programmation Logique et programmation par Contraintes},
   TITLE        = {Pilotage d'un méta-interprète ensembliste par une trace 
      ``relationnelle'' pour le débogage de bases de données déductives},
   YEAR         = {1998},
   ADDRESS      = {Nantes},
   OPTCROSSREF  = {},
   EDITOR       = {O. Ridoux},
   MONTH        = {mai},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   ORGANIZATION = {JFPLC'98},
   PAGES        = {151-165},
   PUBLISHER    = {Hermes},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {bases de données déductives, débogage, trace, 
      sémantique opérationnelle, multi-SLD-AL, méta-interprète, 
      ensembles de substitutions, instrumentation},
   URL          = {ftp://ftp.irisa.fr/local/lande/sm-md-jfplc98.ps.gz},
   ABSTRACT     = {Le développement des bases de données déductives 
      nécessite des outils, en particulier pour le débogage. Les bases de 
      données déductives gèrent des quantités importantes de données et, en 
      général, de manière ensembliste. Les systèmes d'explication existants 
      pour les bases de données déductives ne prennent pas en compte ces 
      contraintes. Nous proposons une technique de traçage qui consiste à 
      intégrer une trace ``relationnelle'' avec un méta-interprète 
      instrumenté utilisant des ensembles de substitutions. La trace 
      relationnelle donne, de manière efficace, de l'information précise 
      sur l'extraction de données de la base relationnelle. Le 
      méta-interprète ensembliste gère des ensembles de substitutions et 
      donne des explications sur la déduction. Les aspects coûteux de la 
      méta-interprétation sont réduits par l'utilisation de la trace qui 
      évite beaucoup de calculs. La flexibilité de la méta-interprétation 
      est conservée. Elle permet de produire facilement des traces de 
      profils différents.}
}

@TECHREPORT{ducasse98,
   AUTHOR       = {M. Ducassé},
   INSTITUTION  = {INRIA},
   TITLE        = {Coca: A Debugger for C Based on Fine Grained Control 
      Flow and Data Events},
   YEAR         = {1998},
   OPTADDRESS   = {},
   MONTH        = {septembre},
   OPTNOTE      = {},
   NUMBER       = {IRISA PI 1202 or INRIA RR-3489},
   OPTTYPE      = {},
   KEYWORDS     = {Software engineering, Programming environment, 
      Automated debugging, Trace query mechanism, Debugging language, 
      Program behavior understanding, C Debugging tool},
   URL          = {http://www.irisa.fr/lande/ducasse/coca-irisa-98.ps.gz},
   ABSTRACT     = {We present Coca, an automated debugger for C, where the 
      breakpoint mechanism is based on events related to language 
      constructs. Events have semantics whereas source lines used by most 
      debuggers do not have any. A trace is a sequence of events. It can be 
      seen as an ordered relation in a database. Users can specify 
      precisely which events they want to see by specifying values for 
      event attributes. At each event, visible variables can be queried. 
      The trace query language is Prolog with a handful of primitives. The 
      trace query mechanism searches through the execution traces using 
      both control flow and data whereas debuggers usually search according 
      to either control flow or data. As opposed to fully ``relational'' 
      debuggers which use plain database querying mechanisms, Coca trace 
      querying mechanism does not require any storage. The analysis is done 
      on the fly, synchronously with the traced execution. Coca is 
      therefore more powerful than ``source line'' debuggers and more 
      efficient than relational debuggers.}
}

@INPROCEEDINGS{mallet97b,
   AUTHOR       = {S. Mallet and M. Ducassé},
   BOOKTITLE    = {DDLP'97, Fifth International Workshop on Deductive Databases and Logic Programming},
   TITLE        = {An Informal Presentation of DDB Trees: A Basis for 
      Deductive Database Explanations},
   YEAR         = {1997},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Ulrich Geske},
   MONTH        = {July},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {GMD-Studien},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {debugging, explanations, deductive databases, 
      logic programming}
}

@INPROCEEDINGS{mallet97a,
   AUTHOR       = {S. Mallet and M. Ducassé},
   BOOKTITLE    = {AADEBUG'97,Third International Workshop on Automated Debugging},
   TITLE        = {DDB trees: a basis for deductive database explanations},
   YEAR         = {1997},
   ADDRESS      = {Linköping, Sweden},
   OPTCROSSREF  = {},
   EDITOR       = {Mariam Kamkar},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {87-102},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {debugging, explanations, deductive databases, 
      logic programming},
   URL          = {http://www.ep.liu.se/ea/cis/1997/009/09/},
   ABSTRACT     = {The power of deductive systems in general is that 
      programs express what should be done and not how it should be done. 
      Nevertheless, deductive systems need debugging and explanation 
      facilities. Indeed, their operational semantics is less abstract than 
      the declarative semantics of the programs. If users have to 
      understand all the low level details of the operational semantics 
      much of the benefits of using a deductive system is lost. Existing 
      explanation systems for deductive databases produce proof trees to be 
      shown to users. Although useful, proof trees give a fragmented view 
      of query evaluations, and users face a, most of the time large, 
      forest of proof trees. We propose a new data structure, called the 
      DDB tree, which merges the information of a proof tree forest into 
      one concise tree. A DDB tree gives a global picture of a query 
      evaluation in a dramatically reduced structure with no loss of 
      information. DDB trees can be shown to users or can be analyzed 
      further by an explanation system.}
}

@INPROCEEDINGS{dn96,
   AUTHOR       = {M. Ducassé and J. Noyé},
   BOOKTITLE    = {Proceedings of the poster session at JICSLP'96},
   TITLE        = {Tracing Prolog without a tracer},
   YEAR         = {1996},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {N. Fuchs and U. Geske},
   MONTH        = {September},
   NOTE         = {One page abstract also appears in Proc. of the JICSLP'96, MIT Press, ISBN 0-262-63173-3},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {223-232},
   PUBLISHER    = {GMD- Forschungszentrum Informationstechnik GMBH, GMD-STUDIEN Nr.296, ISBN3-88457-296-2},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Tracing by automatic program source instrumentation has 
      major advantages over compiled code instrumentation: it is cheaper to 
      develop and more portable, it benefits from most compiler 
      optimizations, it produces traces in terms of the original program, 
      and it can be tailored to specific debugging needs. The usual 
      argument in favor of compiled code instrumentation is its supposed 
      efficiency. Tolmach and Appel 1 designed and implemented a tracer for 
      Standard ML based on automatic program source instrumentation. The 
      resulting code runs only 3 times slower than optimized code. They 
      conjectured that a low-level tracer would run at about the same 
      speed. However they had no reasonable low-level tracer at hand to 
      actually compare their results with. We have performed such a 
      comparison in the context of Prolog, using the ECRC ECLiPSe 
      environment. The built-in low-level tracer of ECLiPSe is, at present, 
      one of the most interesting tracers for Prolog. We have compared it 
      with an instrumentation based on O'Keefe's "advice" utility 2 , made 
      compatible with the ECLiPSe tracer. We traced "standard" Prolog 
      benchmark programs 3 with both tracing techniques and measured the 
      resulting CPU times. On average the performances of both 
      implementations are equivalent: tracing Prolog programs by program 
      instrumentation is no slower than using a low-level tracer. To our 
      knowledge, this is the first time that a quantitative comparison of 
      both approaches is made. Another contribution is that our source 
      instrumentation is more complete than O'Keefe's advice package. In 
      particular, it deals with built-in predicates, and allows predicates 
      to be skipped/unskipped. ---------------------------------------- 1 
      A. Tolmach and A.W. Appel. A debugger for Standard ML. Journal of 
      Functional Programming, 5(2):155-200, April 1995. 2 The "advice" 
      utility is part of the DEC10 Prolog library, available by anonymous 
      ftp from the AIAI of the University of Edinburg 
      (aiai.edinburgh.ac.uk). 3 P. Van Roy and A. M. Despain. 
      High-performance logic programming with the Aquarius Prolog compiler. 
      Computer, 25(1):54-68, January 1992. }
}

@INPROCEEDINGS{louvet:parametric:plilp:96,
   AUTHOR       = {P. Louvet and O. Ridoux},
   BOOKTITLE    = {8th Int. Symp. Programming Languages Implementation and Logic Programming},
   TITLE        = {Parametric Polymorphism for Typed Prolog and 
      $\lambda$Prolog},
   YEAR         = {1996},
   ADDRESS      = {Aachen, Germany},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {47--61},
   OPTPUBLISHER = {},
   SERIES       = {LNCS},
   VOLUME       = {1140},
   KEYWORDS     = {Logic programming, typing, polymorphism, 
      second-order lambda-calculus.},
   URL          = {ftp://ftp.irisa.fr/local/lande/plor-plilp96.ps.gz},
   ABSTRACT     = {Typed Prolog and LambdaProlog are logic programming 
      languages with a strict typing discipline which is based on simple 
      types with variables. These variables are interpreted as denoting 
      generic polymorphism. Experiments show that this discipline does not 
      handle properly common logic programming practices used in Prolog. 
      For instance, the usual transformation for computing the Clark 
      completion of a Prolog program does not work well with some typed 
      programs. We observe that the head-condition is at the heart of these 
      problems, and conclude that it should be enforced. We propose a 
      second-order scheme which is compatible with usual practices. In this 
      scheme, type variables denote parametric polymorphism. It allows 
      quantifying types and terms, passing type and term parameters to 
      goals and terms, and to express type guards for selecting goals. We 
      give its syntax and deduction rules, and propose a solution to keep 
      the concrete notation of programs close to the usual one.}
}

@INPROCEEDINGS{ridoux:engineering:jicslp:96,
   AUTHOR       = {O. Ridoux},
   BOOKTITLE    = {Joint Int. Conf. and Symp. Logic Programming},
   TITLE        = {Engineering Transformations of Attributed Grammars in 
      $\lambda$Prolog},
   YEAR         = {1996},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Maher},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {244--258},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {Syntax-directed translation, grammar transformations, 
      logic grammars, DCG, LambdaProlog.},
   URL          = {ftp://ftp.irisa.fr/local/lande/or-jicslp96.ps.gz},
   ABSTRACT     = {An abstract representation for grammar rules that 
      permits an easy implementation of several attributed grammar 
      transformations is presented. It clearly separates the actions that 
      contribute to evaluating attribute values from the circulation of 
      these values, and it makes it easy to combine the representations of 
      several rules in order to build the representation of new rules. This 
      abstract form applies well to such transforms as elimination of 
      left-recursion, elimination of empty derivation, unfolding and 
      factorization. Finally, the technique is applied to DCGs and a 
      LambdaProlog implementation of the abstract form and of the 
      transforms is described.}
}

@INPROCEEDINGS{sm96,
   AUTHOR       = {S. Schoenig and M. Ducassé},
   BOOKTITLE    = {Static Analysis Symposium},
   TITLE        = {A Backward Slicing Algorithm for Prolog},
   YEAR         = {1996},
   ADDRESS      = {Aachen},
   OPTCROSSREF  = {},
   EDITOR       = {R. Cousot and D.A. Schmidt},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {317-331},
   PUBLISHER    = {Springer-Verlag, LNCS 1145},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {ftp://ftp.irisa.fr/local/lande/ssmd-sas96.ps.gz},
   ABSTRACT     = {Slicing is a program analysis technique originally 
      developed by Weiser for imperative languages. Weiser showed that 
      slicing is a natural tool for debugging, but it has other numerous 
      applications (program integration, program optimization, etc.) In 
      this article we describe a backward slicing algorithm for Prolog 
      which produces executable slices. The proposed algorithm is 
      applicable at least to pure Prolog extended by some simple built-in 
      predicates that handle the explicit unification =/2 and arithmetic. 
      To our knowledge, this algorithm is the first one to be proposed for 
      Prolog. Because of the indeterminism and lack of explicit control 
      flow of Prolog, existing algorithms cannot be trivially adapted. The 
      two main contributions of this paper are a general definition of 
      slicing adapted to Prolog and a slicing algorithm that produces 
      executable programs. }
}

@INPROCEEDINGS{sm96b,
   AUTHOR       = {S. Schoenig and M. Ducassé},
   BOOKTITLE    = {Actes des journées GDR programmation'96, Orléans},
   TITLE        = {Slicing pour programmes Prolog},
   YEAR         = {1996},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {Novembre},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Université de Bordeaux I},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {ftp://ftp.irisa.fr/local/lande/ssmd-gdr96.ps.Z},
   ABSTRACT     = {Le slicing est une technique d'analyse de programme 
      développée à l'origine par Weiser pour les langages impératifs. 
      Weiser a montré que le slicing est un outil naturel de débogage, mais 
      il a également de nombreuses autres applications (intégration de 
      programmes, optimisation, etc.) Dans cet article, nous proposons une 
      définition du slicing pour Prolog et un algorithme. Celui-ci est au 
      moins applicable à Prolog pur étendu par quelques prédicats de base 
      (=/2 et arithmétiques). À notre connaissance, cet algorithme est le 
      premier à être proposé pour Prolog. Les spécificités de Prolog 
      (indéterminisme et manque de flot de contr\^ole explicite), ne 
      permettent pas d'adapter trivialement les algorithmes existants pour 
      langages impératifs. }
}

@PROCEEDINGS{duc95b,
   TITLE        = {Proceedings of the 2nd International Workshop on 
      Automated and Algorithmic Debugging},
   YEAR         = {1995},
   ADDRESS      = {Saint Malo, France},
   EDITOR       = {M. Ducassé},
   MONTH        = {May},
   NOTE         = {see http://www.irisa.fr/EXTERNE/manifestations/AADEBUG95/},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PUBLISHER    = {IRISA, Campus de Beaulieu, F-35042 Rennes cedex},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@ARTICLE{belleannee:reconstruction:tsi:95,
   AUTHOR       = {C. Belleannée and P. Brisset and O. Ridoux},
   JOURNAL      = {Technique et science informatiques},
   TITLE        = {Une reconstruction pragmatique de $\lambda$Prolog},
   YEAR         = {1995},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   PAGES        = {1131--1164},
   VOLUME       = {14},
   KEYWORDS     = {Programmation logique, LambdaProlog, lambda-calcul, 
      quantifications, types. logic programming, LambdaProlog, 
      lambda-calculus, quantifications, types.},
   URL          = {ftp://ftp.irisa.fr/local/lande/cbpbor-tsi95.ps.Z},
   ABSTRACT     = {LambdaProlog est un langage de programmation logique 
      dont les clauses et les termes généralisent ceux de Prolog. On peut 
      se demander si toutes ces extensions sont nécessaires simultanément 
      et si des langages intermédiaires intéressants ne pourraient pas être 
      définis, au moins dans un but pédagogique. Nous répondons à cette 
      question en montrant que des liens de nécessité conduisent à adopter 
      toutes les extensions à partir de l'introduction du nouveau domaine 
      de termes. De cette reconstruction découle une heuristique de 
      programmation par induction sur les types qui est un guide commode 
      pour utiliser LambdaProlog. LambdaProlog is a logic programming 
      language in which clauses and terms are more general than in Prolog. 
      One may wonder whether these extensions are simultaneously needed, 
      and what are the useful subsets of LambdaProlog, at least for 
      pedagogical purposes. We answer this question by exhibiting necessity 
      links from the addition of the new term domain to the extension of 
      the formula language. A handy heuristic for programming by induction 
      on types can be derived from these links.}
}

@ARTICLE{coupet:use:jlp:95,
   AUTHOR       = {S. Coupet-Grimal and O. Ridoux},
   JOURNAL      = {J. Logic Programming},
   TITLE        = {On the use of Advanced Logic Programming Languages in 
      Computational Linguistics},
   YEAR         = {1995},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {1&2},
   PAGES        = {121--159},
   VOLUME       = {24},
   KEYWORDS     = {Logic programming, computational linguistics, 
      LambdaProlog, Prolog II, lambda-terms, rational terms.},
   URL          = {ftp://ftp.irisa.fr/local/lande/scor-jlp95.ps.Z},
   ABSTRACT     = {Computational Linguistics and Logic Programming have 
      strong connections, but the former uses concepts that are absent from 
      the most familiar implementations of the latter. We advocate that a 
      Logic Programming language need not feature the Computational 
      Linguistics concepts exactly, it must only provide a logical way of 
      dealing with them. We focus on the manipulation of higher-order terms 
      and the logical handling of context, and we show that the advanced 
      features of Prolog~II and LambdaProlog are useful for dealing with 
      these concepts. Higher-order terms are native in LambdaProlog, and 
      Prolog~II's infinite trees provide a handy data-structure for 
      manipulating them. The formula language of LambdaProlog can be 
      transposed in the Logic Grammar realm to allow for a logical handling 
      of context.}
}

@INPROCEEDINGS{duc95,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the 2nd International Workshop on Automated and Algorithmic Debugging},
   TITLE        = {Automated Debugging Extensions of the Opium Trace 
      Analyser},
   YEAR         = {1995},
   ADDRESS      = {Saint Malo, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {IRISA, Campus de Beaulieu, F-35042 Rennes cedex},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {ftp://ftp.irisa.fr/local/lande/md-aadebug95.ps.gz},
   ABSTRACT     = {Traces of program executions tell how programs behave in 
      given cases. They are a helpful source of information for automated 
      debugging. Opium is an automated trace analyser for Prolog programs. 
      It is programmable and extendable. It provides a trace query language 
      and abstract views of executions as a basis for automated debugging. 
      Opium has shown its capabilities to build abstract tracers and 
      automated debugging facilities. This paper lists the extensions 
      written so far, and describes two recent extensions: the abstract 
      tracers for the LO (Linear Objects) language and for the CHR 
      (Constraint Handling Rules) language. }
}

@INPROCEEDINGS{ridoux:imagining:sctcs:95,
   AUTHOR       = {O. Ridoux},
   BOOKTITLE    = {Constraint Programming: Basics and Trends. Selected papers of the 22nd Spring School in Theoretical Computer Science. LNCS 910},
   TITLE        = {Imagining CLP$(\Lambda,\equiv_{\alpha\beta})$},
   YEAR         = {1995},
   ADDRESS      = {Châtillon/Seine, France},
   OPTCROSSREF  = {},
   EDITOR       = {A. Podelski},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {209--230},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {CLP, LambdaProlog, lambda-calculus.},
   URL          = {ftp://ftp.irisa.fr/local/lande/or-spring95.ps.Z},
   ABSTRACT     = {We study under which conditions the domain of 
      lambda-terms and the equality theory of the lambda-calculus form the 
      basis of a usable constraint logic programming language (CLP). The 
      conditions are that the equality theory must contain axiom {$\eta$}, 
      and the formula language must depart from Horn clauses and accept 
      universal quantifications and implications in goals. In short, 
      CLP-lambda must be close to LambdaProlog.}
}

@ARTICLE{dn94,
   AUTHOR       = {M. Ducassé and J. Noyé},
   JOURNAL      = {The Journal of Logic Programming},
   TITLE        = {Logic Programming Environments: Dynamic program analysis 
      and debugging},
   YEAR         = {1994},
   MONTH        = {May/July},
   NOTE         = {Anniversary issue: Ten years of Logic Programming},
   OPTNUMBER    = {},
   PAGES        = {351-384},
   VOLUME       = {19/20},
   URL          = {http://www.irisa.fr/EXTERNE/bibli/pi/pi910.html},
   ABSTRACT     = {Programming environments are essential for the 
      acceptance of programming languages. This survey emphasizes that 
      program analysis, both static and dynamic, is the central issue of 
      programming environments. Because their clean semantics makes 
      powerful analysis possible, logic programming languages have an 
      indisputable asset in the long term. This survey is focused on logic 
      program analysis and debugging. The large number of references 
      provided show that the field, though maybe scattered, is active. A 
      unifying framework is given which separates environment tools into 
      extraction, analysis, and visualization. It facilitates the analysis 
      of existing tools and should give some guide lines to develop new 
      ones. Achievements in logic programming are listed; some techniques 
      developed for other languages are pointed out, and some trends for 
      further research are drawn. Among the main achievements are 
      algorithmic debugging, tracing for sequential Prolog, and abstract 
      interpretation. The main missing techniques are slicing, test case 
      generation, and program mutation. The perspectives we see are 
      integration, evaluation and, above all, automated static and dynamic 
      analysis. }
}

@INPROCEEDINGS{brisset:architecture:ilpsw:94,
   AUTHOR       = {P. Brisset and O. Ridoux},
   BOOKTITLE    = {ILPS'94 Workshop on Implementation Techniques for Logic Programming Languages},
   TITLE        = {The Architecture of an Implementation of 
      $\lambda$Prolog: Prolog/Mali},
   YEAR         = {1994},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   NOTE         = {Extended version of \citebo92b},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {See \citebo92b},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-w-ilps94.ps.Z},
   ABSTRACT     = {See \cite{bo92b}}
}

@INPROCEEDINGS{brisset:continuations:iclp:93,
   AUTHOR       = {P. Brisset and O. Ridoux},
   BOOKTITLE    = {10th Int. Conf. Logic Programming},
   TITLE        = {Continuations in $\lambda$Prolog},
   YEAR         = {1993},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {D.S. Warren},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {27--43},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {LambdaProlog, compilation, continuation, 
      exception handling.},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-iclp93.ps.Z},
   ABSTRACT     = {Continuations are well know in functional programming 
      where they have been used to transform and compile programs. Some 
      languages provide explicit manipulations of the continuation for the 
      user: The user can catch and modify the current continuation. 
      Continuations have also been used in the logic programming context to 
      give a denotational semantics for Prolog, to generate Prolog 
      compilers and to transform Prolog programs. In this paper, we propose 
      to introduce new built-ins in a logic programming language to enable 
      the user to explicitly replace the continuations. These built-ins 
      allow the user to have a new control of the execution. We choose 
      LambdaProlog because of its higher-order syntax and implications in 
      the goals which are necessary for the definition and use of these 
      built-ins. In order to define the built-ins, we extend to 
      LambdaProlog the Prolog semantics based on continuations. Then, we 
      show that an exception mechanism can be easily implemented using 
      these new built-ins. The proposed semantics is also used to prove 
      equivalence of goals changing the continuations.}
}

@INPROCEEDINGS{duc93b,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the First Workshop on Automated and Algorithmic Debugging},
   TITLE        = {A pragmatic survey of automated debugging},
   YEAR         = {1993},
   ADDRESS      = {Linkoeping, Sweden},
   OPTCROSSREF  = {},
   EDITOR       = {P. Fritzson},
   MONTH        = {May},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {Lecture Notes in Computer Sciences},
   VOLUME       = {749},
   URL          = {ftp://ftp.irisa.fr/local/lande/md-aadebug93.ps.gz},
   ABSTRACT     = {This article proposes a structuring view of the area of 
      automated debugging. Nineteen automated debugging systems are 
      analyzed. Thirteen existing automated debugging techniques are 
      briefly evaluated from a pragmatic point of view. The three 
      underlying strategies are identified, namely verification with 
      respect to specification, checking with respect to language knowledge 
      and filtering with respect to symptom. The verification strategy 
      compares the actual program with some formal specification of the 
      intended program. The checking strategy looks for suspect places 
      which do not comply with some explicit knowledge of the programming 
      language. The filtering strategy assumes correct parts of the code 
      which cannot be responsible for the error symptom. Assertion 
      evaluation and algorithmic debugging are the most promising 
      verification techniques. Some intrinsic limitations of the checking 
      strategy makes it only a complementary, though helpful, debugging 
      support. The slicing technique should be included in any debugger. }
}

@INPROCEEDINGS{lehuitouze:grammaires:jfpl:93,
   AUTHOR       = {S. Le Huitouze and P. Louvet and O. Ridoux},
   BOOKTITLE    = {Journées Francophones sur la Programmation en Logique},
   TITLE        = {Les grammaires logiques et $\lambda$Prolog},
   YEAR         = {1993},
   ADDRESS      = {Nîmes, France},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   NOTE         = {Version française de \citellr93},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {93--108},
   PUBLISHER    = {Teknea},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {LambdaProlog, grammaires logiques, portée, 
      représentation du contexte.},
   URL          = {ftp://ftp.irisa.fr/local/lande/slplor-jfpl93.ps.Z},
   ABSTRACT     = {La plupart des systèmes Prolog proposent un formalisme 
      de grammaire logique appelé DCG (Definite Clause Grammar), dont 
      l'utilité est reconnue. Nous présentons deux nouveaux formalismes de 
      grammaire logique appelé DCG' et lambda-HHG (higher-order Hereditary 
      Harrop Grammar)---grammaires héréditaires de Harrop d'ordre 
      supérieur) destinés à être utilisés dans les systèmes LambdaProlog. 
      Les relations entre DCG, DCG', et lambda-HHG, d'une part, et entre 
      Prolog et LambdaProlog, d'autre part, peuvent être résumées de la 
      manière suivante. (1) Prolog, DCG et la traduction de DCG en Prolog 
      sont classiques. (2) Miller propose l'évolution de Prolog à 
      LambdaProlog, et Pereira, Pareschi et Miller montrent l'intérêt 
      d'utiliser LambdaProlog pour le traitement de la langue naturelle. 
      (3) Nous proposons une variante fortement typée de DCG (appelée) afin 
      de pouvoir la traduire en LambdaProlog dans le système LambdaProlog. 
      C'est un premier pas vers un formalisme plus élaboré. (4) lambda-HHG 
      est à DCG ce que LambdaProlog est à Prolog. Ce formalisme combine les 
      avantages d'être grammatical et de cacher les opération d'un 
      analyseur (comme DCG), et d'avoir des termes d'ordre supérieur comme 
      attributs et de proposer une approche logique à la représentation des 
      contextes (comme LambdaProlog).}
}

@INPROCEEDINGS{llr93,
   AUTHOR       = {S. Le Huitouze and P. Louvet and O. Ridoux},
   BOOKTITLE    = {10th Int. Conf. Logic Programming},
   TITLE        = {Logic Grammars and $\lambda$Prolog},
   YEAR         = {1993},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {D.S. Warren},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {64--79},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {LambdaProlog, logic grammars, scope, 
      context handling in syntactic analysis.},
   URL          = {ftp://ftp.irisa.fr/local/lande/slplor-iclp93.ps.Z},
   ABSTRACT     = {A logic grammar formalism called DCG (Definite Clause 
      Grammars), which has proved to be useful, is part of most Prolog 
      implementations. We develop two new logic grammar formalisms called 
      DCG' and lambda-HHG (higher-order Hereditary Harrop Grammars) that 
      can be used in LambdaProlog implementations. The relations between 
      DCG, DCG', and lambda-HHG, and Prolog and LambdaProlog can be 
      summarized as follows: (1) The language Prolog, the DCG formalism, 
      and the translation of DCG into Prolog by Prolog are classical. (2) 
      The evolution from Prolog to LambdaProlog is due to Miller and the 
      advantage of using LambdaProlog for doing natural language analysis 
      is shown by Pereira, and Pareschi and Miller. (3) We propose a 
      strongly typed variant of DCG (called DCG') for its translation into 
      LambdaProlog by LambdaProlog. It is a first stage towards a more 
      elaborate formalism. (4) A formalism that is to DCG what LambdaProlog 
      is to Prolog is still missing, and also the way to translate it into 
      LambdaProlog. Such a formalism combines the advantage of being 
      grammatical and hiding the house-keeping operations (like DCG) and of 
      having higher-order terms as attributes and providing a logical 
      approach to context (like LambdaProlog). lambda-HHG is such a 
      formalism.}
}

@TECHREPORT{brisset:compilation:inria:93,
   AUTHOR       = {P. Brisset and O. Ridoux},
   INSTITUTION  = {INRIA},
   TITLE        = {The Compilation of $\lambda$Prolog and its execution 
      with MALI},
   YEAR         = {1993},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {1831},
   TYPE         = {Rapport de recherche},
   KEYWORDS     = {See \citebo92a},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-tr-irisa687-92.ps.Z},
   ABSTRACT     = {See \cite{bo92a}}
}

@PROCEEDINGS{dly92,
   TITLE        = {Proceedings of IJCSLP'92 Workshop on Logic Programming 
      Environments},
   YEAR         = {1992},
   OPTADDRESS   = {},
   EDITOR       = {M. Ducassé and Y.-J. Lin and L.Ü. Yalcinalp},
   MONTH        = {November},
   NOTE         = {Technical Report TR 92-143, Case Western Reserve University, Cleveland},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@PHDTHESIS{duc92,
   AUTHOR       = {M. Ducassé},
   SCHOOL       = {University of Rennes I, France},
   TITLE        = {An extendable trace analyser to support automated 
      debugging},
   YEAR         = {1992},
   OPTADDRESS   = {},
   MONTH        = {June},
   NOTE         = {European Doctorate},
   OPTTYPE      = {},
   ABSTRACT     = {The dissertation describes the innovative features of 
      Opium, a high-level debugging environment for Prolog, designed and 
      implemented at ECRC between 1985 and 1991. Debugging is a costly 
      process, and automating it would significantly reduce the cost of 
      software production and maintenance. However, it is unrealistic to 
      aim at fully automating the task. In particular programmers have to 
      understand rapidly changing situations, examining large amounts of 
      data. In the current state of the art it is beyond the capabilities 
      of computers to take the place of programmer's understanding. 
      Nevertheless, computers can significantly help programmers to select 
      the data to be analysed. The data used by program analysis in general 
      is often restricted to the source code of the analysed programs. 
      However, there is a complementary source of information, namely 
      traces of program executions. An execution trace contains less 
      general information than the program source, but it tells how the 
      program behaves in a particular case. Furthermore, there are 
      intrinsically dynamic aspects in a program which are best analysed at 
      execution time, for example uses of read/write. These remarks 
      suggested to build the automated debugging functionalities of Opium 
      on top of an existing tracer, extending it to a general trace and 
      source analyser. The most important features of Opium, not to be 
      found in other debuggers, are as follows. - It provides a trace query 
      language which is a solution to the ever growing command sets of 
      other tracers. With two primitives plus Prolog, users can already 
      specify more precise trace queries than with the hard coded commands 
      of other tracers. - Opium is programmable and extendable. It is thus 
      an environment where debugging strategies can be easily programmed 
      and integrated. Some strategies are already implemented. - Abstract 
      views of executions are proposed as a basis for automated debugging. 
      They help users to understand the behaviours of programs by browsing 
      through executions at a higher level than single steppers. Opium is 
      fully implemented. More than 20 academic sites have recently 
      requested Opium prototype, and some are actually implementing new 
      abstract views. }
}

@INPROCEEDINGS{bekkers:dynamic:iwmm:92,
   AUTHOR       = {Y. Bekkers and O. Ridoux and L. Ungaro},
   BOOKTITLE    = {Int. Worshop on Memory Management},
   TITLE        = {Dynamic Memory Management for Sequential Logic 
      Programming Languages},
   YEAR         = {1992},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {Y. Bekkers and J. Cohen},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {82--102},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {LNCS},
   VOLUME       = {637},
   KEYWORDS     = {Memory management, logic programming, 
      garbage collection, usefulness logic.},
   URL          = {ftp://ftp.irisa.fr/local/lande/yborlu-iwmm92.ps.Z},
   ABSTRACT     = {Logic programming languages are becoming more complex 
      with the introduction of new features such as constraints or terms 
      with an equality theory. With this increase in complexity, they 
      require more and more sophisticated memory management. This survey 
      gives an insight into the memory management problems in sequential 
      logic programming languages implementations; it also describes the 
      presently know solutions. It is meant to be understood by 
      non-specialists in logic programming with good knowledge of memory 
      management in general. We first describe a "usefulness logic" for 
      run-time objects. Usefulness logic defines non-garbage objects. Next, 
      memory management systems are presented from the most trivial 
      original run-time system, with no real concern for memory problems, 
      to elaborated run-time systems with memory management closely 
      observing the usefulness logic. Finally, the choice of a garbage 
      collection technique is discussed in relation with logic programming 
      specifities.}
}

@INPROCEEDINGS{bo92b,
   AUTHOR       = {P. Brisset and O. Ridoux},
   BOOKTITLE    = {Workshop on $\lambda$Prolog},
   TITLE        = {The Architecture of an Implementation of 
      $\lambda$Prolog: Prolog/Mali},
   YEAR         = {1992},
   ADDRESS      = {Philadelphia},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {LambdaProlog, implementation, compilation, 
      memory management.},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-wlp92.ps.Z},
   ABSTRACT     = {LambdaProlog is a logic programming language accepting a 
      more general clause form than standard Prolog (namely hereditary 
      Harrop formulas instead of Horn formulas) and using simply typed 
      lambda-terms as a term domain instead of first order terms. Despite 
      these extensions, it is still amenable to goal-directed proofs and 
      can still be given procedural semantics. However, the execution of 
      LambdaProlog programs requires several departures from the standard 
      resolution scheme. First, the augmented clause form causes the 
      program (a set of clauses) and the signature (a set of constants) to 
      be changeable, but in a very disciplined way. Second, the new term 
      domain has a semi-decidable and infinitary unification theory, and it 
      introduces the need for a beta-reduction operation at run-time. MALI 
      is an abstract memory that is suitable for storing the search-state 
      of depth-first search processes. Its main feature is its efficient 
      memory management. We have used an original LambdaProlog-to-C 
      translation: predicates are transformed into functions operating on 
      several continuations. The compilation scheme is sometimes an 
      adaptation of the standard Prolog scheme, but at other times it has 
      to handle new features such as types, beta-reduction and delayed 
      unification. Two keywords of this implementation are "sharing" and 
      "folding" of representations. Sharing amounts to recognising that 
      some representation already exists and reusing it. Folding amounts to 
      recognising that two different representations represent the same 
      thing and replacing one by the other. We assume a basic knowledge of 
      Prolog and LambdaProlog.}
}

@INPROCEEDINGS{duc92f,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {International Symposium on Programming Language Implementation and Logic Programming},
   TITLE        = {A general trace query mechanism based on Prolog},
   YEAR         = {1992},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {M. Bruynooghe and M. Wirsing},
   MONTH        = {August},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {400-414},
   PUBLISHER    = {Springer-Verlag},
   SERIES       = {Lecture Notes in Computer Science},
   VOLUME       = {631},
   URL          = {ftp://ftp.irisa.fr/local/lande/md-plilp92.ps.gz},
   ABSTRACT     = {We present a general trace query language which is a 
      solution to the ever growing command sets of other tracers. It 
      provides all the required generality while being very simple and 
      efficient. We model a program execution into a trace which is a 
      stream of events. Execution events have a uniform representation, and 
      can be analysed by Prolog programs. With this approach and thanks to 
      the expressive power of Prolog, two high-level primitives plus Prolog 
      are enough to provide a general trace query language. With a few 
      optimizations this language can work on large executions without any 
      loss of performance, if compared to traditional tracers. This paper 
      describes the trace query mechanism from its high level specification 
      down to some implementation details. The proposed model of trace 
      query depends only on the sequentiality of the execution, and the 
      principles behind the design of the optimizations do not depend on 
      the traced language. }
}

@INPROCEEDINGS{duc92b,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of JICSLP'92 Workshop on Logic Programming Environments},
   TITLE        = {A trace analyser to prototype explanations},
   YEAR         = {1992},
   ADDRESS      = {Washington D.C.},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {November},
   NOTE         = {Technical Report TR 92-143, Case Western Reserve University, Cleveland},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {Automated debugging and expert system explanations have 
      in common to aim at helping people to understand executions. We have 
      designed an extendable trace analyser for the purpose of automated 
      debugging, which we propose to use to prototype expert system 
      explanations. Two examples illustrate how simple it is to implement 
      abstract tracing of executions and how easy it is to play with them. }
}

@INPROCEEDINGS{duc92c,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Actes des Journées Francophones sur la Programmation Logique},
   TITLE        = {Analysis of failing Prolog executions},
   YEAR         = {1992},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   OPTEDITOR    = {},
   MONTH        = {Mai},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPAGES     = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   ABSTRACT     = {The result of a Prolog execution can simply be ``no'', 
      when the programmer is expecting something else. This symptom is 
      typical of Prolog, and especially requires the help of an execution 
      tracer to get clues of what the problem can be. We present a solution 
      which helps programmers to understand how unexpected failures have 
      occurred. We first propose a hierarchy of failing goals. We argue 
      that there is one kind of leaf failures which is interesting to track 
      at the first place. Then we give the algorithm for our leaf failure 
      tracking and two examples illustrating its use. }
}

@INPROCEEDINGS{duc92d,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the Second Logic Programming Summer School},
   TITLE        = {Opium: An advanced debugging system},
   YEAR         = {1992},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {G. Comyn and N. Fuchs},
   MONTH        = {September},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   ORGANIZATION = {Esprit Network of Excellence in Computational Logic COMPULOG-NET},
   OPTPAGES     = {},
   PUBLISHER    = {Springer-Verlag, LNAI 636},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {ftp://ftp.irisa.fr/local/lande/md-lpss92.ps.gz},
   ABSTRACT     = {The data used by program analysis in general is often 
      restricted to the source code of the analysed programs. However, 
      there is a complementary source of information, namely traces of 
      program executions. Usual tracers, which extract this trace 
      information, do not allow for general trace analysis. Opium, our 
      debugger for Prolog, sets up a framework where program sources and 
      traces of program executions can be jointly analysed. As the 
      debugging process is heuristic and not all the debugging strategies 
      have been identified so far, Opium is programmable. In particular, 
      its trace query language gives more flexibility and more power than 
      the hard coded command sets of usual tracers. This trace query 
      language is based on Prolog. Opium is therefore both a helpful tool 
      for Prolog and a nice application of Prolog. The most innovative 
      extensions of Opium compute abstract views of Prolog executions to 
      help users understand the behaviours of programs. In particular they 
      help them understand how error symptoms have been produced. This 
      article briefly recalls some general information about Opium. A 
      debugging session is then commented in detail. }
}

@TECHREPORT{bo92a,
   AUTHOR       = {P. Brisset and O. Ridoux},
   INSTITUTION  = {IRISA},
   TITLE        = {The Compilation of $\lambda$Prolog and its execution 
      with MALI},
   YEAR         = {1992},
   OPTADDRESS   = {},
   OPTMONTH     = {},
   OPTNOTE      = {},
   NUMBER       = {687},
   TYPE         = {Publication Interne},
   KEYWORDS     = {LambdaProlog, implementation, compilation, 
      memory management.},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-tr-irisa687-92.ps.Z},
   ABSTRACT     = {We present a compiled implementation of LambdaProlog 
      that uses the abstract memory MALI for representing the execution 
      state. LambdaProlog is a logic programming language allowing a more 
      general clause form than Standard Prolog's (namely hereditary Harrop 
      formulas instead of Horn formulas) and using simply typed 
      lambda-terms as a term domain instead of first order terms. The 
      augmented clause form causes the program (a set of clauses) and the 
      signature (a set of constants) to be changeable in a very disciplined 
      way. The new term domain has a semi-decidable and infinitary 
      unification theory, and it introduces the need for a beta-reduction 
      operation at run-time. MALI is an abstract memory that is suitable 
      for storing the search-state of depth-first search processes. Its 
      main feature is its efficient memory management. We have used an 
      original LambdaProlog-to-C translation along which predicates are 
      transformed into functions operating on continuations for handling 
      failure and success in unifications, and changes in signatures and 
      programs. Two keywords of this implementation are ``sharing'' and 
      ``folding'' of representations. Sharing amounts to recognising that 
      some representation already exists and to reuse it. Folding amounts 
      to recognising that two different representations represent the same 
      thing and to replace one by the other.}
}

@PROCEEDINGS{df91,
   TITLE        = {Proceedings of ICLP'91 Workshop on Logic Programming 
      Environments},
   YEAR         = {1991},
   OPTADDRESS   = {},
   EDITOR       = {M. Ducassé and G. Ferrand},
   MONTH        = {June},
   NOTE         = {Technical Report, University of Orléans, France, LIFO N 91-61},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   OPTPUBLISHER = {},
   OPTSERIES    = {},
   OPTVOLUME    = {}
}

@ARTICLE{de91d,
   AUTHOR       = {M. Ducassé and A.-M. Emde},
   JOURNAL      = {ACM Software Engineering Notes},
   TITLE        = {Opium: a debugging environment for Prolog development 
      and debugging research},
   YEAR         = {1991},
   MONTH        = {January},
   NOTE         = {Demonstration presented at the Fourth Symposium on Software Development Environments},
   NUMBER       = {1},
   PAGES        = {54-59},
   VOLUME       = {16},
   ABSTRACT     = {Opium is an extensible debugging environment for PROLOG 
      providing high-level debugging facilities for programmers and 
      debugging experts. In the design of debuggers there are two tasks 
      which are often mixed, extraction and analysis of debugging 
      information. The aim of the extraction task is to collect the whole 
      debugging information so that users do not miss any important 
      information about their program. On the other hand, the aim of the 
      analysis task is to restrict in an accurate way the amount of 
      debugging information shown to the user so that the latter has to 
      examine only the relevant parts. This task clearly depends on the 
      debugging situation and, to our point of view, there is no general 
      restriction which can be done a priori. However, the two tasks are 
      usually mixed and hard-coded, the result is that not enough relevant 
      information and too much useless information is displayed. In Opium 
      the two tasks are clearly separated. The extraction module collects 
      the whole debugging information (execution trace and program source) 
      which is then available for the analysis module. The presentation 
      concentrates on the analysis module, discussing the main aspects of 
      Opium: programmability, high-level debugging, extensibility 
      mechanisms, meta-debugging, support for end-users and debugging 
      experts. }
}

@INPROCEEDINGS{brisset:naivereverse:iclp:91,
   AUTHOR       = {P. Brisset and O. Ridoux},
   BOOKTITLE    = {8th Int. Conf. Logic Programming},
   TITLE        = {Naïve Reverse Can Be Linear},
   YEAR         = {1991},
   OPTADDRESS   = {},
   OPTCROSSREF  = {},
   EDITOR       = {K. Furukawa},
   OPTMONTH     = {},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {857--870},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   KEYWORDS     = {LambdaProlog, implementation, function-lists, 
      higher-order unification.},
   URL          = {ftp://ftp.irisa.fr/local/lande/pbor-iclp91.ps.Z},
   ABSTRACT     = {We propose a new implementation of logic programming 
      with higher-order terms. In order to illustrate the properties of our 
      implementation, we apply the coding of lists as functions to the 
      context of logic programming. As a side-effect, we show that 
      higher-order unification is a good tool for manipulating the 
      function-lists. It appears that the efficiency of the program thus 
      obtained relies critically upon the implementation of higher-order 
      operations (unification and reduction). In particular, we show that a 
      good choice for data-structures and reduction strategy yields a 
      linear naïve reverse.}
}

@INPROCEEDINGS{duc91c,
   AUTHOR       = {M. Ducassé},
   BOOKTITLE    = {Proceedings of the International Logic Programming Symposium},
   TITLE        = {Abstract views of Prolog executions in Opium},
   YEAR         = {1991},
   ADDRESS      = {San Diego, USA},
   OPTCROSSREF  = {},
   EDITOR       = {V. Saraswat and K. Ueda},
   MONTH        = {October},
   OPTNOTE      = {},
   OPTNUMBER    = {},
   OPTORGANIZATION = {},
   PAGES        = {18-32},
   PUBLISHER    = {MIT Press},
   OPTSERIES    = {},
   OPTVOLUME    = {},
   URL          = {ftp://ftp.irisa.fr/local/lande/md-ilps91.ps.gz},
   ABSTRACT     = {Opium is a system for analysing and debugging Prolog 
      programs. Its kernel comprises an execution tracer and a programming 
      language with a full set of primitives for trace and source analysis. 
      In this paper we show the power of Opium for supporting abstract 
      views of Prolog executions. Abstract views give high-level points of 
      view about the execution. They filter out irrelevant details; they 
      restructure the remaining information; and they compact it so that 
      the amount of information given at each step has a reasonable size. 
      The examples of abstract views given in the following are a goal 
      execution profile, some data abstractions, an instantiation profile, 
      a failure analysis and a kind of explanation for an expert system 
      written in Prolog. }
}

@TECHREPORT{de91,
   AUTHOR       = {M. Ducassé and A.-M. Emde},
   INSTITUTION  = {ECRC},
   TITLE        = {A High-level Debugging Environment for Prolog. Opium 
      User's Manual},
   YEAR         = {1991},
   OPTADDRESS   = {},
   MONTH        = {May},
   OPTNOTE      = {},
   NUMBER       = {TR-LP-60},
   TYPE         = {Technical Report},
   URL          = {ftp://ftp.ecrc.de/pub/eclipse/doc/dvi/opium-manual.ps.Z}
}

